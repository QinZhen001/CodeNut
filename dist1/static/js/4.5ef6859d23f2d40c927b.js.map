{"version":3,"sources":["webpack:///static/js/4.5ef6859d23f2d40c927b.js","webpack:///./~/codemirror/addon/edit/closetag.js","webpack:///src/components/notes/notes.vue","webpack:///./~/codemirror/addon/search/matchesonscrollbar.js","webpack:///src/components/description/description.vue","webpack:///./src/components/hints/hints.vue?bc10","webpack:///src/components/description/myeditor.vue","webpack:///src/components/solution/solution.vue","webpack:///./src/common/js/problem.js?e44c","webpack:///./src/components/hints/hints.vue?9025","webpack:///./~/codemirror/keymap/sublime.js","webpack:///./src/components/description/description.vue","webpack:///./src/components/hints/hints.vue?ca96","webpack:///./~/codemirror/addon/search/search.js","webpack:///./src/components/description/description.vue?5239","webpack:///./src/components/problem-detail/problem-detail.vue?0244","webpack:///./src/components/problem-detail/problem-detail.vue?d96a","webpack:///./src/components/description/runresultdialog.vue","webpack:///./~/codemirror/keymap/vim.js","webpack:///./src/components/description/runresultdialog.vue?8423","webpack:///./~/codemirror/addon/fold/foldgutter.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///./~/codemirror/addon/dialog/dialog.css?ae99","webpack:///./src/components/problem-detail/problem-detail.vue","webpack:///./~/codemirror/addon/hint/javascript-hint.js","webpack:///./src/components/solution/solution.vue?5bc7","webpack:///./~/codemirror/addon/search/match-highlighter.js","webpack:///./src/components/solution/solution.vue","webpack:///./src/components/problem-detail/problem-detail.vue?3a10","webpack:///./~/codemirror/addon/scroll/annotatescrollbar.js","webpack:///src/components/description/runresultdialog.vue","webpack:///./src/components/description/myeditor.vue","webpack:///./~/codemirror/addon/dialog/dialog.css","webpack:///./~/codemirror/addon/dialog/dialog.js","webpack:///./src/components/notes/notes.vue?0fae","webpack:///./~/codemirror/addon/fold/foldcode.js","webpack:///./~/codemirror/addon/fold/xml-fold.js","webpack:///./~/codemirror/addon/fold/indent-fold.js","webpack:///./~/codemirror/addon/selection/mark-selection.js","webpack:///./src/components/description/myeditor.vue?236d","webpack:///./src/components/solution/solution.vue?9e91","webpack:///./src/components/description/myeditor.vue?8c1e","webpack:///./~/codemirror/addon/fold/foldgutter.css?9068","webpack:///./~/codemirror/addon/comment/comment.js","webpack:///./~/codemirror/addon/selection/active-line.js","webpack:///./src/components/notes/notes.vue?6f3e","webpack:///./~/codemirror/addon/edit/closebrackets.js","webpack:///./~/codemirror/addon/search/searchcursor.js","webpack:///./~/codemirror/addon/fold/markdown-fold.js","webpack:///./src/components/solution/solution.vue?aa1f","webpack:///./~/codemirror/addon/fold/foldgutter.css","webpack:///./src/components/description/myeditor.vue?4b3f","webpack:///./~/codemirror/addon/fold/brace-fold.js","webpack:///./src/components/description/description.vue?19a2","webpack:///./src/components/notes/notes.vue","webpack:///./src/components/notes/notes.vue?da57","webpack:///./~/codemirror/addon/hint/show-hint.js","webpack:///./~/file-saver/FileSaver.js","webpack:///./src/components/description/runresultdialog.vue?9e4f","webpack:///./src/components/hints/hints.vue","webpack:///(webpack)/buildin/amd-options.js","webpack:///./src/components/description/description.vue?3370","webpack:///./src/components/description/runresultdialog.vue?651d","webpack:///./src/common/js/ReturnResult.js","webpack:///./~/codemirror/addon/fold/comment-fold.js","webpack:///./~/codemirror/keymap/emacs.js","webpack:///./~/codemirror/addon/edit/matchbrackets.js","webpack:///src/components/problem-detail/problem-detail.vue"],"names":["webpackJsonp","+/ra","module","exports","__webpack_require__","mod","CodeMirror","autoCloseGT","cm","getOption","Pass","ranges","listSelections","replacements","i","length","empty","pos","head","tok","getTokenAt","inner","innerMode","getMode","state","mode","name","tagName","opt","html","configuration","dontCloseTags","htmlDontClose","indentTags","htmlIndent","end","ch","slice","lowerTagName","toLowerCase","type","test","string","charAt","indexOf","closingTagExists","indent","text","newPos","Pos","line","info","replaceRange","anchor","sel","setSelections","indentLine","autoCloseCurrent","typingSlash","start","replacement","context","getLine","replaceSelections","autoCloseSlash","collection","elt","e","newTag","scanForClosingTag","Math","min","lastLine","nextClose","tag","cx","onCx","prev","to","next","defineOption","val","old","Init","removeKeyMap","map","whenClosing","whenOpening","addKeyMap","commands","closeTag","+onj","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default","n","__WEBPACK_IMPORTED_MODULE_1_axios__","__WEBPACK_IMPORTED_MODULE_1_axios___default","__WEBPACK_IMPORTED_MODULE_2_common_js_data__","__WEBPACK_IMPORTED_MODULE_3_vuex__","props","String","default","data","note","noteDialogVisible","fileType","noteName","this","created","_this","_checkLogin","url","problem","id","a","get","then","response","msg","result","methods","_showSaveNoteDialog","saveNoteConfirm","FileSaver","blob","Blob","saveAs","undefined","$notify","title","message","_saveNote","_this2","put","user","user_id","computed","/A6h","SearchAnnotation","query","caseFold","options","annotateOptions","listenForChanges","prop","className","annotation","annotateScrollbar","gap","from","firstLine","matches","update","findMatches","self","on","changeHandler","_cm","change","onChange","offsetLine","changeStart","sizeChange","max","defineExtension","prototype","match","splice","cursor","getSearchCursor","maxMatches","findNext","startLine","endLine","changeEnd","newFrom","newTo","clearTimeout","setTimeout","updateAfterChange","clear","off","0CT/","__WEBPACK_IMPORTED_MODULE_0_components_description_myeditor__","Object","components","MyEditor","1LpH","content","locals","2hzx","__WEBPACK_IMPORTED_MODULE_1_codemirror_mode_javascript_javascript__","__WEBPACK_IMPORTED_MODULE_2_codemirror_mode_go_go__","__WEBPACK_IMPORTED_MODULE_3_codemirror_mode_python_python__","__WEBPACK_IMPORTED_MODULE_4_codemirror_mode_ruby_ruby__","__WEBPACK_IMPORTED_MODULE_5_codemirror_mode_clike_clike__","__WEBPACK_IMPORTED_MODULE_6_codemirror_theme_ambiance_css__","__WEBPACK_IMPORTED_MODULE_7_codemirror_theme_base16_dark_css__","__WEBPACK_IMPORTED_MODULE_8_codemirror_theme_cobalt_css__","__WEBPACK_IMPORTED_MODULE_9_codemirror_theme_paraiso_light_css__","__WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_dark_css__","__WEBPACK_IMPORTED_MODULE_11_codemirror_theme_rubyblue_css__","__WEBPACK_IMPORTED_MODULE_12_codemirror_theme_solarized_css__","__WEBPACK_IMPORTED_MODULE_13_codemirror_theme_mbo_css__","__WEBPACK_IMPORTED_MODULE_14_common_js_data__","__WEBPACK_IMPORTED_MODULE_15_axios__","__WEBPACK_IMPORTED_MODULE_15_axios___default","__WEBPACK_IMPORTED_MODULE_16_vuex__","__WEBPACK_IMPORTED_MODULE_17_common_js_ReturnResult__","__WEBPACK_IMPORTED_MODULE_18_components_description_runresultdialog__","code","templateCodes","Languages","editorModes","selectLanguage","editorThemes","selectTheme","keyMaps","selectkeyMap","editorOptions","tabSize","theme","lineNumbers","keyMap","foldGutter","gutters","styleSelectedText","highlightSelectionMatches","showToken","fullscreenLoading","Runresult","_getTempletCode","handleCommandLangage","command","console","log","JSON","parse","templet","find","item","defaultCode","handleCommandKeyMap","handleCommandTheme","onClickSubmit","post","language","mytitle","memory_used","toFixed","output","status","time_used","push","_showLoading","$refs","dialog","show","mag","error","onClickRun","_this3","patch","onClickCustom","str","_this4","RunResultDialog","47LY","solution","mounted","_getSolution","5Ey+","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default","Problem","_ref","level","description","accepted","submitted","like_nums","hate_nums","6rPU","render","_vm","_h","$createElement","_self","_c","_m","staticRenderFns","staticClass","_v","esExports","7Xsf","findPosSubword","doc","dir","clipPos","cat","isWordChar","toUpperCase","moveSubword","extendSelectionsBy","range","display","shift","extend","insertLine","above","isReadOnly","operation","len","newSelection","last","at","execCommand","wordAt","word","addCursorToSelection","newRanges","newAnchor","findPosV","newHead","newRange","isSelectedRange","selectBetweenBrackets","opening","scanForBracket","closing","mirror","sortLines","caseSensitive","selected","toSort","lines","getRange","sort","b","au","bu","modifyWordOrSelection","indices","cmpPos","getTarget","getCursor","findAndGoTo","forward","target","cur","findPrevious","setSelection","sublime","fallthrough","cmds","mac","macDefault","ctrl","goSubwordCombo","scrollLineCombo","getScrollInfo","somethingSelected","visibleBottomLine","lineAtHeight","top","clientHeight","scrollTo","defaultTextHeight","visibleTopLine","lineRanges","scroll","extended","fullWord","sublimeFindFullWord","RegExp","found","addSelection","addCursorToLineCombo","swapLineCombo","linesToMove","newSels","scrollIntoView","toggleComment","joined","offset","obj","actual","exec","rangeCount","marks","sublimeBookmarks","current","unshift","pop","findMarks","j","sublimeBookmark","k","markText","clearWhenEmpty","cK","cursors","indentUnit","toStartOfLine","column","countColumn","deletePos","findPosH","prevIndent","findColumn","sublimeMark","setBookmark","tmp","sublimeKilled","setCursor","replaceSelection","cursorCoords","bottom","selectLinesCombo","primaryIndex","normalizeKeyMap","8eAg","injectStyle","ssrContext","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_description_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4dfc5728_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_description_vue__","normalizeComponent","__vue_styles__","Component","8f5d","version","sources","names","mappings","file","sourcesContent","sourceRoot","CK2l","searchOverlay","caseInsensitive","replace","global","source","ignoreCase","token","stream","lastIndex","index","skipToEnd","SearchState","posFrom","posTo","lastQuery","overlay","getSearchState","search","queryCaseInsensitive","multiline","persistentDialog","deflt","onEnter","onKeyDown","openDialog","value","selectValueOnOpen","closeOnEnter","onClose","clearSearch","shortText","f","prompt","confirmDialog","fs","openConfirm","confirm","parseString","_","parseQuery","isRE","startSearch","queryText","removeOverlay","addOverlay","showMatchesOnScrollbar","annotate","doSearch","rev","persistent","immediate","q","getSelection","hiding","searchNext","event","e_stop","style","opacity","shiftKey","document","querySelector","wrapper","getBoundingClientRect","queryDialog","keyName","extra","cmd","callback","replaceAll","all","dialogText","replaceQueryDialog","replacementQueryDialog","advance","doReplaceConfirm","doReplace","findPersistent","findPersistentNext","findPersistentPrev","findPrev","CXwt","FVxK","Fvbh","Hid1","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_runresultdialog_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_d7772fc0_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_runresultdialog_vue__","Hyg2","defaultKeymap","keys","toKeys","action","motion","motionArgs","linewise","toJumplist","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","Vim","enterVimMode","setOption","signal","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","vim","detachVimMap","rmClass","getWrapperElement","attach","attachVimMap","addClass","cmKey","key","vimKey","cmKeyToVimKey","findKey","pieces","split","lastPiece","hasCharacter","piece","modifiers","specialKeys","isUpperCase","join","onPasteFn","insertMode","offsetCursor","actions","enterInsertMode","makeKeyRange","size","fromCharCode","isLine","isLowerCase","isMatchableSymbol","isNumber","numberRegex","isWhiteSpaceString","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","createInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","resetVimGlobalState","vimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","createCircularJumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","prefixRepeat","motionRepeat","keyBuffer","registerName","clearInputState","reason","Register","insertModeChanges","searchQueries","defineRegister","register","registers","validRegisters","unnamedRegister","historyBuffer","iterator","initialPrefix","defineMotion","fn","motions","fillArray","times","defineOperator","operators","defineAction","clipCursorToContent","includeLineBreak","maxCh","lineLength","copyArgs","args","ret","hasOwnProperty","offsetCh","getOffset","commandMatches","partial","full","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","lastChar","repeatFn","repeat","copyCursor","cursorEqual","cur1","cur2","cursorIsBefore","cursorMin","arguments","apply","Array","call","cursorMax","cursorIsBetween","cur3","cur1before2","cur2before3","lineNum","trim","s","escapeRegex","extendLineToColumn","endCh","spaces","selectBlock","selectionEnd","selections","isClipped","curHead","primIndex","getIndex","wasClipped","base","baseCh","headCh","newDir","selectForInsert","height","lineHead","atAnchor","atHead","getSelectedAreaRange","selectionStart","block","width","anchorMark","headMark","updateLastSelection","posFromIndex","indexFromPos","expandSelection","updateCmSelection","cmSel","makeCmSelection","primary","updateFakeCursor","exclusive","headOffset","anchorOffset","left","right","getHead","exitVisualMode","moveHead","clipToLine","curStart","curEnd","selection","expandSelectionToLine","findFirstNonWhiteSpaceCharacter","firstNonWS","expandWordUnderCursor","_forward","noSymbol","idx","wordCharTest","bigWordCharTest","wordStart","recordJumpPosition","oldCur","newCur","add","recordLastCharacterSearch","findSymbol","symb","lineCount","curCh","lineText","nextCh","lastCh","reverseSymb",")","}","(","{","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","moveToWord","words","eodCh","shortCircuit","firstWord","lastWord","moveToCharacter","character","charIdxInLine","moveToColumn","updateMark","markName","validMarks","includeChar","lastIndexOf","findParagraph","isEmpty","isBoundary","any","startState","selectCompanionObject","bracketRegexp","[","]","openSym","curChar","bracketRegex","findBeginningAndEnd","chars","firstIndex","searchState_","template","onKeyUp","splitBySlash","argString","slashes","findUnescapedSlashes","tokens","substring","escapeNextChar","c","translateRegex","specials","unescape","out","specialComesNext","translateRegexReplace","charUnescapes","unescapeRegexReplace","StringStream","eol","peek","matched","matcher","unescapes","smartCase","getRegister","setText","regexPart","forceIgnoreCase","showConfirm","openNotification","duration","alert","makePrompt","prefix","desc","raw","showPrompt","regexEqual","r1","r2","updateSearchQuery","rawQuery","highlightSearchMatches","getQuery","setQuery","matchSol","sol","backUp","searchState","getOverlay","getScrollbarAnnotate","setScrollbarAnnotate","setOverlay","clearSearchHighlight","isInRange","getUserVisibleLines","scrollInfo","coordsChar","bottomY","getMarkPos","history","done","mark","lineStart","lineEnd","searchCursor","replaceWith","newText","lastPos","close","focus","exMode","onPromptKeyDown","_value","savedCallback","exitInsertMode","insertModeChangeRegister","lastChange","selLength","inVisualBlock","changes","InsertModeKey","onKeyEventTargetKeyDown","repeatLastEdit","repeatOverride","toggleOverwrite","logInsertModeChange","_mapCommand","mapCommand","executeMacroRegister","exCommandDispatcher","processCommand","imc","handleKey","repeatInsertModeChanges","logKey","pushText","pushInsertModeChanges","logSearchQuery","pushSearchQuery","changeObj","expectCursorActivityForChange","origin","maybeReset","overwrite","curOp","isVimOp","handleExternalSelection","onKeyFound","lookupKey","repeatForInsert","repeatCommand","isAction","commandDispatcher","processAction","evalInput","repeatInsert","changeObject","cachedInputState","keyHandler","binding","lastSel","Shift","Ctrl","Alt","Cmd","Mod","Enter","Backspace","Delete","Insert","upperCaseAlphabet","lowerCaseAlphabet","numbers","concat","useNextSlot","pointer","trashMark","buffer","curMark","markPos","tail","move","inc","cachedCursor","exitMacroRecordMode","enterMacroRecordMode","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","lhs","rhs","ctx","unmap","defineEx","func","exCommands","commandMap_","handleMacroRecording","handleEsc","doKeyToKey","keysAreChars","matchCommand","thisMatch","window","here","keysMatcher","pushRepeatDigit","handleEx","input","getRepeat","parseInt","toString","isValidRegister","shiftNumericRegisters_","nextMatch","up","element","pushInput","reset","bestMatch","processMotion","processOperator","processOperatorMotion","processSearch","processEx","repeatIsExplicit","recordLastEdit","handleQuery","onPromptClose","originalScrollPos","onPromptKeyUp","parsedQuery","originalQuery","setReversed","promptPrefix","searchPromptDesc","isKeyword","exArgs","origHead","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","Infinity","lineOffset","abs","chOffset","operatorMoveTo","actionCommand","moveToTopLine","_head","moveToMiddleLine","floor","moveToBottomLine","expandToLine","isReversed","goToMark","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","moveByCharacters","moveByLines","moveByDisplayLines","moveByScroll","moveToEol","first","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","scrollbox","orig","dest","moveByWords","moveTillCharacter","moveToSymbol","retval","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","getTokenTypeAt","findMatchingBracket","moveToLineOrEdgeOfDocument","textObjectManipulation","mirroredPairs","selfPaired","'","\"","repeatLastCharacterSearch","lastSearch","moveH","finalHead","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","newlineAndIndent","delete","changeCase","getSelections","swapped","toSwap","yank","endPos","jumpListWalk","lineHeight","delta","ceil","newBottom","scrollToCursor","y","replayMacro","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineAndIndentContinueComment","paste","whitespaceLength","tabs","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","selectedText","emptyStrings","undo","redo","setRegister","setMark","replaceTo","replaceWithStr","incrementNumberToken","numberStr","lineStr","re","number","*","/","m","M","#","bracket","section","comment","method","preprocess","reversed","\\n","\\r","\\t","\\/","\\\\","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","mapping","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","setOptionReturn","setlocal","setglobal","regArgs","regInfo","compareFn","reverse","anum","bnum","radix","comparePatternFn","unique","pattern","err","eatSpace","opts","decimal","hex","octal","substr","numPart","textPart","matchPart","textOld","matchedLines","nextCommand","substitute","trailing","flagsPart","count","replacePart","startPos","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","detach","Iula","Kk9m","State","parseOptions","gutter","indicatorOpen","indicatorFolded","isFolded","__isFold","marker","spec","createElement","cloneNode","updateFoldInfo","minSize","foldOption","eachLine","setGutterMarker","updateInViewport","vp","getViewport","onGutterClick","folded","foldCode","rangeFinder","changeUpdate","foldOnChangeTimeSpan","onViewportChange","updateViewportTimeSpan","onFold","clearGutter","LGuY","LxZp","McHp","defineProperty","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_problem_detail_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4ad8a6d2_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_problem_detail_vue__","Mixr","forEach","arrayContains","scriptHint","editor","keywords","getToken","tprop","list","getCompletions","javascriptHint","javascriptKeywords","getCoffeeScriptToken","coffeescriptHint","coffeescriptKeywords","forAllProps","getOwnPropertyNames","getPrototypeOf","o","maybeAdd","gatherCompletions","stringProps","arrayProps","Function","funcProps","globalScope","additionalContext","useGlobalScope","jQuery","v","localVars","globalVars","registerHelper","OEy6","OkRY","defaults","timeout","matchesonscroll","active","cursorActivity","matchHighlighter","hasFocus","scheduleHighlight","onFocus","highlightMatches","delay","hasBoundary","makeOverlay","searchFor","wordsOnly","isWord","minChars","chr","boundariesAround","skipTo","P830","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_solution_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6701a6dc_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_solution_vue__","PdbZ","attrs","sm","lg","md","xs","align","_s","problemDetail","src","getFavoriteSrc","click","model","$$v","tab","expression","label","QSKu","Annotation","scheduleRedraw","doRedraw","redraw","buttonHeight","scrollButtonHeight","annotations","doUpdate","div","appendChild","cssText","computeScale","resizeHandler","hScale","barHeight","getScrollerElement","scrollHeight","compute","getY","curLine","curLineObj","getLineHandle","widgets","wrapping","singleLineH","heightAtLine","frag","createDocumentFragment","anns","barWidth","nextTop","ann","setAttribute","textContent","parentNode","removeChild","RBst","__WEBPACK_IMPORTED_MODULE_0_common_js_data__","dialogVisible","results","hide","getExplanation","RKlR","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myeditor_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_58438f59_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_myeditor_vue__","RkAk","RkhK","dialogDiv","wrap","innerHTML","closeNotification","newVal","currentNotificationClose","inp","closed","me","button","getElementsByTagName","select","onInput","keyCode","blur","closeOnBlur","callbacks","buttons","blurring","e_preventDefault","doneTimer","SVHh","visible","update:visible","$event","ref","label-width","slot","default_open","placeholder","THjC","doFold","force","allowFolded","finder","findMarksAt","cleared","myWidget","makeWidget","myRange","replacedWith","clearOnEnter","widget","createTextNode","foldOptions","defaultOptions","newFoldFunction","toggleFold","fold","unfold","foldAll","unfoldAll","funcs","helpers","getHelpers","auto","minFoldSize","scanUp","TQy8","cmp","Iter","tagAt","iter","nextLine","prevLine","toTagEnd","gt","lastSlash","selfClose","toTagStart","lt","xmlTagStart","toNextTag","toPrevTag","findMatchingClose","stack","startCh","findMatchingOpen","nameStartChar","openTag","findMatchingTag","open","findEnclosingTag","U3HU","lineIndent","lineNo","spaceTo","myIndent","lastLineInFold","U80t","markedSelection","coverRange","addAt","array","cls","markedSelectionStyle","CHUNK_SIZE","atEnd","coverStart","coverEnd","WD2d","trigger","menu-align","_l","directives","rawName","fullscreen","lock","element-loading-text","class","includes","XgT+","Xh4M","Yokd","Z6qg","nonWS","probablyInsideString","useInnerComments","getModeAt","noOptions","minLine","uncomment","lineComment","commentString","blockCommentStart","fullLines","blockComment","pad","padding","blankLines","commentBlankLines","baseString","whitespace","cut","startString","endString","blockCommentEnd","lastLineHasText","lead","blockCommentLead","didSomething","lineString","insideStart","insideEnd","lastStart","firstEnd","almostLastStart","openEnd","foundEnd","aGTD","clearActiveLines","activeLines","removeLineClass","WRAP_CLASS","BACK_CLASS","GUTT_CLASS","sameArray","updateActiveLines","nonEmpty","getLineHandleVisualStart","addLineClass","selectionChange","aOIS","aX1R","conf","getConfig","closeBrackets","override","handleBackspace","pairs","around","charsAround","handleEnter","explode","contractSelection","inverted","handleChar","triples","identical","curType","enteringString","isClosingBracket","stringStartsAfter","sels","triggerElectric","type1","bind","bp3c","c+I8","regexpFlags","regexp","flags","ensureGlobal","maybeMultiline","searchRegexpForward","searchRegexpForwardMultiline","chunk","before","inside","lastMatchIn","cutOff","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","adjustPos","foldFunc","mid","searchStringForward","noFold","cutFrom","searchStringBackward","topString","SearchCursor","atOccurrence","normalize","splitLines","defineDocExtension","dxBS","isHeader","tokentype","headerLevel","maxDepth","lastLineNo","nextNextLine","eg3M","domProps","_e","engA","f+y5","fo6W","findOpening","openCh","pass","tokenType","startToken","endToken","outer","nextOpen","hasImport","semi","has","hasInclude","fpaw","j09L","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_notes_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_c64ce914_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_notes_vue__","jCel","jQeI","Completion","debounce","tick","startLen","activityFunc","isNewCompletion","nw","hintOptions","hint","resolve","getText","completion","handle","addBinding","bound","baseMap","ourMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","pick","Tab","Esc","custom","customKeys","extraKeys","getHintElement","hintsElement","el","nodeName","Widget","picked","hints","selectedHint","completions","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","displayText","hintId","alignWithWord","below","winW","innerWidth","body","offsetWidth","documentElement","winH","innerHeight","offsetHeight","container","box","overlapY","scrolls","startScroll","overlapX","node","firstChild","nextSibling","paddingRight","nativeBarWidth","avoidWrap","changeActive","screenAmount","closeOnUnfocus","closingOnBlur","onBlur","onScroll","curScroll","newTop","point","pageYOffset","scrollTop","t","srcElement","completeOnSingleClick","applicableHelpers","supportsSelection","fetchHints","async","resolveAutoHints","resolved","run","app","getHelper","fromList","anyword","showHint","getHints","newOpts","completionActive","requestAnimationFrame","cancelAnimationFrame","closeCharacters","disable","myTick","finishUpdate","completeSingle","childNodes","offsetTop","term","autocomplete","lDdF","__WEBPACK_AMD_DEFINE_RESULT__","view","navigator","userAgent","get_URL","URL","webkitURL","save_link","createElementNS","can_use_save_link","MouseEvent","dispatchEvent","is_safari","HTMLElement","safari","is_chrome_ios","throw_outside","ex","setImmediate","revoke","revoker","revokeObjectURL","remove","dispatch","filesaver","event_types","listener","auto_bom","no_auto_bom","object_url","dispatch_all","readyState","INIT","createObjectURL","href","download","DONE","FileReader","reader","onloadend","location","readAsDataURL","FS_proto","msSaveOrOpenBlob","abort","WRITING","onwritestart","onprogress","onwrite","onabort","onerror","onwriteend","lL6t","lUyH","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hints_vue__","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hints_vue___default","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_062a844c_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_hints_vue__","nErl","__webpack_amd_options__","oFfA","q8U2","qnSv","ReturnResult","soCA","registerGlobalHelper","tjx/","posEq","addToRing","killRing","growRingTop","getFromRing","popFromRing","kill","mayGrow","lastKill","isClean","gen","changeGeneration","byChar","byWord","byLine","goalColumn","byPage","byParagraph","no","sawText","fst","lst","bySentence","sawWord","byExpr","strict","getPrefix","precise","digits","emacsPrefix","clearPrefix","repeated","findEnd","by","extendSelection","killTo","killRegion","addPrefix","digit","maybeClearPrefix","maybeDuplicateInput","arg","emacsPrefixMap","prefixPreservingKeys","dup","one","txt","addPrefixMap","prefixMap","maybeRemovePrefixMap","setExtending","getExtending","clearMark","getInput","operateOnWord","op","toEnclosingExpr","quit","regPrefix","d","Alt-G","Ctrl-X","Ctrl-Q","Ctrl-U","emacs","Ctrl-W","Ctrl-K","Alt-W","Ctrl-Y","Alt-Y","Ctrl-Space","Ctrl-Shift-2","Ctrl-F","Ctrl-B","Right","Left","Ctrl-D","Ctrl-H","Alt-F","Alt-B","Alt-D","Alt-Backspace","Ctrl-N","Ctrl-P","Ctrl-A","Ctrl-E","Alt-V","Ctrl-V","Ctrl-Up","Ctrl-Down","Alt-A","Alt-E","Alt-K","Ctrl-Alt-K","Ctrl-Alt-Backspace","Ctrl-Alt-F","Ctrl-Alt-B","Shift-Ctrl-Alt-2","Ctrl-Alt-T","leftStart","leftEnd","rightEnd","rightStart","Ctrl-Alt-U","Alt-Space","Ctrl-O","Ctrl-T","Alt-C","w","letter","Alt-U","Alt-L","Alt-;","Ctrl-/","Shift-Ctrl--","Ctrl-Z","Cmd-Z","Shift-Alt-,","Shift-Alt-.","Ctrl-S","Ctrl-R","Ctrl-G","Shift-Alt-5","Alt-/","Ctrl-J","Alt-G G","num","isNaN","Ctrl-X Tab","indentSelection","Ctrl-X Ctrl-X","Ctrl-X Ctrl-S","Ctrl-X Ctrl-W","Ctrl-X S","Ctrl-X F","Ctrl-X U","Ctrl-X K","Ctrl-X Delete","Ctrl-X H","Ctrl-Q Tab","vq+x","where","config","afterCursor","matching","maxScanLen","maxScanLineLength","maxScanLines","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","ie_lt8","focused","doMatchBrackets","currentlyHighlighted","documentMode","oldConfig","x494","__WEBPACK_IMPORTED_MODULE_1_vuex__","__WEBPACK_IMPORTED_MODULE_2_axios__","__WEBPACK_IMPORTED_MODULE_2_axios___default","__WEBPACK_IMPORTED_MODULE_3_components_description_description__","__WEBPACK_IMPORTED_MODULE_4_components_solution_solution__","__WEBPACK_IMPORTED_MODULE_5_components_hints_hints__","__WEBPACK_IMPORTED_MODULE_6_components_notes_notes__","__WEBPACK_IMPORTED_MODULE_7_common_js_problem__","__WEBPACK_IMPORTED_MODULE_8_common_js_data__","loading","_getProblemDetail","$router","hasCollect","deleteFavoriteList","saveFavoriteList","collectionList","findIndex","Description","Solution","Hints","Notes"],"mappings":"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","file":"static/js/4.5ef6859d23f2d40c927b.js","sourcesContent":["webpackJsonp([4],{\n\n/***/ \"+/ra\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Tag-closer extension for CodeMirror.\n *\n * This extension adds an \"autoCloseTags\" option that can be set to\n * either true to get the default behavior, or an object to further\n * configure its behavior.\n *\n * These are supported options:\n *\n * `whenClosing` (default true)\n *   Whether to autoclose when the '/' of a closing tag is typed.\n * `whenOpening` (default true)\n *   Whether to autoclose the tag when the final '>' of an opening\n *   tag is typed.\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\n *   An array of tag names that should not be autoclosed.\n * `indentTags` (default is block tags for HTML, none for XML)\n *   An array of tag names that should, when opened, cause a\n *   blank line to be added inside the tag, and the blank line and\n *   closing line to be indented.\n *\n * See demos/closetag.html for a usage example.\n */\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"TQy8\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../fold/xml-fold\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  CodeMirror.defineOption(\"autoCloseTags\", false, function(cm, val, old) {\n    if (old != CodeMirror.Init && old)\n      cm.removeKeyMap(\"autoCloseTags\");\n    if (!val) return;\n    var map = {name: \"autoCloseTags\"};\n    if (typeof val != \"object\" || val.whenClosing)\n      map[\"'/'\"] = function(cm) { return autoCloseSlash(cm); };\n    if (typeof val != \"object\" || val.whenOpening)\n      map[\"'>'\"] = function(cm) { return autoCloseGT(cm); };\n    cm.addKeyMap(map);\n  });\n\n  var htmlDontClose = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n                       \"source\", \"track\", \"wbr\"];\n  var htmlIndent = [\"applet\", \"blockquote\", \"body\", \"button\", \"div\", \"dl\", \"fieldset\", \"form\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\",\n                    \"h5\", \"h6\", \"head\", \"html\", \"iframe\", \"layer\", \"legend\", \"object\", \"ol\", \"p\", \"select\", \"table\", \"ul\"];\n\n  function autoCloseGT(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (inner.mode.name != \"xml\" || !state.tagName) return CodeMirror.Pass;\n\n      var opt = cm.getOption(\"autoCloseTags\"), html = inner.mode.configuration == \"html\";\n      var dontCloseTags = (typeof opt == \"object\" && opt.dontCloseTags) || (html && htmlDontClose);\n      var indentTags = (typeof opt == \"object\" && opt.indentTags) || (html && htmlIndent);\n\n      var tagName = state.tagName;\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n      var lowerTagName = tagName.toLowerCase();\n      // Don't process the '>' at the end of an end-tag or self-closing tag\n      if (!tagName ||\n          tok.type == \"string\" && (tok.end != pos.ch || !/[\\\"\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||\n          tok.type == \"tag\" && state.type == \"closeTag\" ||\n          tok.string.indexOf(\"/\") == (tok.string.length - 1) || // match something like <someTagName />\n          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||\n          closingTagExists(cm, tagName, pos, state, true))\n        return CodeMirror.Pass;\n\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n      replacements[i] = {indent: indent,\n                         text: \">\" + (indent ? \"\\n\\n\" : \"\") + \"</\" + tagName + \">\",\n                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};\n    }\n\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var info = replacements[i];\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, \"+insert\");\n      var sel = cm.listSelections().slice(0);\n      sel[i] = {head: info.newPos, anchor: info.newPos};\n      cm.setSelections(sel);\n      if (info.indent) {\n        cm.indentLine(info.newPos.line, null, true);\n        cm.indentLine(info.newPos.line + 1, null, true);\n      }\n    }\n  }\n\n  function autoCloseCurrent(cm, typingSlash) {\n    var ranges = cm.listSelections(), replacements = [];\n    var head = typingSlash ? \"/\" : \"</\";\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (typingSlash && (tok.type == \"string\" || tok.string.charAt(0) != \"<\" ||\n                          tok.start != pos.ch - 1))\n        return CodeMirror.Pass;\n      // Kludge to get around the fact that we are not in XML mode\n      // when completing in JS/CSS snippet in htmlmixed mode. Does not\n      // work for other XML embedded languages (there is no general\n      // way to go from a mixed mode to its current XML state).\n      var replacement;\n      if (inner.mode.name != \"xml\") {\n        if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"javascript\")\n          replacement = head + \"script\";\n        else if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"css\")\n          replacement = head + \"style\";\n        else\n          return CodeMirror.Pass;\n      } else {\n        if (!state.context || !state.context.tagName ||\n            closingTagExists(cm, state.context.tagName, pos, state))\n          return CodeMirror.Pass;\n        replacement = head + state.context.tagName;\n      }\n      if (cm.getLine(pos.line).charAt(tok.end) != \">\") replacement += \">\";\n      replacements[i] = replacement;\n    }\n    cm.replaceSelections(replacements);\n    ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\n        cm.indentLine(ranges[i].head.line);\n  }\n\n  function autoCloseSlash(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    return autoCloseCurrent(cm, true);\n  }\n\n  CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  // If xml-fold is loaded, we use its functionality to try and verify\n  // whether a given tag is actually unclosed.\n  function closingTagExists(cm, tagName, pos, state, newTag) {\n    if (!CodeMirror.scanForClosingTag) return false;\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n    if (!nextClose || nextClose.tag != tagName) return false;\n    var cx = state.context;\n    // If the immediate wrapping context contains onCx instances of\n    // the same tag, a closing tag only exists if there are at least\n    // that many closing tags of that type following.\n    for (var onCx = newTag ? 1 : 0; cx && cx.tagName == tagName; cx = cx.prev) ++onCx;\n    pos = nextClose.to;\n    for (var i = 1; i < onCx; i++) {\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n      if (!next || next.tag != tagName) return false;\n      pos = next.to;\n    }\n    return true;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"+onj\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(\"Dd8w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios__ = __webpack_require__(\"mtWM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_js_data__ = __webpack_require__(\"DW9A\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vuex__ = __webpack_require__(\"NYxO\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  props: {\n    name: String,\n    default: 'CodeNut笔记'\n  },\n  data: function data() {\n    return {\n      note: '',\n      noteDialogVisible: false,\n      fileType: '1',\n      noteName: this.name + '笔记'\n    };\n  },\n  created: function created() {\n    var _this = this;\n\n    if (this._checkLogin()) {\n      var url = __WEBPACK_IMPORTED_MODULE_2_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/notes';\n      __WEBPACK_IMPORTED_MODULE_1_axios___default.a.get(url).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_2_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this.note = response.data.result[0].text;\n        }\n      }, function (response) {});\n    }\n  },\n\n  methods: {\n    _showSaveNoteDialog: function _showSaveNoteDialog() {\n      this.noteDialogVisible = true;\n    },\n    saveNoteConfirm: function saveNoteConfirm() {\n      var FileSaver = __webpack_require__(\"lDdF\");\n      var blob = new Blob([this.note], { type: 'text/plain;charset=utf-8' });\n      if (this.fileType === '1') {\n        // Save as .txt\n        FileSaver.saveAs(blob, this.noteName + '.txt');\n      } else if (this.fileType === '2') {\n        FileSaver.saveAs(blob, this.noteName + '.md');\n      } else if (this.fileType === '0') {\n        if (this.note === '' || this.note === undefined) {\n          this.$notify({\n            title: '警告',\n            type: 'warning',\n            message: '笔记不能为空哦!'\n          });\n        } else {\n          if (this._checkLogin()) {\n            this._saveNote();\n          }\n        }\n      }\n      this.noteDialogVisible = false;\n    },\n    _saveNote: function _saveNote() {\n      var _this2 = this;\n\n      var url = __WEBPACK_IMPORTED_MODULE_2_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/notes';\n      __WEBPACK_IMPORTED_MODULE_1_axios___default.a.put(url, {\n        text: this.note\n      }).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_2_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this2.$notify({\n            title: '成功',\n            type: 'success',\n            message: '保存笔记成功!'\n          });\n        }\n      }, function (response) {\n        _this2._saveNote();\n      });\n    },\n    _checkLogin: function _checkLogin() {\n      if (this.user.user_id == null) {\n        this.$notify({\n          title: '警告',\n          message: '请先登录！',\n          type: 'warning'\n        });\n        return false;\n      } else {\n        return true;\n      }\n    }\n  },\n  computed: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_vuex__[\"d\" /* mapGetters */])(['problem', 'user']))\n});\n\n/***/ }),\n\n/***/ \"/A6h\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"QSKu\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n\n\n/***/ }),\n\n/***/ \"0CT/\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_components_description_myeditor__ = __webpack_require__(\"RKlR\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n//  import Editor from 'components/editor/vueeditor'\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  props: {\n    data: {\n      type: Object,\n      default: {}\n    }\n  },\n  components: {\n    MyEditor: __WEBPACK_IMPORTED_MODULE_0_components_description_myeditor__[\"a\" /* default */]\n  }\n});\n\n/***/ }),\n\n/***/ \"1LpH\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"8f5d\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"0c6bc646\", content, true);\n\n/***/ }),\n\n/***/ \"2hzx\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(\"Dd8w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_codemirror_mode_javascript_javascript__ = __webpack_require__(\"5IAE\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_codemirror_mode_javascript_javascript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_codemirror_mode_javascript_javascript__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_codemirror_mode_go_go__ = __webpack_require__(\"CQVp\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_codemirror_mode_go_go___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_codemirror_mode_go_go__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_codemirror_mode_python_python__ = __webpack_require__(\"tWbI\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_codemirror_mode_python_python___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_codemirror_mode_python_python__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_codemirror_mode_ruby_ruby__ = __webpack_require__(\"uOPQ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_codemirror_mode_ruby_ruby___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_codemirror_mode_ruby_ruby__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_codemirror_mode_clike_clike__ = __webpack_require__(\"6S2o\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_codemirror_mode_clike_clike___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_codemirror_mode_clike_clike__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_codemirror_theme_ambiance_css__ = __webpack_require__(\"vX90\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_codemirror_theme_ambiance_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_codemirror_theme_ambiance_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_codemirror_theme_base16_dark_css__ = __webpack_require__(\"jGSh\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_codemirror_theme_base16_dark_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_codemirror_theme_base16_dark_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_codemirror_theme_cobalt_css__ = __webpack_require__(\"t9xi\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_codemirror_theme_cobalt_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_codemirror_theme_cobalt_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_codemirror_theme_paraiso_light_css__ = __webpack_require__(\"Y0SK\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_codemirror_theme_paraiso_light_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_codemirror_theme_paraiso_light_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_dark_css__ = __webpack_require__(\"BR0Y\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_dark_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_dark_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_codemirror_theme_rubyblue_css__ = __webpack_require__(\"0tbE\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_codemirror_theme_rubyblue_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_codemirror_theme_rubyblue_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_codemirror_theme_solarized_css__ = __webpack_require__(\"Xdwu\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_codemirror_theme_solarized_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_codemirror_theme_solarized_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_codemirror_theme_mbo_css__ = __webpack_require__(\"1XTk\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_codemirror_theme_mbo_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_codemirror_theme_mbo_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_common_js_data__ = __webpack_require__(\"DW9A\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_axios__ = __webpack_require__(\"mtWM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_vuex__ = __webpack_require__(\"NYxO\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_common_js_ReturnResult__ = __webpack_require__(\"qnSv\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_components_description_runresultdialog__ = __webpack_require__(\"Hid1\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n// require active-line.js\n__webpack_require__(\"aGTD\");\n\n// closebrackets\n__webpack_require__(\"aX1R\");\n\n// styleSelectedText\n__webpack_require__(\"U80t\");\n__webpack_require__(\"c+I8\");\n\n// hint\n__webpack_require__(\"jQeI\");\n__webpack_require__(\"Mixr\");\n__webpack_require__(\"aGTD\");\n\n// highlightSelectionMatches\n__webpack_require__(\"QSKu\");\n__webpack_require__(\"/A6h\");\n__webpack_require__(\"c+I8\");\n__webpack_require__(\"OkRY\");\n\n// keyMap\n__webpack_require__(\"6S2o\");\n__webpack_require__(\"vq+x\");\n__webpack_require__(\"Z6qg\");\n__webpack_require__(\"RkhK\");\n__webpack_require__(\"LxZp\");\n__webpack_require__(\"c+I8\");\n__webpack_require__(\"CK2l\");\n__webpack_require__(\"7Xsf\");\n__webpack_require__(\"tjx/\");\n__webpack_require__(\"Hyg2\");\n\n// foldGutter\n__webpack_require__(\"Yokd\");\n__webpack_require__(\"fo6W\");\n__webpack_require__(\"soCA\");\n__webpack_require__(\"THjC\");\n__webpack_require__(\"Kk9m\");\n__webpack_require__(\"U3HU\");\n__webpack_require__(\"dxBS\");\n__webpack_require__(\"TQy8\");\n\n// autoCloseTags\n__webpack_require__(\"+/ra\");\n\n// 语法高亮，自行替换为你需要的语言\n\n\n\n\n\n\n// Theme\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//组件\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  data: function data() {\n    return {\n      code: '',\n      templateCodes: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"i\" /* templateCodes */],\n      Languages: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"e\" /* languages */],\n      editorModes: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"f\" /* editorModes */],\n      selectLanguage: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"e\" /* languages */][0],\n      editorThemes: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"d\" /* editorThemes */],\n      selectTheme: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"d\" /* editorThemes */][0],\n      keyMaps: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"j\" /* keyMaps */],\n      selectkeyMap: __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"j\" /* keyMaps */][0],\n      editorOptions: {\n        tabSize: 4,\n        mode: 'text/x-csrc',\n        theme: 'default',\n        lineNumbers: true,\n        line: true,\n        keyMap: 'sublime',\n        foldGutter: true,\n        gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n        // 选中文本自动高亮，及高亮方式\n        styleSelectedText: true,\n        highlightSelectionMatches: { showToken: /\\w/, annotateScrollbar: true\n          // 如果有hint方面的配置，也应该出现在这里\n        } },\n      result: [],\n      fullscreenLoading: false,\n      Runresult: {}\n    };\n  },\n  created: function created() {\n    this._getTempletCode(this.selectLanguage);\n  },\n\n  methods: {\n    handleCommandLangage: function handleCommandLangage(command) {\n      // 这里的command 是 index\n      console.log('xuan ' + command);\n      this.editorOptions.mode = this.editorModes[command];\n      this.selectLanguage = this.Languages[command];\n      this._getTempletCode(this.selectLanguage);\n    },\n    _getTempletCode: function _getTempletCode(selectLanguage) {\n      var _this = this;\n\n      var url = __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/codes';\n      __WEBPACK_IMPORTED_MODULE_15_axios___default.a.get(url).then(function (response) {\n        var result = JSON.parse(response.data.result[0].code);\n        console.log(result);\n        var templet = result.find(function (item) {\n          if (item) {\n            return item.text === selectLanguage;\n          }\n        });\n        if (templet && templet.defaultCode) {\n          _this.code = templet.defaultCode;\n        } else {\n          _this.code = '';\n        }\n      }, function (response) {});\n    },\n    handleCommandKeyMap: function handleCommandKeyMap(command) {\n      this.editorOptions.keyMap = command;\n      this.selectkeyMap = command;\n      console.log(this.editorOptions);\n    },\n    handleCommandTheme: function handleCommandTheme(command) {\n      console.log('click on item ' + command);\n      this.editorOptions.theme = command;\n      this.selectTheme = command;\n    },\n    onClickSubmit: function onClickSubmit() {\n      var _this2 = this;\n\n      if (!this._checkLogin()) {\n        return;\n      }\n      var url = __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/codes';\n      __WEBPACK_IMPORTED_MODULE_15_axios___default.a.post(url, {\n        language: this.selectLanguage,\n        code: this.code\n      }).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"b\" /* MSG_OK */]) {\n          console.log(response.data.result[0]);\n          _this2.Runresult = new __WEBPACK_IMPORTED_MODULE_17_common_js_ReturnResult__[\"a\" /* default */]({\n            mytitle: 'SubmitResult',\n            memory_used: response.data.result[0].memory_used.toFixed(2) + 'kb',\n            output: response.data.result[0].output,\n            status: response.data.result[0].status,\n            time_used: response.data.result[0].time_used.toFixed(2) + 's'\n          });\n          _this2.result.push(_this2.Runresult);\n          _this2._showLoading();\n          _this2.$refs.dialog.show();\n        } else if (response.data.mag === __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"c\" /* MSG_NO */]) {\n          _this2.$notify.error({\n            title: '错误',\n            message: response.data.error\n          });\n        }\n      }, function (response) {});\n    },\n    onClickRun: function onClickRun() {\n      var _this3 = this;\n\n      if (!this._checkLogin()) {\n        return;\n      }\n      console.log(this.code);\n      var url = __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/codes';\n      __WEBPACK_IMPORTED_MODULE_15_axios___default.a.patch(url, {\n        language: this.selectLanguage,\n        code: this.code\n      }).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"b\" /* MSG_OK */]) {\n          console.log(response.data.result[0]);\n          _this3.Runresult = new __WEBPACK_IMPORTED_MODULE_17_common_js_ReturnResult__[\"a\" /* default */]({\n            mytitle: 'RunResult',\n            memory_used: response.data.result[0].memory_used + 'kb',\n            output: response.data.result[0].output,\n            status: response.data.result[0].status,\n            time_used: response.data.result[0].time_used + 's'\n          });\n          _this3.result.push(_this3.Runresult);\n          _this3._showLoading();\n          _this3.$refs.dialog.show();\n        } else if (response.data.mag === __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"c\" /* MSG_NO */]) {\n          _this3.$notify.error({\n            title: '错误',\n            message: response.data.error\n          });\n        }\n      }, function (response) {});\n    },\n    onClickCustom: function onClickCustom() {\n      var url = __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/codes';\n      __WEBPACK_IMPORTED_MODULE_15_axios___default.a.get(url).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_14_common_js_data__[\"b\" /* MSG_OK */]) {\n          var str = JSON.parse(response.data.result[0].code);\n          console.log(str);\n        }\n      }, function (response) {});\n    },\n    _checkLogin: function _checkLogin() {\n      if (this.user.user_id === null || this.user.user_id === undefined || this.user.user_id === '') {\n        this.$notify({\n          title: '警告',\n          message: '请先登录！',\n          type: 'warning'\n        });\n        return false;\n      } else {\n        return true;\n      }\n    },\n    _showLoading: function _showLoading() {\n      var _this4 = this;\n\n      this.fullscreenLoading = true;\n      setTimeout(function () {\n        _this4.fullscreenLoading = false;\n      }, 1000);\n    }\n  },\n  computed: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_vuex__[\"d\" /* mapGetters */])(['problem', 'user'])),\n  components: {\n    RunResultDialog: __WEBPACK_IMPORTED_MODULE_18_components_description_runresultdialog__[\"a\" /* default */]\n  }\n});\n\n/***/ }),\n\n/***/ \"47LY\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(\"Dd8w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios__ = __webpack_require__(\"mtWM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_js_data__ = __webpack_require__(\"DW9A\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vuex__ = __webpack_require__(\"NYxO\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  data: function data() {\n    return {\n      solution: {}\n    };\n  },\n  mounted: function mounted() {\n    this._getSolution();\n    //      let results = document.getElementsByTagName('a')\n    //      for (let i = 0; i < results.length; i++) {\n    //        results[i].href = '#'\n    //      }\n  },\n\n  methods: {\n    _getSolution: function _getSolution() {\n      var _this = this;\n\n      console.log(this.id + '1111111111');\n      var url = __WEBPACK_IMPORTED_MODULE_2_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/solutions';\n      __WEBPACK_IMPORTED_MODULE_1_axios___default.a.get(url).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_2_common_js_data__[\"b\" /* MSG_OK */]) {\n          console.log(response.data.result[0]);\n          _this.solution = response.data.result[0].solution;\n        }\n      }, function (response) {});\n    }\n  },\n  computed: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_vuex__[\"d\" /* mapGetters */])(['problem']))\n});\n\n/***/ }),\n\n/***/ \"5Ey+\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(\"Zrlr\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);\n\n\n/**\n * Created by qinzhen on 2017/9/17.\n */\nvar Problem = function Problem(_ref) {\n  var id = _ref.id,\n      title = _ref.title,\n      tag = _ref.tag,\n      level = _ref.level,\n      description = _ref.description,\n      accepted = _ref.accepted,\n      submitted = _ref.submitted,\n      like_nums = _ref.like_nums,\n      hate_nums = _ref.hate_nums;\n\n  __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Problem);\n\n  this.id = id;\n  this.title = title;\n  this.tag = tag;\n  this.level = level;\n  this.description = description;\n  this.accepted = accepted;\n  this.submitted = submitted;\n  this.like_nums = like_nums;\n  this.hate_nums = hate_nums;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Problem);\n\n/***/ }),\n\n/***/ \"6rPU\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"hint-wrapper\"\n  }, [_c('div', {\n    staticClass: \"placeholder-text\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"We do not have any hints for this question at the moment.\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"suggest\"\n  }, [_vm._v(\"Do you have one or more hints?\")])])])\n}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"7Xsf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"vq+x\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  var goSubwordCombo = mac ? \"Ctrl-\" : \"Alt-\";\n\n  cmds[map[goSubwordCombo + \"Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n  cmds[map[goSubwordCombo + \"Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\n  if (mac) map[\"Cmd-Left\"] = \"goLineStartSmart\";\n\n  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\n  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  map[\"Shift-Tab\"] = \"indentLess\";\n\n  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  map[\"Shift-Ctrl-K\"] = \"deleteLine\";\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { return insertLine(cm, false); };\n\n  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))\n        return CodeMirror.Pass\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(range.anchor, dir, \"line\");\n      var newHead = cm.findPosV(range.head, dir, \"line\");\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n\n  var addCursorToLineCombo = mac ? \"Shift-Cmd\" : 'Alt-Ctrl';\n  cmds[map[addCursorToLineCombo + \"Up\"] = \"addCursorToPrevLine\"] = function(cm) { addCursorToSelection(cm, -1); };\n  cmds[map[addCursorToLineCombo + \"Down\"] = \"addCursorToNextLine\"] = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (ranges[i].from() == from && ranges[i].to() == to) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          newRanges.push({anchor: Pos(opening.pos.line, opening.pos.ch + 1),\n                          head: closing.pos});\n          break;\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\n  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[ctrl + \"/\"] = \"toggleCommentIndented\"] = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  if (!mac) map[ctrl + \"T\"] = \"transposeChars\";\n\n  function sortLines(cm, caseSensitive) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\n  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  map[\"Alt-Q\"] = \"wrapLines\";\n\n  var cK = ctrl + \"K \";\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\n  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  var selectLinesCombo = mac ? \"Ctrl-Shift-\" : \"Ctrl-Alt-\";\n  cmds[map[selectLinesCombo + \"Up\"] = \"selectLinesUpward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line > cm.firstLine())\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n      }\n    });\n  };\n  cmds[map[selectLinesCombo + \"Down\"] = \"selectLinesDownward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line < cm.lastLine())\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n      }\n    });\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"J\"] = \"unfoldAll\";\n\n  map[ctrl + \"I\"] = \"findIncremental\";\n  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n  map[ctrl + \"H\"] = \"replace\";\n  map[\"F3\"] = \"findNext\";\n  map[\"Shift-F3\"] = \"findPrev\";\n\n  CodeMirror.normalizeKeyMap(map);\n});\n\n\n/***/ }),\n\n/***/ \"8eAg\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_description_vue__ = __webpack_require__(\"0CT/\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4dfc5728_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_description_vue__ = __webpack_require__(\"fpaw\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"CXwt\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-4dfc5728\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_description_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4dfc5728_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_description_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"8f5d\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".hint-wrapper{width:100%;height:100%}.hint-wrapper .placeholder-text{padding:8rem 4rem;text-align:center;font-size:1.5rem;color:#555}.hint-wrapper .placeholder-text .suggest{margin-top:30px;color:gray}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/hints/hints.vue\"],\"names\":[],\"mappings\":\"AACA,cACE,WAAY,AACZ,WAAa,CACd,AACD,gCACE,kBAAmB,AACnB,kBAAmB,AACnB,iBAAkB,AAClB,UAAY,CACb,AACD,yCACE,gBAAiB,AACjB,UAAe,CAChB\",\"file\":\"hints.vue\",\"sourcesContent\":[\"\\n.hint-wrapper {\\n  width: 100%;\\n  height: 100%;\\n}\\n.hint-wrapper .placeholder-text {\\n  padding: 8rem 4rem;\\n  text-align: center;\\n  font-size: 1.5rem;\\n  color: #555;\\n}\\n.hint-wrapper .placeholder-text .suggest {\\n  margin-top: 30px;\\n  color: #808080;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"CK2l\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"RkhK\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../dialog/dialog\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function searchOverlay(query, caseInsensitive) {\n    if (typeof query == \"string\")\n      query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\"), caseInsensitive ? \"gi\" : \"g\");\n    else if (!query.global)\n      query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\n\n    return {token: function(stream) {\n      query.lastIndex = stream.pos;\n      var match = query.exec(stream.string);\n      if (match && match.index == stream.pos) {\n        stream.pos += match[0].length || 1;\n        return \"searching\";\n      } else if (match) {\n        stream.pos = match.index;\n      } else {\n        stream.skipToEnd();\n      }\n    }};\n  }\n\n  function SearchState() {\n    this.posFrom = this.posTo = this.lastQuery = this.query = null;\n    this.overlay = null;\n  }\n\n  function getSearchState(cm) {\n    return cm.state.search || (cm.state.search = new SearchState());\n  }\n\n  function queryCaseInsensitive(query) {\n    return typeof query == \"string\" && query == query.toLowerCase();\n  }\n\n  function getSearchCursor(cm, query, pos) {\n    // Heuristic: if the query string is all lowercase, do a case insensitive search.\n    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});\n  }\n\n  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {\n    cm.openDialog(text, onEnter, {\n      value: deflt,\n      selectValueOnOpen: true,\n      closeOnEnter: false,\n      onClose: function() { clearSearch(cm); },\n      onKeyDown: onKeyDown\n    });\n  }\n\n  function dialog(cm, text, shortText, deflt, f) {\n    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});\n    else f(prompt(shortText, deflt));\n  }\n\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n\n  function parseString(string) {\n    return string.replace(/\\\\(.)/g, function(_, ch) {\n      if (ch == \"n\") return \"\\n\"\n      if (ch == \"r\") return \"\\r\"\n      return ch\n    })\n  }\n\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\n    if (isRE) {\n      try { query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\"); }\n      catch(e) {} // Not a regular expression after all, do a string search\n    } else {\n      query = parseString(query)\n    }\n    if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\n      query = /x^/;\n    return query;\n  }\n\n  var queryDialog =\n    '<span class=\"CodeMirror-search-label\">Search:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n\n  function startSearch(cm, state, query) {\n    state.queryText = query;\n    state.query = parseQuery(query);\n    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\n    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\n    cm.addOverlay(state.overlay);\n    if (cm.showMatchesOnScrollbar) {\n      if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\n    }\n  }\n\n  function doSearch(cm, rev, persistent, immediate) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    var q = cm.getSelection() || state.lastQuery;\n    if (persistent && cm.openDialog) {\n      var hiding = null\n      var searchNext = function(query, event) {\n        CodeMirror.e_stop(event);\n        if (!query) return;\n        if (query != state.queryText) {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n        }\n        if (hiding) hiding.style.opacity = 1\n        findNext(cm, event.shiftKey, function(_, to) {\n          var dialog\n          if (to.line < 3 && document.querySelector &&\n              (dialog = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) &&\n              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, \"window\").top)\n            (hiding = dialog).style.opacity = .4\n        })\n      };\n      persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {\n        var keyName = CodeMirror.keyName(event)\n        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName]\n        if (cmd == \"findNext\" || cmd == \"findPrev\" ||\n          cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\n          CodeMirror.e_stop(event);\n          startSearch(cm, getSearchState(cm), query);\n          cm.execCommand(cmd);\n        } else if (cmd == \"find\" || cmd == \"findPersistent\") {\n          CodeMirror.e_stop(event);\n          searchNext(query, event);\n        }\n      });\n      if (immediate && q) {\n        startSearch(cm, state, q);\n        findNext(cm, rev);\n      }\n    } else {\n      dialog(cm, queryDialog, \"Search for:\", q, function(query) {\n        if (query && !state.query) cm.operation(function() {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n          findNext(cm, rev);\n        });\n      });\n    }\n  }\n\n  function findNext(cm, rev, callback) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n    if (callback) callback(cursor.from(), cursor.to())\n  });}\n\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    state.lastQuery = state.query;\n    if (!state.query) return;\n    state.query = state.queryText = null;\n    cm.removeOverlay(state.overlay);\n    if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n  });}\n\n  var replaceQueryDialog =\n    ' <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n  var replacementQueryDialog = '<span class=\"CodeMirror-search-label\">With:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/>';\n  var doReplaceConfirm = '<span class=\"CodeMirror-search-label\">Replace?</span> <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>';\n\n  function replaceAll(cm, query, text) {\n    cm.operation(function() {\n      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {\n        if (typeof query != \"string\") {\n          var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n          cursor.replace(text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n        } else cursor.replace(text);\n      }\n    });\n  }\n\n  function replace(cm, all) {\n    if (cm.getOption(\"readOnly\")) return;\n    var query = cm.getSelection() || getSearchState(cm).lastQuery;\n    var dialogText = '<span class=\"CodeMirror-search-label\">' + (all ? 'Replace all:' : 'Replace:') + '</span>';\n    dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, replacementQueryDialog, \"Replace with:\", \"\", function(text) {\n        text = parseString(text)\n        if (all) {\n          replaceAll(cm, query, text)\n        } else {\n          clearSearch(cm);\n          var cursor = getSearchCursor(cm, query, cm.getCursor(\"from\"));\n          var advance = function() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = getSearchCursor(cm, query);\n              if (!(match = cursor.findNext()) ||\n                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});\n            confirmDialog(cm, doReplaceConfirm, \"Replace?\",\n                          [function() {doReplace(match);}, advance,\n                           function() {replaceAll(cm, query, text)}]);\n          };\n          var doReplace = function(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n            advance();\n          };\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};\n  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};\n  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n});\n\n\n/***/ }),\n\n/***/ \"CXwt\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"oFfA\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"79df4bd3\", content, true);\n\n/***/ }),\n\n/***/ \"FVxK\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".problem[data-v-4ad8a6d2]{-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}.problem .problem-header .collection[data-v-4ad8a6d2]{float:right;margin-top:5px;vertical-align:bottom}.problem .problem-header h3[data-v-4ad8a6d2]{display:inline-block;margin-bottom:10px;font-weight:500;line-height:1;font-size:24px}.container[data-v-4ad8a6d2]{margin-top:32px}.container .el-tabs__content[data-v-4ad8a6d2]{min-height:800px}.grid-content[data-v-4ad8a6d2]{border-radius:4px;min-height:36px}.bg-purple[data-v-4ad8a6d2]{background:#d3dce6}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/problem-detail/problem-detail.vue\"],\"names\":[],\"mappings\":\"AACA,0BACE,mBAAoB,AAChB,kBAAmB,AACf,aAAe,CACxB,AACD,sDACE,YAAa,AACb,eAAgB,AAChB,qBAAuB,CACxB,AACD,6CACE,qBAAsB,AACtB,mBAAoB,AACpB,gBAAiB,AACjB,cAAe,AACf,cAAgB,CACjB,AACD,4BACE,eAAiB,CAClB,AACD,8CACE,gBAAkB,CACnB,AACD,+BACE,kBAAmB,AACnB,eAAiB,CAClB,AACD,4BACE,kBAAoB,CACrB\",\"file\":\"problem-detail.vue\",\"sourcesContent\":[\"\\n.problem[data-v-4ad8a6d2] {\\n  -webkit-box-flex: 1;\\n      -ms-flex: 1 0 auto;\\n          flex: 1 0 auto;\\n}\\n.problem .problem-header .collection[data-v-4ad8a6d2] {\\n  float: right;\\n  margin-top: 5px;\\n  vertical-align: bottom;\\n}\\n.problem .problem-header h3[data-v-4ad8a6d2] {\\n  display: inline-block;\\n  margin-bottom: 10px;\\n  font-weight: 500;\\n  line-height: 1;\\n  font-size: 24px;\\n}\\n.container[data-v-4ad8a6d2] {\\n  margin-top: 32px;\\n}\\n.container .el-tabs__content[data-v-4ad8a6d2] {\\n  min-height: 800px;\\n}\\n.grid-content[data-v-4ad8a6d2] {\\n  border-radius: 4px;\\n  min-height: 36px;\\n}\\n.bg-purple[data-v-4ad8a6d2] {\\n  background: #d3dce6;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"Fvbh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"FVxK\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"b2eb1a16\", content, true);\n\n/***/ }),\n\n/***/ \"Hid1\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_runresultdialog_vue__ = __webpack_require__(\"RBst\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_d7772fc0_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_runresultdialog_vue__ = __webpack_require__(\"q8U2\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"lL6t\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-d7772fc0\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_runresultdialog_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_d7772fc0_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_runresultdialog_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"Hyg2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"RkhK\"), __webpack_require__(\"vq+x\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; };\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '['};\n        var selfPaired = {'\\'': true, '\"': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /-?\\d+/g;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        var token;\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0];\n          start = match.index;\n          end = start + token.length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1;\n          var number = parseInt(token) + (increment * actionArgs.repeat);\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          numberStr = number.toString();\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /**\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      var slashes = findUnescapedSlashes(argString) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSlashes(str) {\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySlash(argString) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); };\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n             i++;\n          } else {\n             i+= selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      };\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n            } else {\n                lastChange.changes.push(text);\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    };\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n\n\n/***/ }),\n\n/***/ \"Iula\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".dialog-container .explanation[data-v-d7772fc0]{font-size:18px;font-weight:500;color:#222;margin-bottom:10px}.dialog-container .text[data-v-d7772fc0]{font-size:14px;text-align:justify}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/description/runresultdialog.vue\"],\"names\":[],\"mappings\":\"AACA,gDACE,eAAgB,AAChB,gBAAiB,AACjB,WAAY,AACZ,kBAAoB,CACrB,AACD,yCACE,eAAgB,AAChB,kBAAoB,CACrB\",\"file\":\"runresultdialog.vue\",\"sourcesContent\":[\"\\n.dialog-container .explanation[data-v-d7772fc0] {\\n  font-size: 18px;\\n  font-weight: 500;\\n  color: #222;\\n  margin-bottom: 10px;\\n}\\n.dialog-container .text[data-v-d7772fc0] {\\n  font-size: 14px;\\n  text-align: justify;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"Kk9m\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"THjC\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"LGuY\":\n/***/ (function(module, exports) {\n\nmodule.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n/***/ }),\n\n/***/ \"LxZp\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"RkAk\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"e2c66042\", content, true);\n\n/***/ }),\n\n/***/ \"McHp\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_problem_detail_vue__ = __webpack_require__(\"x494\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4ad8a6d2_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_problem_detail_vue__ = __webpack_require__(\"PdbZ\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"Fvbh\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-4ad8a6d2\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_problem_detail_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4ad8a6d2_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_problem_detail_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"Mixr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch continue debugger default delete do else false finally for function \" +\n                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"OEy6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"XgT+\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"60b01bed\", content, true);\n\n/***/ }),\n\n/***/ \"OkRY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"/A6h\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query + \"\\\\b\") : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n\n\n/***/ }),\n\n/***/ \"P830\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_solution_vue__ = __webpack_require__(\"47LY\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6701a6dc_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_solution_vue__ = __webpack_require__(\"eg3M\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"OEy6\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-6701a6dc\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_solution_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6701a6dc_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_solution_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"PdbZ\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in-linear\"\n    }\n  }, [_c('div', {\n    staticClass: \"problem\"\n  }, [_c('el-row', [_c('el-col', {\n    attrs: {\n      \"sm\": 0,\n      \"lg\": 2,\n      \"md\": 1,\n      \"xs\": 0\n    }\n  }, [_c('div', {\n    staticClass: \"grid-content\"\n  })]), _vm._v(\" \"), _c('el-col', {\n    attrs: {\n      \"sm\": 24,\n      \"lg\": 20,\n      \"md\": 22,\n      \"xs\": 24\n    }\n  }, [_c('div', {\n    staticClass: \"problem-header\"\n  }, [_c('h3', {\n    attrs: {\n      \"align\": \"left\"\n    }\n  }, [_vm._v(_vm._s(_vm.problemDetail.title))]), _vm._v(\" \"), _c('img', {\n    staticClass: \"collection\",\n    attrs: {\n      \"width\": \"56\",\n      \"height\": \"56\",\n      \"src\": _vm.getFavoriteSrc(_vm.problemDetail)\n    },\n    on: {\n      \"click\": _vm.collection\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"container\"\n  }, [_c('el-tabs', {\n    attrs: {\n      \"type\": \"card\"\n    },\n    model: {\n      value: (_vm.tab),\n      callback: function($$v) {\n        _vm.tab = $$v\n      },\n      expression: \"tab\"\n    }\n  }, [_c('el-tab-pane', {\n    attrs: {\n      \"label\": \"题目描述\",\n      \"name\": \"description\"\n    }\n  }, [_c('description', {\n    attrs: {\n      \"data\": _vm.problemDetail\n    }\n  })], 1), _vm._v(\" \"), _c('el-tab-pane', {\n    attrs: {\n      \"label\": \"解决方案\",\n      \"name\": \"solution\"\n    }\n  }, [_c('solution')], 1), _vm._v(\" \"), _c('el-tab-pane', {\n    attrs: {\n      \"label\": \"提示\",\n      \"name\": \"third\"\n    }\n  }, [_c('hints')], 1), _vm._v(\" \"), _c('el-tab-pane', {\n    attrs: {\n      \"label\": \"笔记\",\n      \"name\": \"fourth\"\n    }\n  }, [_c('notes', {\n    attrs: {\n      \"name\": _vm.problem.title\n    }\n  })], 1)], 1)], 1)]), _vm._v(\" \"), _c('el-col', {\n    attrs: {\n      \"sm\": 0,\n      \"lg\": 2,\n      \"md\": 1,\n      \"xs\": 0\n    }\n  }, [_c('div', {\n    staticClass: \"grid-content\"\n  })])], 1)], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"QSKu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"annotateScrollbar\", function(options) {\n    if (typeof options == \"string\") options = {className: options};\n    return new Annotation(this, options);\n  });\n\n  CodeMirror.defineOption(\"scrollButtonHeight\", 0);\n\n  function Annotation(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.buttonHeight = options.scrollButtonHeight || cm.getOption(\"scrollButtonHeight\");\n    this.annotations = [];\n    this.doRedraw = this.doUpdate = null;\n    this.div = cm.getWrapperElement().appendChild(document.createElement(\"div\"));\n    this.div.style.cssText = \"position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none\";\n    this.computeScale();\n\n    function scheduleRedraw(delay) {\n      clearTimeout(self.doRedraw);\n      self.doRedraw = setTimeout(function() { self.redraw(); }, delay);\n    }\n\n    var self = this;\n    cm.on(\"refresh\", this.resizeHandler = function() {\n      clearTimeout(self.doUpdate);\n      self.doUpdate = setTimeout(function() {\n        if (self.computeScale()) scheduleRedraw(20);\n      }, 100);\n    });\n    cm.on(\"markerAdded\", this.resizeHandler);\n    cm.on(\"markerCleared\", this.resizeHandler);\n    if (options.listenForChanges !== false)\n      cm.on(\"change\", this.changeHandler = function() {\n        scheduleRedraw(250);\n      });\n  }\n\n  Annotation.prototype.computeScale = function() {\n    var cm = this.cm;\n    var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) /\n      cm.getScrollerElement().scrollHeight\n    if (hScale != this.hScale) {\n      this.hScale = hScale;\n      return true;\n    }\n  };\n\n  Annotation.prototype.update = function(annotations) {\n    this.annotations = annotations;\n    this.redraw();\n  };\n\n  Annotation.prototype.redraw = function(compute) {\n    if (compute !== false) this.computeScale();\n    var cm = this.cm, hScale = this.hScale;\n\n    var frag = document.createDocumentFragment(), anns = this.annotations;\n\n    var wrapping = cm.getOption(\"lineWrapping\");\n    var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;\n    var curLine = null, curLineObj = null;\n    function getY(pos, top) {\n      if (curLine != pos.line) {\n        curLine = pos.line;\n        curLineObj = cm.getLineHandle(curLine);\n      }\n      if ((curLineObj.widgets && curLineObj.widgets.length) ||\n          (wrapping && curLineObj.height > singleLineH))\n        return cm.charCoords(pos, \"local\")[top ? \"top\" : \"bottom\"];\n      var topY = cm.heightAtLine(curLineObj, \"local\");\n      return topY + (top ? 0 : curLineObj.height);\n    }\n\n    var lastLine = cm.lastLine()\n    if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {\n      var ann = anns[i];\n      if (ann.to.line > lastLine) continue;\n      var top = nextTop || getY(ann.from, true) * hScale;\n      var bottom = getY(ann.to, false) * hScale;\n      while (i < anns.length - 1) {\n        if (anns[i + 1].to.line > lastLine) break;\n        nextTop = getY(anns[i + 1].from, true) * hScale;\n        if (nextTop > bottom + .9) break;\n        ann = anns[++i];\n        bottom = getY(ann.to, false) * hScale;\n      }\n      if (bottom == top) continue;\n      var height = Math.max(bottom - top, 3);\n\n      var elt = frag.appendChild(document.createElement(\"div\"));\n      elt.style.cssText = \"position: absolute; right: 0px; width: \" + Math.max(cm.display.barWidth - 1, 2) + \"px; top: \"\n        + (top + this.buttonHeight) + \"px; height: \" + height + \"px\";\n      elt.className = this.options.className;\n      if (ann.id) {\n        elt.setAttribute(\"annotation-id\", ann.id);\n      }\n    }\n    this.div.textContent = \"\";\n    this.div.appendChild(frag);\n  };\n\n  Annotation.prototype.clear = function() {\n    this.cm.off(\"refresh\", this.resizeHandler);\n    this.cm.off(\"markerAdded\", this.resizeHandler);\n    this.cm.off(\"markerCleared\", this.resizeHandler);\n    if (this.changeHandler) this.cm.off(\"change\", this.changeHandler);\n    this.div.parentNode.removeChild(this.div);\n  };\n});\n\n\n/***/ }),\n\n/***/ \"RBst\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_js_data__ = __webpack_require__(\"DW9A\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  props: {\n    result: {\n      type: Object\n\n    }\n  },\n  data: function data() {\n    return {\n      dialogVisible: false,\n      results: __WEBPACK_IMPORTED_MODULE_0_common_js_data__[\"k\" /* results */]\n    };\n  },\n\n  methods: {\n    show: function show() {\n      this.dialogVisible = true;\n    },\n    hide: function hide() {\n      this.dialogVisible = false;\n    },\n    getExplanation: function getExplanation(status) {\n      var res = this.results.find(function (item) {\n        return item.name === status;\n      });\n      return res.value;\n    }\n  }\n});\n\n/***/ }),\n\n/***/ \"RKlR\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myeditor_vue__ = __webpack_require__(\"2hzx\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_58438f59_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_myeditor_vue__ = __webpack_require__(\"WD2d\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"Xh4M\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-58438f59\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myeditor_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_58438f59_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_myeditor_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"RkAk\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror-dialog{position:absolute;left:0;right:0;background:inherit;z-index:15;padding:.1em .8em;overflow:hidden;color:inherit}.CodeMirror-dialog-top{border-bottom:1px solid #eee;top:0}.CodeMirror-dialog-bottom{border-top:1px solid #eee;bottom:0}.CodeMirror-dialog input{border:none;outline:none;background:transparent;width:20em;color:inherit;font-family:monospace}.CodeMirror-dialog button{font-size:70%}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/dialog/dialog.css\"],\"names\":[],\"mappings\":\"AAAA,mBACE,kBAAmB,AACnB,OAAQ,AAAC,QAAS,AAClB,mBAAoB,AACpB,WAAY,AACZ,kBAAmB,AACnB,gBAAiB,AACjB,aAAe,CAChB,AAED,uBACE,6BAA8B,AAC9B,KAAO,CACR,AAED,0BACE,0BAA2B,AAC3B,QAAU,CACX,AAED,yBACE,YAAa,AACb,aAAc,AACd,uBAAwB,AACxB,WAAY,AACZ,cAAe,AACf,qBAAuB,CACxB,AAED,0BACE,aAAe,CAChB\",\"file\":\"dialog.css\",\"sourcesContent\":[\".CodeMirror-dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n\\n.CodeMirror-dialog-top {\\n  border-bottom: 1px solid #eee;\\n  top: 0;\\n}\\n\\n.CodeMirror-dialog-bottom {\\n  border-top: 1px solid #eee;\\n  bottom: 0;\\n}\\n\\n.CodeMirror-dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\\n\\n.CodeMirror-dialog button {\\n  font-size: 70%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"RkhK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n\n\n/***/ }),\n\n/***/ \"SVHh\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in\"\n    }\n  }, [_c('div', {\n    staticClass: \"notes\"\n  }, [_c('el-dialog', {\n    attrs: {\n      \"title\": \"保存笔记\",\n      \"visible\": _vm.noteDialogVisible\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.noteDialogVisible = $event\n      }\n    }\n  }, [_c('el-form', {\n    ref: \"form\",\n    attrs: {\n      \"label-width\": \"60px\"\n    }\n  }, [_c('el-form-item', {\n    attrs: {\n      \"label\": \"文件名:\"\n    }\n  }, [_c('el-input', {\n    model: {\n      value: (_vm.noteName),\n      callback: function($$v) {\n        _vm.noteName = $$v\n      },\n      expression: \"noteName\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-radio-group', {\n    model: {\n      value: (_vm.fileType),\n      callback: function($$v) {\n        _vm.fileType = $$v\n      },\n      expression: \"fileType\"\n    }\n  }, [_c('el-radio', {\n    attrs: {\n      \"label\": \"0\"\n    }\n  }, [_vm._v(\"保存至云端\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": \"1\"\n    }\n  }, [_vm._v(\"以txt格式保存\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": \"2\"\n    }\n  }, [_vm._v(\"以markdown格式保存\")])], 1)], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"dialog-footer\",\n    slot: \"footer\"\n  }, [_c('el-button', {\n    on: {\n      \"click\": function($event) {\n        _vm.noteDialogVisible = false\n      }\n    }\n  }, [_vm._v(\"取 消\")]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.saveNoteConfirm\n    }\n  }, [_vm._v(\"保 存\")])], 1)], 1), _vm._v(\" \"), _c('mavon-editor', {\n    attrs: {\n      \"default_open\": \"edit\",\n      \"placeholder\": \"记录学习笔记\"\n    },\n    on: {\n      \"save\": _vm._showSaveNoteDialog\n    },\n    model: {\n      value: (_vm.note),\n      callback: function($$v) {\n        _vm.note = $$v\n      },\n      expression: \"note\"\n    }\n  })], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"THjC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n\n\n/***/ }),\n\n/***/ \"TQy8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter), end;\n      if (!openTag || iter.line != start.line || !(end = toTagEnd(iter))) return;\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && {from: startPos, to: endPos.from};\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n\n\n/***/ }),\n\n/***/ \"U3HU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction lineIndent(cm, lineNo) {\n  var text = cm.getLine(lineNo)\n  var spaceTo = text.search(/\\S/)\n  if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))\n    return -1\n  return CodeMirror.countColumn(text, null, cm.getOption(\"tabSize\"))\n}\n\nCodeMirror.registerHelper(\"fold\", \"indent\", function(cm, start) {\n  var myIndent = lineIndent(cm, start.line)\n  if (myIndent < 0) return\n  var lastLineInFold = null\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    var indent = lineIndent(cm, i)\n    if (indent == -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) return {\n    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n  };\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"U80t\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    if (cm.state.markedSelection)\n      cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n\n\n/***/ }),\n\n/***/ \"WD2d\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"myeditor\"\n  }, [_c('div', {\n    staticClass: \"myeditor-header\"\n  }, [_c('el-dropdown', {\n    staticClass: \"language-dropdown\",\n    attrs: {\n      \"trigger\": \"click\",\n      \"menu-align\": \"start\"\n    },\n    on: {\n      \"command\": _vm.handleCommandLangage\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    }\n  }, [_vm._v(_vm._s(_vm.selectLanguage)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.Languages), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": index\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n        \")])\n  }))], 1), _vm._v(\" \"), _c('el-dropdown', {\n    staticClass: \"el-dropdown-theme\",\n    attrs: {\n      \"menu-align\": \"start\",\n      \"trigger\": \"click\"\n    },\n    on: {\n      \"command\": _vm.handleCommandTheme\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    }\n  }, [_vm._v(\"\\n        \" + _vm._s(_vm.selectTheme)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.editorThemes), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": item\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n        \")])\n  }))], 1), _vm._v(\" \"), _c('el-dropdown', {\n    staticClass: \"el-dropdown-keyMap\",\n    attrs: {\n      \"menu-align\": \"start\",\n      \"trigger\": \"click\"\n    },\n    on: {\n      \"command\": _vm.handleCommandKeyMap\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    }\n  }, [_vm._v(\"\\n        \" + _vm._s(_vm.selectkeyMap)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.keyMaps), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": item\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n        \")])\n  }))], 1)], 1), _vm._v(\" \"), _c('codemirror', {\n    ref: \"myEditor\",\n    attrs: {\n      \"options\": _vm.editorOptions\n    },\n    model: {\n      value: (_vm.code),\n      callback: function($$v) {\n        _vm.code = $$v\n      },\n      expression: \"code\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"myeditor-footer\"\n  }, [_c('el-button', {\n    staticClass: \"custom-button\",\n    attrs: {\n      \"type\": \"success\"\n    },\n    on: {\n      \"click\": _vm.onClickCustom\n    }\n  }, [_vm._v(\"\\n      Custom\"), _c('i', {\n    staticClass: \"el-icon-upload el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"submit-button\",\n    attrs: {\n      \"type\": \"success\"\n    },\n    on: {\n      \"click\": _vm.onClickSubmit\n    }\n  }, [_vm._v(\"\\n      Submit\"), _c('i', {\n    staticClass: \"el-icon-upload el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"run-button\",\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.onClickRun\n    }\n  }, [_vm._v(\"Run\\n    \")])], 1), _vm._v(\" \"), _vm._l((_vm.result), function(item, index) {\n    return _c('div', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (_vm.result !== []),\n        expression: \"result!==[]\"\n      }, {\n        name: \"loading\",\n        rawName: \"v-loading.fullscreen.lock\",\n        value: (_vm.fullscreenLoading),\n        expression: \"fullscreenLoading\",\n        modifiers: {\n          \"fullscreen\": true,\n          \"lock\": true\n        }\n      }],\n      key: index,\n      staticClass: \"result-wrapper\",\n      attrs: {\n        \"element-loading-text\": \"正在运行中...\"\n      }\n    }, [_c('div', {\n      staticClass: \"result-type\"\n    }, [_c('el-tag', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (item.mytitle === 'SubmitResult'),\n        expression: \"item.mytitle === 'SubmitResult'\"\n      }],\n      attrs: {\n        \"type\": \"success\"\n      }\n    }, [_vm._v(_vm._s(item.mytitle))]), _vm._v(\" \"), _c('el-tag', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (item.mytitle === 'RunResult'),\n        expression: \"item.mytitle === 'RunResult'\"\n      }],\n      attrs: {\n        \"type\": \"warning\"\n      }\n    }, [_vm._v(_vm._s(item.mytitle))])], 1), _vm._v(\" \"), _c('span', {\n      staticClass: \"result-item\"\n    }, [_c('span', {\n      staticClass: \"result-item-text\"\n    }, [_vm._v(\"耗费内存\")]), _vm._v(\" \" + _vm._s(item.memory_used) + \"\\n    \")]), _vm._v(\" \"), _c('span', {\n      staticClass: \"result-item\"\n    }, [_c('span', {\n      staticClass: \"result-item-text\"\n    }, [_vm._v(\"耗费时间\")]), _vm._v(\" \" + _vm._s(item.time_used) + \"\\n    \")]), _vm._v(\" \"), _c('span', {\n      staticClass: \"result-item\"\n    }, [_c('span', {\n      staticClass: \"result-item-text\"\n    }, [_vm._v(\"运行状态\\n        \"), _c('span', {\n      class: [item.status.includes('Error') ? 'error' : 'default']\n    }, [_vm._v(\" \" + _vm._s(item.status))])]), _vm._v(\" \"), _c('img', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (index === (_vm.result.length - 1)),\n        expression: \"index === (result.length-1)\"\n      }],\n      staticClass: \"result-item-img\",\n      attrs: {\n        \"src\": \"static/target.png\",\n        \"width\": \"32\",\n        \"height\": \"32\"\n      }\n    })])])\n  }), _vm._v(\" \"), _c('run-result-dialog', {\n    ref: \"dialog\",\n    attrs: {\n      \"result\": _vm.Runresult\n    }\n  })], 2)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"XgT+\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".solution[data-v-6701a6dc]{padding:5px 10px 0 12px;background:#f2f2f2;line-height:1.7}.solution .toc[data-v-6701a6dc]{display:table;border:1px solid #aaa;background-color:#f9f9f9;padding:7px 25px 3px 7px;margin-top:15px;font-size:95%}.solution .toc ul[data-v-6701a6dc]{margin-top:0;margin-bottom:10px}.solution .toc ul li a[data-v-6701a6dc]{pointer-events:none;color:#08c;text-decoration:none}h2[data-v-6701a6dc]{font-size:1.75em}h2[data-v-6701a6dc],h4[data-v-6701a6dc]{font-weight:700;margin-top:1.275em;margin-bottom:.85em;line-height:1.7}h4[data-v-6701a6dc]{font-size:1.25em}hr[data-v-6701a6dc]{height:4px;padding:0;margin:1.7em 0;overflow:hidden;background-color:#e7e7e7;border:none}p[data-v-6701a6dc]{margin:0 0 10px;display:block;-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0;font-size:16px;font-weight:400}code[data-v-6701a6dc]{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}b[data-v-6701a6dc],strong[data-v-6701a6dc]{font-weight:700}pre[data-v-6701a6dc]{display:block;padding:9.5px;margin:0 0 10px;overflow:auto;font-size:14px;line-height:1.9;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f2f2f2;border:1px solid #ccc;border-radius:4px;font-family:Menlo,Monaco,Consolas,Courier New,monospace}pre .nf[data-v-6701a6dc]{color:#900;font-weight:700}pre .na[data-v-6701a6dc]{color:teal}pre .kt[data-v-6701a6dc]{color:#458;font-weight:700}pre .o[data-v-6701a6dc]{font-weight:700}.nodata[data-v-6701a6dc]{height:100%;width:100%;padding:8rem 4rem;text-align:center;font-size:1.5rem;color:#333}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/solution/solution.vue\"],\"names\":[],\"mappings\":\"AACA,2BACE,wBAAyB,AACzB,mBAAoB,AACpB,eAAiB,CAClB,AACD,gCACE,cAAe,AACf,sBAAuB,AACvB,yBAA0B,AAC1B,yBAA0B,AAC1B,gBAAiB,AACjB,aAAe,CAChB,AACD,mCACE,aAAc,AACd,kBAAoB,CACrB,AACD,wCACE,oBAAqB,AACrB,WAAY,AACZ,oBAAsB,CACvB,AACD,oBACE,gBAAkB,CAKnB,AACD,wCALE,gBAAiB,AACjB,mBAAoB,AACpB,oBAAsB,AACtB,eAAiB,CAQlB,AAND,oBACE,gBAAkB,CAKnB,AACD,oBACE,WAAY,AACZ,UAAW,AACX,eAAgB,AAChB,gBAAiB,AACjB,yBAA0B,AAC1B,WAAa,CACd,AACD,mBACE,gBAAiB,AACjB,cAAe,AACf,0BAA2B,AAC3B,yBAA0B,AAC1B,uBAA0B,AAC1B,qBAAwB,AACxB,eAAgB,AAChB,eAAiB,CAClB,AACD,sBACE,gBAAiB,AACjB,cAAe,AACf,cAAe,AACf,yBAA0B,AAC1B,iBAAmB,CACpB,AACD,2CAEE,eAAiB,CAClB,AACD,qBACE,cAAe,AACf,cAAe,AACf,gBAAiB,AACjB,cAAe,AACf,eAAgB,AAChB,gBAAiB,AACjB,WAAY,AACZ,qBAAsB,AACtB,qBAAsB,AACtB,yBAA0B,AAC1B,sBAAuB,AACvB,kBAAmB,AACnB,uDAA+D,CAChE,AACD,yBACE,WAAY,AACZ,eAAkB,CACnB,AACD,yBACE,UAAe,CAChB,AACD,yBACE,WAAY,AACZ,eAAkB,CACnB,AACD,wBACE,eAAkB,CACnB,AACD,yBACE,YAAa,AACb,WAAY,AACZ,kBAAmB,AACnB,kBAAmB,AACnB,iBAAkB,AAClB,UAAY,CACb\",\"file\":\"solution.vue\",\"sourcesContent\":[\"\\n.solution[data-v-6701a6dc] {\\n  padding: 5px 10px 0 12px;\\n  background: #f2f2f2;\\n  line-height: 1.7;\\n}\\n.solution .toc[data-v-6701a6dc] {\\n  display: table;\\n  border: 1px solid #aaa;\\n  background-color: #f9f9f9;\\n  padding: 7px 25px 3px 7px;\\n  margin-top: 15px;\\n  font-size: 95%;\\n}\\n.solution .toc ul[data-v-6701a6dc] {\\n  margin-top: 0;\\n  margin-bottom: 10px;\\n}\\n.solution .toc ul li a[data-v-6701a6dc] {\\n  pointer-events: none;\\n  color: #08c;\\n  text-decoration: none;\\n}\\nh2[data-v-6701a6dc] {\\n  font-size: 1.75em;\\n  font-weight: 700;\\n  margin-top: 1.275em;\\n  margin-bottom: 0.85em;\\n  line-height: 1.7;\\n}\\nh4[data-v-6701a6dc] {\\n  font-size: 1.25em;\\n  font-weight: 700;\\n  margin-top: 1.275em;\\n  margin-bottom: 0.85em;\\n  line-height: 1.7;\\n}\\nhr[data-v-6701a6dc] {\\n  height: 4px;\\n  padding: 0;\\n  margin: 1.7em 0;\\n  overflow: hidden;\\n  background-color: #e7e7e7;\\n  border: none;\\n}\\np[data-v-6701a6dc] {\\n  margin: 0 0 10px;\\n  display: block;\\n  -webkit-margin-before: 1em;\\n  -webkit-margin-after: 1em;\\n  -webkit-margin-start: 0px;\\n  -webkit-margin-end: 0px;\\n  font-size: 16px;\\n  font-weight: 400;\\n}\\ncode[data-v-6701a6dc] {\\n  padding: 2px 4px;\\n  font-size: 90%;\\n  color: #c7254e;\\n  background-color: #f9f2f4;\\n  border-radius: 4px;\\n}\\nb[data-v-6701a6dc],\\nstrong[data-v-6701a6dc] {\\n  font-weight: 700;\\n}\\npre[data-v-6701a6dc] {\\n  display: block;\\n  padding: 9.5px;\\n  margin: 0 0 10px;\\n  overflow: auto;\\n  font-size: 14px;\\n  line-height: 1.9;\\n  color: #333;\\n  word-break: break-all;\\n  word-wrap: break-word;\\n  background-color: #f2f2f2;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\npre .nf[data-v-6701a6dc] {\\n  color: #900;\\n  font-weight: bold;\\n}\\npre .na[data-v-6701a6dc] {\\n  color: #008080;\\n}\\npre .kt[data-v-6701a6dc] {\\n  color: #458;\\n  font-weight: bold;\\n}\\npre .o[data-v-6701a6dc] {\\n  font-weight: bold;\\n}\\n.nodata[data-v-6701a6dc] {\\n  height: 100%;\\n  width: 100%;\\n  padding: 8rem 4rem;\\n  text-align: center;\\n  font-size: 1.5rem;\\n  color: #333;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"Xh4M\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"f+y5\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"10d8bb4b\", content, true);\n\n/***/ }),\n\n/***/ \"Yokd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"engA\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"da13b76a\", content, true);\n\n/***/ }),\n\n/***/ \"Z6qg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  // Rough heuristic to try and detect lines that are part of multi-line string\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode()\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\n    if (open == -1) return false\n    var endLine = end == start ? startLine : self.getLine(end)\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    if (close == -1 && start != end) {\n      endLine = self.getLine(--end);\n      close = endLine.indexOf(endString);\n    }\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\n    if (close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n/***/ }),\n\n/***/ \"aGTD\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var WRAP_CLASS = \"CodeMirror-activeline\";\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\n  var GUTT_CLASS = \"CodeMirror-activeline-gutter\";\n\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n    var prev = old == CodeMirror.Init ? false : old;\n    if (val == prev) return\n    if (prev) {\n      cm.off(\"beforeSelectionChange\", selectionChange);\n      clearActiveLines(cm);\n      delete cm.state.activeLines;\n    }\n    if (val) {\n      cm.state.activeLines = [];\n      updateActiveLines(cm, cm.listSelections());\n      cm.on(\"beforeSelectionChange\", selectionChange);\n    }\n  });\n\n  function clearActiveLines(cm) {\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\n      cm.removeLineClass(cm.state.activeLines[i], \"wrap\", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"background\", BACK_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"gutter\", GUTT_CLASS);\n    }\n  }\n\n  function sameArray(a, b) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++)\n      if (a[i] != b[i]) return false;\n    return true;\n  }\n\n  function updateActiveLines(cm, ranges) {\n    var active = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var option = cm.getOption(\"styleActiveLine\");\n      if (typeof option == \"object\" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n        continue\n      var line = cm.getLineHandleVisualStart(range.head.line);\n      if (active[active.length - 1] != line) active.push(line);\n    }\n    if (sameArray(cm.state.activeLines, active)) return;\n    cm.operation(function() {\n      clearActiveLines(cm);\n      for (var i = 0; i < active.length; i++) {\n        cm.addLineClass(active[i], \"wrap\", WRAP_CLASS);\n        cm.addLineClass(active[i], \"background\", BACK_CLASS);\n        cm.addLineClass(active[i], \"gutter\", GUTT_CLASS);\n      }\n      cm.state.activeLines = active;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLines(cm, sel.ranges);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"aOIS\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".notes[data-v-c64ce914]{margin-top:25px;height:590px}.notes .v-note-wrapper[data-v-c64ce914]{height:500px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/notes/notes.vue\"],\"names\":[],\"mappings\":\"AACA,wBACE,gBAAiB,AACjB,YAAc,CACf,AACD,wCACE,YAAc,CACf\",\"file\":\"notes.vue\",\"sourcesContent\":[\"\\n.notes[data-v-c64ce914] {\\n  margin-top: 25px;\\n  height: 590px;\\n}\\n.notes .v-note-wrapper[data-v-c64ce914] {\\n  height: 500px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"aX1R\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var defaults = {\n    pairs: \"()[]{}''\\\"\\\"\",\n    triples: \"\",\n    explode: \"[]{}\"\n  };\n\n  var Pos = CodeMirror.Pos;\n\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.removeKeyMap(keyMap);\n      cm.state.closeBrackets = null;\n    }\n    if (val) {\n      cm.state.closeBrackets = val;\n      cm.addKeyMap(keyMap);\n    }\n  });\n\n  function getOption(conf, name) {\n    if (name == \"pairs\" && typeof conf == \"string\") return conf;\n    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\n    return defaults[name];\n  }\n\n  var bind = defaults.pairs + \"`\";\n  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n  for (var i = 0; i < bind.length; i++)\n    keyMap[\"'\" + bind.charAt(i) + \"'\"] = handler(bind.charAt(i));\n\n  function handler(ch) {\n    return function(cm) { return handleChar(cm, ch); };\n  }\n\n  function getConfig(cm) {\n    var deflt = cm.state.closeBrackets;\n    if (!deflt || deflt.override) return deflt;\n    var mode = cm.getModeAt(cm.getCursor());\n    return mode.closeBrackets || deflt;\n  }\n\n  function handleBackspace(cm) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var cur = ranges[i].head;\n      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), \"+delete\");\n    }\n  }\n\n  function handleEnter(cm) {\n    var conf = getConfig(cm);\n    var explode = conf && getOption(conf, \"explode\");\n    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    cm.operation(function() {\n      cm.replaceSelection(\"\\n\\n\", null);\n      cm.execCommand(\"goCharLeft\");\n      ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var line = ranges[i].head.line;\n        cm.indentLine(line, null, true);\n        cm.indentLine(line + 1, null, true);\n      }\n    });\n  }\n\n  function contractSelection(sel) {\n    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n  }\n\n  function handleChar(cm, ch) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var pos = pairs.indexOf(ch);\n    if (pos == -1) return CodeMirror.Pass;\n    var triples = getOption(conf, \"triples\");\n\n    var identical = pairs.charAt(pos + 1) == ch;\n    var ranges = cm.listSelections();\n    var opening = pos % 2 == 0;\n\n    var type;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], cur = range.head, curType;\n      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n      if (opening && !range.empty()) {\n        curType = \"surround\";\n      } else if ((identical || !opening) && next == ch) {\n        if (identical && stringStartsAfter(cm, cur))\n          curType = \"both\";\n        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n          curType = \"skipThree\";\n        else\n          curType = \"skip\";\n      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&\n                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {\n        curType = \"addFour\";\n      } else if (identical) {\n        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = \"both\";\n        else return CodeMirror.Pass;\n      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||\n                             isClosingBracket(next, pairs) ||\n                             /\\s/.test(next))) {\n        curType = \"both\";\n      } else {\n        return CodeMirror.Pass;\n      }\n      if (!type) type = curType;\n      else if (type != curType) return CodeMirror.Pass;\n    }\n\n    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n    cm.operation(function() {\n      if (type == \"skip\") {\n        cm.execCommand(\"goCharRight\");\n      } else if (type == \"skipThree\") {\n        for (var i = 0; i < 3; i++)\n          cm.execCommand(\"goCharRight\");\n      } else if (type == \"surround\") {\n        var sels = cm.getSelections();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = left + sels[i] + right;\n        cm.replaceSelections(sels, \"around\");\n        sels = cm.listSelections().slice();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = contractSelection(sels[i]);\n        cm.setSelections(sels);\n      } else if (type == \"both\") {\n        cm.replaceSelection(left + right, null);\n        cm.triggerElectric(left + right);\n        cm.execCommand(\"goCharLeft\");\n      } else if (type == \"addFour\") {\n        cm.replaceSelection(left + left + left + left, \"before\");\n        cm.execCommand(\"goCharRight\");\n      }\n    });\n  }\n\n  function isClosingBracket(ch, pairs) {\n    var pos = pairs.lastIndexOf(ch);\n    return pos > -1 && pos % 2 == 1;\n  }\n\n  function charsAround(cm, pos) {\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n                          Pos(pos.line, pos.ch + 1));\n    return str.length == 2 ? str : null;\n  }\n\n  // Project the token type that will exists after the given char is\n  // typed, and use it to determine whether it would cause the start\n  // of a string token.\n  function enteringString(cm, pos, ch) {\n    var line = cm.getLine(pos.line);\n    var token = cm.getTokenAt(pos);\n    if (/\\bstring2?\\b/.test(token.type) || stringStartsAfter(cm, pos)) return false;\n    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\n    stream.pos = stream.start = token.start;\n    for (;;) {\n      var type1 = cm.getMode().token(stream, token.state);\n      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\n      stream.start = stream.pos;\n    }\n  }\n\n  function stringStartsAfter(cm, pos) {\n    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))\n    return /\\bstring/.test(token.type) && token.start == pos.ch\n  }\n});\n\n\n/***/ }),\n\n/***/ \"bp3c\":\n/***/ (function(module, exports) {\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/***/ }),\n\n/***/ \"c+I8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureGlobal(regexp) {\n    return regexp.global ? regexp : new RegExp(regexp.source, regexpFlags(regexp) + \"g\")\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (end.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureGlobal(query)\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n\n\n/***/ }),\n\n/***/ \"dxBS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"markdown\", function(cm, start) {\n  var maxDepth = 100;\n\n  function isHeader(lineNo) {\n    var tokentype = cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0));\n    return tokentype && /\\bheader\\b/.test(tokentype);\n  }\n\n  function headerLevel(lineNo, line, nextLine) {\n    var match = line && line.match(/^#+/);\n    if (match && isHeader(lineNo)) return match[0].length;\n    match = nextLine && nextLine.match(/^[=\\-]+\\s*$/);\n    if (match && isHeader(lineNo + 1)) return nextLine[0] == \"=\" ? 1 : 2;\n    return maxDepth;\n  }\n\n  var firstLine = cm.getLine(start.line), nextLine = cm.getLine(start.line + 1);\n  var level = headerLevel(start.line, firstLine, nextLine);\n  if (level === maxDepth) return undefined;\n\n  var lastLineNo = cm.lastLine();\n  var end = start.line, nextNextLine = cm.getLine(end + 2);\n  while (end < lastLineNo) {\n    if (headerLevel(end + 1, nextLine, nextNextLine) <= level) break;\n    ++end;\n    nextLine = nextNextLine;\n    nextNextLine = cm.getLine(end + 2);\n  }\n\n  return {\n    from: CodeMirror.Pos(start.line, firstLine.length),\n    to: CodeMirror.Pos(end, cm.getLine(end).length)\n  };\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"eg3M\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in\"\n    }\n  }, [_c('div', [(_vm.solution) ? _c('div', {\n    staticClass: \"solution\",\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.solution)\n    }\n  }) : _vm._e(), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.solution || _vm.solution === {}),\n      expression: \"!solution || solution === {}\"\n    }],\n    staticClass: \"nodata\"\n  }, [_vm._v(\"\\n      No solution at the moment\\n    \")])])])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"engA\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror-foldmarker{color:blue;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\\\"\\\\25BE\\\"}.CodeMirror-foldgutter-folded:after{content:\\\"\\\\25B8\\\"}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/fold/foldgutter.css\"],\"names\":[],\"mappings\":\"AAAA,uBACE,WAAY,AACZ,oFAAwF,AACxF,kBAAmB,AACnB,eAAgB,AAChB,cAAgB,CACjB,AACD,uBACE,UAAY,CACb,AACD,0DAEE,cAAgB,CACjB,AACD,kCACE,eAAiB,CAClB,AACD,oCACE,eAAiB,CAClB\",\"file\":\"foldgutter.css\",\"sourcesContent\":[\".CodeMirror-foldmarker {\\n  color: blue;\\n  text-shadow: #b9f 1px 1px 2px, #b9f -1px -1px 2px, #b9f 1px -1px 2px, #b9f -1px 1px 2px;\\n  font-family: arial;\\n  line-height: .3;\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter {\\n  width: .7em;\\n}\\n.CodeMirror-foldgutter-open,\\n.CodeMirror-foldgutter-folded {\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter-open:after {\\n  content: \\\"\\\\25BE\\\";\\n}\\n.CodeMirror-foldgutter-folded:after {\\n  content: \\\"\\\\25B8\\\";\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"f+y5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".myeditor[data-v-58438f59]{margin-top:20px}.myeditor .myeditor-header[data-v-58438f59]{margin-bottom:12px}.myeditor .language-dropdown .el-dropdown-menu__item[data-v-58438f59]{padding:0 5px}.myeditor .el-dropdown-theme[data-v-58438f59]{float:right}.myeditor .el-dropdown-keyMap[data-v-58438f59]{float:right;margin-right:8px}.myeditor .CodeMirror[data-v-58438f59]{height:400px}.myeditor .myeditor-footer[data-v-58438f59]{padding:20px 0 0;height:100px;width:100%}.myeditor .myeditor-footer .custom-button[data-v-58438f59]{float:left;margin-right:10px;width:150px}.myeditor .myeditor-footer .run-button[data-v-58438f59]{float:right;margin-right:10px;width:150px}.myeditor .myeditor-footer .submit-button[data-v-58438f59]{float:right;width:150px}.myeditor .result-wrapper[data-v-58438f59]{display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:-1px;padding:10px 0;border-bottom:1px solid #ddd;border-top:1px solid #ddd}.myeditor .result-wrapper .result-type[data-v-58438f59]{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto;display:inline-block}.myeditor .result-wrapper .result-type .el-tag[data-v-58438f59]{margin-top:4px;font-size:18px}.myeditor .result-wrapper .result-item[data-v-58438f59]{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;text-align:center}.myeditor .result-wrapper .result-item .result-item-text[data-v-58438f59]{font-size:18px;font-weight:600;margin:0 5px;line-height:30px;color:#9e9e9e}.myeditor .result-wrapper .result-item .result-item-text .error[data-v-58438f59]{color:#ff1744}.myeditor .result-wrapper .result-item .result-item-text .default[data-v-58438f59]{color:#333}.myeditor .result-wrapper .result-item-img[data-v-58438f59]{vertical-align:middle}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/description/myeditor.vue\"],\"names\":[],\"mappings\":\"AACA,2BACE,eAAiB,CAClB,AACD,4CACE,kBAAoB,CACrB,AACD,sEACE,aAAe,CAChB,AACD,8CACE,WAAa,CACd,AACD,+CACE,YAAa,AACb,gBAAkB,CACnB,AACD,uCACE,YAAc,CACf,AACD,4CACE,iBAAoB,AACpB,aAAc,AACd,UAAY,CACb,AACD,2DACE,WAAY,AACZ,kBAAmB,AACnB,WAAa,CACd,AACD,wDACE,YAAa,AACb,kBAAmB,AACnB,WAAa,CACd,AACD,2DACE,YAAa,AACb,WAAa,CACd,AACD,2CACE,oBAAqB,AACrB,oBAAqB,AACrB,aAAc,AACd,gBAAiB,AACjB,eAAgB,AAChB,6BAA8B,AAC9B,yBAA2B,CAC5B,AACD,wDACE,mBAAoB,AAChB,kBAAmB,AACf,cAAe,AACvB,oBAAsB,CACvB,AACD,gEACE,eAAgB,AAChB,cAAgB,CACjB,AACD,wDACE,mBAAoB,AAChB,kBAAmB,AACf,cAAe,AACvB,iBAAmB,CACpB,AACD,0EACE,eAAgB,AAChB,gBAAiB,AACjB,aAAc,AACd,iBAAkB,AAClB,aAAe,CAChB,AACD,iFACE,aAAe,CAChB,AACD,mFACE,UAAY,CACb,AACD,4DACE,qBAAuB,CACxB\",\"file\":\"myeditor.vue\",\"sourcesContent\":[\"\\n.myeditor[data-v-58438f59] {\\n  margin-top: 20px;\\n}\\n.myeditor .myeditor-header[data-v-58438f59] {\\n  margin-bottom: 12px;\\n}\\n.myeditor .language-dropdown .el-dropdown-menu__item[data-v-58438f59] {\\n  padding: 0 5px;\\n}\\n.myeditor .el-dropdown-theme[data-v-58438f59] {\\n  float: right;\\n}\\n.myeditor .el-dropdown-keyMap[data-v-58438f59] {\\n  float: right;\\n  margin-right: 8px;\\n}\\n.myeditor .CodeMirror[data-v-58438f59] {\\n  height: 400px;\\n}\\n.myeditor .myeditor-footer[data-v-58438f59] {\\n  padding: 20px 0 0 0;\\n  height: 100px;\\n  width: 100%;\\n}\\n.myeditor .myeditor-footer .custom-button[data-v-58438f59] {\\n  float: left;\\n  margin-right: 10px;\\n  width: 150px;\\n}\\n.myeditor .myeditor-footer .run-button[data-v-58438f59] {\\n  float: right;\\n  margin-right: 10px;\\n  width: 150px;\\n}\\n.myeditor .myeditor-footer .submit-button[data-v-58438f59] {\\n  float: right;\\n  width: 150px;\\n}\\n.myeditor .result-wrapper[data-v-58438f59] {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin-top: -1px;\\n  padding: 10px 0;\\n  border-bottom: 1px solid #ddd;\\n  border-top: 1px solid #ddd;\\n}\\n.myeditor .result-wrapper .result-type[data-v-58438f59] {\\n  -webkit-box-flex: 0;\\n      -ms-flex: 0 1 auto;\\n          flex: 0 1 auto;\\n  display: inline-block;\\n}\\n.myeditor .result-wrapper .result-type .el-tag[data-v-58438f59] {\\n  margin-top: 4px;\\n  font-size: 18px;\\n}\\n.myeditor .result-wrapper .result-item[data-v-58438f59] {\\n  -webkit-box-flex: 1;\\n      -ms-flex: 1 1 auto;\\n          flex: 1 1 auto;\\n  text-align: center;\\n}\\n.myeditor .result-wrapper .result-item .result-item-text[data-v-58438f59] {\\n  font-size: 18px;\\n  font-weight: 600;\\n  margin: 0 5px;\\n  line-height: 30px;\\n  color: #9e9e9e;\\n}\\n.myeditor .result-wrapper .result-item .result-item-text .error[data-v-58438f59] {\\n  color: #ff1744;\\n}\\n.myeditor .result-wrapper .result-item .result-item-text .default[data-v-58438f59] {\\n  color: #333;\\n}\\n.myeditor .result-wrapper .result-item-img[data-v-58438f59] {\\n  vertical-align: middle;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"fo6W\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var startLine = start.line, has = hasImport(startLine), prev;\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var startLine = start.line, has = hasInclude(startLine);\n  if (has == null || hasInclude(startLine - 1) != null) return null;\n  for (var end = startLine;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(startLine, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"fpaw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in\"\n    }\n  }, [_c('div', [(_vm.data.description) ? _c('div', {\n    staticClass: \"description\",\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.data.description)\n    }\n  }) : _vm._e(), _vm._v(\" \"), _c('my-editor')], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"j09L\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_notes_vue__ = __webpack_require__(\"+onj\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_c64ce914_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_notes_vue__ = __webpack_require__(\"SVHh\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"jCel\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-c64ce914\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_notes_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_c64ce914_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_notes_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"jCel\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"aOIS\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"30ccd70a\", content, true);\n\n/***/ }),\n\n/***/ \"jQeI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    var self = this;\n    cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      this.cm.off(\"cursorActivity\", this.activityFunc);\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i];\n      if (completion.hint) completion.hint(this.cm, data, completion);\n      else this.cm.replaceRange(getText(completion), completion.from || data.from,\n                                completion.to || data.to, \"complete\");\n      CodeMirror.signal(data, \"pick\", completion);\n      this.close();\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||\n          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      if (data && this.data && isNewCompletion(this.data, data)) return;\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function isNewCompletion(old, nw) {\n    var moved = CodeMirror.cmpPos(nw.from, old.from)\n    return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch\n  }\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n\n    var hints = this.hints = document.createElement(\"ul\");\n    hints.className = \"CodeMirror-hints\";\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    hints.style.left = left + \"px\";\n    hints.style.top = top + \"px\";\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n    (completion.options.container || document.body).appendChild(hints);\n    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n    var scrolls = hints.scrollHeight > hints.clientHeight + 1\n    var startScroll = cm.getScrollInfo();\n\n    if (overlapY > 0) {\n      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n      if (curTop - height > 0) { // Fits above cursor\n        hints.style.top = (top = pos.top - height) + \"px\";\n        below = false;\n      } else if (height > winH) {\n        hints.style.height = (winH - 5) + \"px\";\n        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n        var cursor = cm.getCursor();\n        if (data.from.ch != cursor.ch) {\n          pos = cm.cursorCoords(cursor);\n          hints.style.left = (left = pos.left) + \"px\";\n          box = hints.getBoundingClientRect();\n        }\n      }\n    }\n    var overlapX = box.right - winW;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = pos.left - overlapX) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      if (node.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node.offsetTop - 3;\n      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    var to = CodeMirror.Pos(cur.line, token.end);\n    if (token.string && /\\w/.test(token.string[token.string.length - 1])) {\n      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);\n    } else {\n      var term = \"\", from = to;\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnUnfocus: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n\n\n/***/ }),\n\n/***/ \"lDdF\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 1.3.2\n * 2016-06-16 18:25:19\n *\n * By Eli Grey, http://eligrey.com\n * License: MIT\n *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs || (function(view) {\n\t\"use strict\";\n\t// IE <10 is explicitly unsupported\n\tif (typeof view === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n\t\treturn;\n\t}\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case Blob.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = new MouseEvent(\"click\");\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, is_safari = /constructor/i.test(view.HTMLElement) || view.safari\n\t\t, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)\n\t\t, throw_outside = function(ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t// the Blob API is fundamentally broken as there is no \"downloadfinished\" event to subscribe to\n\t\t, arbitrary_revoke_timeout = 1000 * 40 // in ms\n\t\t, revoke = function(file) {\n\t\t\tvar revoker = function() {\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tget_URL().revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetTimeout(revoker, arbitrary_revoke_timeout);\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, auto_bom = function(blob) {\n\t\t\t// prepend BOM for UTF-8 XML and text/* types (including HTML)\n\t\t\t// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\t\t\tif (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n\t\t\t\treturn new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});\n\t\t\t}\n\t\t\treturn blob;\n\t\t}\n\t\t, FileSaver = function(blob, name, no_auto_bom) {\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, force = type === force_saveable_type\n\t\t\t\t, object_url\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\tif ((is_chrome_ios || (force && is_safari)) && view.FileReader) {\n\t\t\t\t\t\t// Safari doesn't allow downloading of blob urls\n\t\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\t\treader.onloadend = function() {\n\t\t\t\t\t\t\tvar url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\t\t\t\tvar popup = view.open(url, '_blank');\n\t\t\t\t\t\t\tif(!popup) view.location.href = url;\n\t\t\t\t\t\t\turl=undefined; // release reference before dispatching\n\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\tdispatch_all();\n\t\t\t\t\t\t};\n\t\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (!object_url) {\n\t\t\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opened = view.open(object_url, \"_blank\");\n\t\t\t\t\t\tif (!opened) {\n\t\t\t\t\t\t\t// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html\n\t\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t}\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tsave_link.href = object_url;\n\t\t\t\t\tsave_link.download = name;\n\t\t\t\t\tclick(save_link);\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfs_error();\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name, no_auto_bom) {\n\t\t\treturn new FileSaver(blob, name || blob.name || \"download\", no_auto_bom);\n\t\t}\n\t;\n\t// IE 10+ (native saveAs)\n\tif (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\n\t\treturn function(blob, name, no_auto_bom) {\n\t\t\tname = name || blob.name || \"download\";\n\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\treturn navigator.msSaveOrOpenBlob(blob, name);\n\t\t};\n\t}\n\n\tFS_proto.abort = function(){};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\treturn saveAs;\n}(\n\t   typeof self !== \"undefined\" && self\n\t|| typeof window !== \"undefined\" && window\n\t|| this.content\n));\n// `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports.saveAs = saveAs;\n} else if ((\"function\" !== \"undefined\" && __webpack_require__(\"LGuY\") !== null) && (__webpack_require__(\"nErl\") !== null)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n    return saveAs;\n  }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n/***/ }),\n\n/***/ \"lL6t\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"Iula\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"1ec08980\", content, true);\n\n/***/ }),\n\n/***/ \"lUyH\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hints_vue__ = __webpack_require__(\"bp3c\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hints_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hints_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_062a844c_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_hints_vue__ = __webpack_require__(\"6rPU\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"1LpH\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_hints_vue___default.a,\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_062a844c_hasScoped_false_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_hints_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"nErl\":\n/***/ (function(module, exports) {\n\n/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }),\n\n/***/ \"oFfA\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".description[data-v-4dfc5728]{border-bottom:1px solid #ddd}.description p[data-v-4dfc5728]{margin:0 0 10px;display:block;font-size:16px;-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0}.description pre[data-v-4dfc5728]{display:block;padding:9.5px;margin:0 0 10px;overflow:auto;font-size:14px;line-height:1.9;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f2f2f2;border:1px solid #ccc;border-radius:4px;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.description pre .nf[data-v-4dfc5728]{color:#900;font-weight:700}.description pre .na[data-v-4dfc5728]{color:teal}.description pre .kt[data-v-4dfc5728]{color:#458;font-weight:700}.description pre .o[data-v-4dfc5728]{font-weight:700}.description code[data-v-4dfc5728]{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.description b[data-v-4dfc5728]{font-weight:700}.description ol[data-v-4dfc5728]{margin-top:10px}.description ol li[data-v-4dfc5728]{font-size:16px}.editor .ql-editor[data-v-4dfc5728]{min-height:300px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/description/description.vue\"],\"names\":[],\"mappings\":\"AACA,8BACE,4BAA8B,CAC/B,AACD,gCACE,gBAAiB,AACjB,cAAe,AACf,eAAgB,AAChB,0BAA2B,AAC3B,yBAA0B,AAC1B,uBAA0B,AAC1B,oBAAwB,CACzB,AACD,kCACE,cAAe,AACf,cAAe,AACf,gBAAiB,AACjB,cAAe,AACf,eAAgB,AAChB,gBAAiB,AACjB,WAAY,AACZ,qBAAsB,AACtB,qBAAsB,AACtB,yBAA0B,AAC1B,sBAAuB,AACvB,kBAAmB,AACnB,uDAA+D,CAChE,AACD,sCACE,WAAY,AACZ,eAAkB,CACnB,AACD,sCACE,UAAe,CAChB,AACD,sCACE,WAAY,AACZ,eAAkB,CACnB,AACD,qCACE,eAAkB,CACnB,AACD,mCACE,gBAAiB,AACjB,cAAe,AACf,cAAe,AACf,yBAA0B,AAC1B,kBAAmB,AACnB,uDAA+D,CAChE,AACD,gCACE,eAAiB,CAClB,AACD,iCACE,eAAiB,CAClB,AACD,oCACE,cAAgB,CACjB,AACD,oCACE,gBAAkB,CACnB\",\"file\":\"description.vue\",\"sourcesContent\":[\"\\n.description[data-v-4dfc5728] {\\n  border-bottom: 1px solid #ddd;\\n}\\n.description p[data-v-4dfc5728] {\\n  margin: 0 0 10px;\\n  display: block;\\n  font-size: 16px;\\n  -webkit-margin-before: 1em;\\n  -webkit-margin-after: 1em;\\n  -webkit-margin-start: 0px;\\n  -webkit-margin-end: 0px;\\n}\\n.description pre[data-v-4dfc5728] {\\n  display: block;\\n  padding: 9.5px;\\n  margin: 0 0 10px;\\n  overflow: auto;\\n  font-size: 14px;\\n  line-height: 1.9;\\n  color: #333;\\n  word-break: break-all;\\n  word-wrap: break-word;\\n  background-color: #f2f2f2;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\n.description pre .nf[data-v-4dfc5728] {\\n  color: #900;\\n  font-weight: bold;\\n}\\n.description pre .na[data-v-4dfc5728] {\\n  color: #008080;\\n}\\n.description pre .kt[data-v-4dfc5728] {\\n  color: #458;\\n  font-weight: bold;\\n}\\n.description pre .o[data-v-4dfc5728] {\\n  font-weight: bold;\\n}\\n.description code[data-v-4dfc5728] {\\n  padding: 2px 4px;\\n  font-size: 90%;\\n  color: #c7254e;\\n  background-color: #f9f2f4;\\n  border-radius: 4px;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\n.description b[data-v-4dfc5728] {\\n  font-weight: 700;\\n}\\n.description ol[data-v-4dfc5728] {\\n  margin-top: 10px;\\n}\\n.description ol li[data-v-4dfc5728] {\\n  font-size: 16px;\\n}\\n.editor .ql-editor[data-v-4dfc5728] {\\n  min-height: 300px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"q8U2\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('el-dialog', {\n    attrs: {\n      \"title\": \"运行结果\",\n      \"visible\": _vm.dialogVisible\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.dialogVisible = $event\n      }\n    }\n  }, [_c('span', {\n    slot: \"title\"\n  }, [_vm._v(\" \" + _vm._s(_vm.result.status))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"dialog-container\"\n  }, [_c('div', {\n    staticClass: \"explanation\",\n    domProps: {\n      \"textContent\": _vm._s(_vm.getExplanation(_vm.result.status))\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"text\",\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.result.output)\n    }\n  }, [_vm._v(\"{{}}\")])]), _vm._v(\" \"), _c('span', {\n    staticClass: \"dialog-footer\",\n    slot: \"footer\"\n  }, [_c('el-button', {\n    on: {\n      \"click\": function($event) {\n        _vm.dialogVisible = false\n      }\n    }\n  }, [_vm._v(\"取 消\")]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": function($event) {\n        _vm.dialogVisible = false\n      }\n    }\n  }, [_vm._v(\"确 定\")])], 1)])], 1)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"qnSv\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(\"Zrlr\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);\n\n\n/**\n * Created by qinzhen on 2017/9/30.\n */\nvar ReturnResult = function ReturnResult(_ref) {\n  var mytitle = _ref.mytitle,\n      memory_used = _ref.memory_used,\n      output = _ref.output,\n      status = _ref.status,\n      time_used = _ref.time_used;\n\n  __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, ReturnResult);\n\n  this.mytitle = mytitle;\n  this.memory_used = memory_used;\n  this.output = output;\n  this.status = status;\n  this.time_used = time_used;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ReturnResult);\n\n/***/ }),\n\n/***/ \"soCA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerGlobalHelper(\"fold\", \"comment\", function(mode) {\n  return mode.blockCommentStart && mode.blockCommentEnd;\n}, function(cm, start) {\n  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;\n  if (!startToken || !endToken) return;\n  var line = start.line, lineText = cm.getLine(line);\n\n  var startCh;\n  for (var at = start.ch, pass = 0;;) {\n    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);\n    if (found == -1) {\n      if (pass == 1) return;\n      pass = 1;\n      at = lineText.length;\n      continue;\n    }\n    if (pass == 1 && found < start.ch) return;\n    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&\n        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||\n         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {\n      startCh = found + startToken.length;\n      break;\n    }\n    at = found - 1;\n  }\n\n  var depth = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (pos == nextOpen) ++depth;\n      else if (!--depth) { end = i; endCh = pos; break outer; }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"tjx/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  function kill(cm, from, to, mayGrow, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (mayGrow) lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      kill(cm, cursor, findEnd(cm, cursor, by, dir), true);\n    }\n  }\n\n  function killRegion(cm) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        kill(cm, selection.anchor, selection.head);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  function setMark(cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(msg + \": <input type=\\\"text\\\" style=\\\"width: 10em\\\"/>\", f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  function quit(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  CodeMirror.emacs = {kill: kill, killRegion: killRegion, repeated: repeated};\n\n  // Actual keymap\n\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": function(cm) {kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"));},\n    \"Ctrl-K\": repeated(function(cm) {\n      var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n      var text = cm.getRange(start, end);\n      if (!/\\S/.test(text)) {\n        text += \"\\n\";\n        end = Pos(start.line + 1, 0);\n      }\n      kill(cm, start, end, true, text);\n    }),\n    \"Alt-W\": function(cm) {\n      addToRing(cm.getSelection());\n      clearMark(cm);\n    },\n    \"Ctrl-Y\": function(cm) {\n      var start = cm.getCursor();\n      cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n      cm.setSelection(start, cm.getCursor());\n    },\n    \"Alt-Y\": function(cm) {cm.replaceSelection(popFromRing(), \"around\", \"paste\");},\n\n    \"Ctrl-Space\": setMark, \"Ctrl-Shift-2\": setMark,\n\n    \"Ctrl-F\": move(byChar, 1), \"Ctrl-B\": move(byChar, -1),\n    \"Right\": move(byChar, 1), \"Left\": move(byChar, -1),\n    \"Ctrl-D\": function(cm) { killTo(cm, byChar, 1); },\n    \"Delete\": function(cm) { killRegion(cm) || killTo(cm, byChar, 1); },\n    \"Ctrl-H\": function(cm) { killTo(cm, byChar, -1); },\n    \"Backspace\": function(cm) { killRegion(cm) || killTo(cm, byChar, -1); },\n\n    \"Alt-F\": move(byWord, 1), \"Alt-B\": move(byWord, -1),\n    \"Alt-D\": function(cm) { killTo(cm, byWord, 1); },\n    \"Alt-Backspace\": function(cm) { killTo(cm, byWord, -1); },\n\n    \"Ctrl-N\": move(byLine, 1), \"Ctrl-P\": move(byLine, -1),\n    \"Down\": move(byLine, 1), \"Up\": move(byLine, -1),\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStart\",\n\n    \"Alt-V\": move(byPage, -1), \"Ctrl-V\": move(byPage, 1),\n    \"PageUp\": move(byPage, -1), \"PageDown\": move(byPage, 1),\n\n    \"Ctrl-Up\": move(byParagraph, -1), \"Ctrl-Down\": move(byParagraph, 1),\n\n    \"Alt-A\": move(bySentence, -1), \"Alt-E\": move(bySentence, 1),\n    \"Alt-K\": function(cm) { killTo(cm, bySentence, 1); },\n\n    \"Ctrl-Alt-K\": function(cm) { killTo(cm, byExpr, 1); },\n    \"Ctrl-Alt-Backspace\": function(cm) { killTo(cm, byExpr, -1); },\n    \"Ctrl-Alt-F\": move(byExpr, 1), \"Ctrl-Alt-B\": move(byExpr, -1),\n\n    \"Shift-Ctrl-Alt-2\": function(cm) {\n      var cursor = cm.getCursor();\n      cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n    },\n    \"Ctrl-Alt-T\": function(cm) {\n      var leftStart = byExpr(cm, cm.getCursor(), -1), leftEnd = byExpr(cm, leftStart, 1);\n      var rightEnd = byExpr(cm, leftEnd, 1), rightStart = byExpr(cm, rightEnd, -1);\n      cm.replaceRange(cm.getRange(rightStart, rightEnd) + cm.getRange(leftEnd, rightStart) +\n                      cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n    },\n    \"Ctrl-Alt-U\": repeated(toEnclosingExpr),\n\n    \"Alt-Space\": function(cm) {\n      var pos = cm.getCursor(), from = pos.ch, to = pos.ch, text = cm.getLine(pos.line);\n      while (from && /\\s/.test(text.charAt(from - 1))) --from;\n      while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n      cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n    },\n    \"Ctrl-O\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"start\"); }),\n    \"Ctrl-T\": repeated(function(cm) {\n      cm.execCommand(\"transposeChars\");\n    }),\n\n    \"Alt-C\": repeated(function(cm) {\n      operateOnWord(cm, function(w) {\n        var letter = w.search(/\\w/);\n        if (letter == -1) return w;\n        return w.slice(0, letter) + w.charAt(letter).toUpperCase() + w.slice(letter + 1).toLowerCase();\n      });\n    }),\n    \"Alt-U\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toUpperCase(); });\n    }),\n    \"Alt-L\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toLowerCase(); });\n    }),\n\n    \"Alt-;\": \"toggleComment\",\n\n    \"Ctrl-/\": repeated(\"undo\"), \"Shift-Ctrl--\": repeated(\"undo\"),\n    \"Ctrl-Z\": repeated(\"undo\"), \"Cmd-Z\": repeated(\"undo\"),\n    \"Shift-Alt-,\": \"goDocStart\", \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\", \"Ctrl-R\": \"findPersistentPrev\", \"Ctrl-G\": quit, \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); }),\n    \"Tab\": \"indentAuto\",\n\n    \"Alt-G G\": function(cm) {\n      var prefix = getPrefix(cm, true);\n      if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n      getInput(cm, \"Goto line\", function(str) {\n        var num;\n        if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n          cm.setCursor(num - 1);\n      });\n    },\n\n    \"Ctrl-X Tab\": function(cm) {\n      cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n    },\n    \"Ctrl-X Ctrl-X\": function(cm) {\n      cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n    },\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X U\": repeated(\"undo\"),\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X Delete\": function(cm) { kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), true); },\n    \"Ctrl-X H\": \"selectAll\",\n\n    \"Ctrl-Q Tab\": repeated(\"insertTab\"),\n    \"Ctrl-U\": addPrefixMap\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n\n\n/***/ }),\n\n/***/ \"vq+x\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && matching[line.text.charAt(pos)]) ||\n        matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n\n\n/***/ }),\n\n/***/ \"x494\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(\"Dd8w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vuex__ = __webpack_require__(\"NYxO\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_axios__ = __webpack_require__(\"mtWM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_components_description_description__ = __webpack_require__(\"8eAg\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_components_solution_solution__ = __webpack_require__(\"P830\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_components_hints_hints__ = __webpack_require__(\"lUyH\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_components_notes_notes__ = __webpack_require__(\"j09L\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_js_problem__ = __webpack_require__(\"5Ey+\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_js_data__ = __webpack_require__(\"DW9A\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  data: function data() {\n    return {\n      loading: true,\n      problemDetail: {},\n      tab: 'description'\n    };\n  },\n  created: function created() {\n    this._getProblemDetail();\n  },\n\n  methods: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({\n    _getProblemDetail: function _getProblemDetail() {\n      var _this = this;\n\n      if (!this.problem.id) {\n        this.$router.push('/home');\n        return;\n      }\n      console.log('problem detail id');\n      console.log(this.problem.id);\n      var url = __WEBPACK_IMPORTED_MODULE_8_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id;\n      __WEBPACK_IMPORTED_MODULE_2_axios___default.a.get(url).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_8_common_js_data__[\"b\" /* MSG_OK */]) {\n          console.log(response.data.result);\n          _this.problemDetail = response.data.result[0];\n          console.log(_this.problemDetail.id);\n          _this.loading = false;\n        }\n      }, function (response) {\n        _this._getProblemDetail();\n      });\n    },\n    collection: function collection() {\n      if (!this.user.user_id) {\n        this.$notify({\n          title: '无法收藏题目',\n          message: '请先登录',\n          type: 'error'\n        });\n      } else {\n        if (!this.hasCollect(this.problemDetail.id)) {\n          this.saveFavoriteList(new __WEBPACK_IMPORTED_MODULE_7_common_js_problem__[\"a\" /* default */]({\n            id: this.problemDetail.id,\n            title: this.problemDetail.title,\n            tag: this.problemDetail.tag,\n            level: this.problemDetail.level,\n            accepted: this.problemDetail.accepted,\n            submitted: this.problemDetail.submitted\n          }));\n          this.$notify({\n            title: '收藏成功',\n            message: '\\u6536\\u85CF\\u9898\\u76EE:' + this.problemDetail.title,\n            type: 'success'\n          });\n        } else {\n          this.deleteFavoriteList(new __WEBPACK_IMPORTED_MODULE_7_common_js_problem__[\"a\" /* default */]({\n            id: this.problemDetail.id,\n            title: this.problemDetail.title,\n            tag: this.problemDetail.tag,\n            level: this.problemDetail.level,\n            accepted: this.problemDetail.accepted,\n            submitted: this.problemDetail.submitted\n          }));\n          this.$notify.info({\n            title: '取消成功',\n            message: '\\u53D6\\u6D88\\u6536\\u85CF\\u9898\\u76EE:' + this.problemDetail.title\n          });\n        }\n      }\n    },\n    hasCollect: function hasCollect(id) {\n      var index = this.collectionList.findIndex(function (item) {\n        return item.id === id;\n      });\n      return index > -1;\n    },\n    getFavoriteSrc: function getFavoriteSrc(problemDetail) {\n      if (this.user.user_id != null && this.hasCollect(problemDetail.id)) {\n        return 'static/collection.png';\n      } else {\n        return 'static/nocollection.png';\n      }\n    }\n  }, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_vuex__[\"b\" /* mapActions */])(['saveFavoriteList', 'deleteFavoriteList'])),\n  computed: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_vuex__[\"d\" /* mapGetters */])(['problem', 'collectionList', 'user'])),\n  components: {\n    Description: __WEBPACK_IMPORTED_MODULE_3_components_description_description__[\"a\" /* default */],\n    Solution: __WEBPACK_IMPORTED_MODULE_4_components_solution_solution__[\"a\" /* default */],\n    Hints: __WEBPACK_IMPORTED_MODULE_5_components_hints_hints__[\"a\" /* default */],\n    Notes: __WEBPACK_IMPORTED_MODULE_6_components_notes_notes__[\"a\" /* default */]\n  }\n});\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/4.5ef6859d23f2d40c927b.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Tag-closer extension for CodeMirror.\n *\n * This extension adds an \"autoCloseTags\" option that can be set to\n * either true to get the default behavior, or an object to further\n * configure its behavior.\n *\n * These are supported options:\n *\n * `whenClosing` (default true)\n *   Whether to autoclose when the '/' of a closing tag is typed.\n * `whenOpening` (default true)\n *   Whether to autoclose the tag when the final '>' of an opening\n *   tag is typed.\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\n *   An array of tag names that should not be autoclosed.\n * `indentTags` (default is block tags for HTML, none for XML)\n *   An array of tag names that should, when opened, cause a\n *   blank line to be added inside the tag, and the blank line and\n *   closing line to be indented.\n *\n * See demos/closetag.html for a usage example.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../fold/xml-fold\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../fold/xml-fold\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  CodeMirror.defineOption(\"autoCloseTags\", false, function(cm, val, old) {\n    if (old != CodeMirror.Init && old)\n      cm.removeKeyMap(\"autoCloseTags\");\n    if (!val) return;\n    var map = {name: \"autoCloseTags\"};\n    if (typeof val != \"object\" || val.whenClosing)\n      map[\"'/'\"] = function(cm) { return autoCloseSlash(cm); };\n    if (typeof val != \"object\" || val.whenOpening)\n      map[\"'>'\"] = function(cm) { return autoCloseGT(cm); };\n    cm.addKeyMap(map);\n  });\n\n  var htmlDontClose = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n                       \"source\", \"track\", \"wbr\"];\n  var htmlIndent = [\"applet\", \"blockquote\", \"body\", \"button\", \"div\", \"dl\", \"fieldset\", \"form\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\",\n                    \"h5\", \"h6\", \"head\", \"html\", \"iframe\", \"layer\", \"legend\", \"object\", \"ol\", \"p\", \"select\", \"table\", \"ul\"];\n\n  function autoCloseGT(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (inner.mode.name != \"xml\" || !state.tagName) return CodeMirror.Pass;\n\n      var opt = cm.getOption(\"autoCloseTags\"), html = inner.mode.configuration == \"html\";\n      var dontCloseTags = (typeof opt == \"object\" && opt.dontCloseTags) || (html && htmlDontClose);\n      var indentTags = (typeof opt == \"object\" && opt.indentTags) || (html && htmlIndent);\n\n      var tagName = state.tagName;\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n      var lowerTagName = tagName.toLowerCase();\n      // Don't process the '>' at the end of an end-tag or self-closing tag\n      if (!tagName ||\n          tok.type == \"string\" && (tok.end != pos.ch || !/[\\\"\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||\n          tok.type == \"tag\" && state.type == \"closeTag\" ||\n          tok.string.indexOf(\"/\") == (tok.string.length - 1) || // match something like <someTagName />\n          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||\n          closingTagExists(cm, tagName, pos, state, true))\n        return CodeMirror.Pass;\n\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n      replacements[i] = {indent: indent,\n                         text: \">\" + (indent ? \"\\n\\n\" : \"\") + \"</\" + tagName + \">\",\n                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};\n    }\n\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var info = replacements[i];\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, \"+insert\");\n      var sel = cm.listSelections().slice(0);\n      sel[i] = {head: info.newPos, anchor: info.newPos};\n      cm.setSelections(sel);\n      if (info.indent) {\n        cm.indentLine(info.newPos.line, null, true);\n        cm.indentLine(info.newPos.line + 1, null, true);\n      }\n    }\n  }\n\n  function autoCloseCurrent(cm, typingSlash) {\n    var ranges = cm.listSelections(), replacements = [];\n    var head = typingSlash ? \"/\" : \"</\";\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (typingSlash && (tok.type == \"string\" || tok.string.charAt(0) != \"<\" ||\n                          tok.start != pos.ch - 1))\n        return CodeMirror.Pass;\n      // Kludge to get around the fact that we are not in XML mode\n      // when completing in JS/CSS snippet in htmlmixed mode. Does not\n      // work for other XML embedded languages (there is no general\n      // way to go from a mixed mode to its current XML state).\n      var replacement;\n      if (inner.mode.name != \"xml\") {\n        if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"javascript\")\n          replacement = head + \"script\";\n        else if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"css\")\n          replacement = head + \"style\";\n        else\n          return CodeMirror.Pass;\n      } else {\n        if (!state.context || !state.context.tagName ||\n            closingTagExists(cm, state.context.tagName, pos, state))\n          return CodeMirror.Pass;\n        replacement = head + state.context.tagName;\n      }\n      if (cm.getLine(pos.line).charAt(tok.end) != \">\") replacement += \">\";\n      replacements[i] = replacement;\n    }\n    cm.replaceSelections(replacements);\n    ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\n        cm.indentLine(ranges[i].head.line);\n  }\n\n  function autoCloseSlash(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    return autoCloseCurrent(cm, true);\n  }\n\n  CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  // If xml-fold is loaded, we use its functionality to try and verify\n  // whether a given tag is actually unclosed.\n  function closingTagExists(cm, tagName, pos, state, newTag) {\n    if (!CodeMirror.scanForClosingTag) return false;\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n    if (!nextClose || nextClose.tag != tagName) return false;\n    var cx = state.context;\n    // If the immediate wrapping context contains onCx instances of\n    // the same tag, a closing tag only exists if there are at least\n    // that many closing tags of that type following.\n    for (var onCx = newTag ? 1 : 0; cx && cx.tagName == tagName; cx = cx.prev) ++onCx;\n    pos = nextClose.to;\n    for (var i = 1; i < onCx; i++) {\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n      if (!next || next.tag != tagName) return false;\n      pos = next.to;\n    }\n    return true;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/edit/closetag.js\n// module id = +/ra\n// module chunks = 4 5","<template>\n  <transition name=\"el-fade-in\">\n    <div class=\"notes\">\n      <el-dialog title=\"保存笔记\" :visible.sync=\"noteDialogVisible\">\n        <el-form ref=\"form\" label-width=\"60px\">\n          <el-form-item label=\"文件名:\">\n            <el-input v-model=\"noteName\"></el-input>\n          </el-form-item>\n          <el-radio-group v-model=\"fileType\">\n            <el-radio label=\"0\">保存至云端</el-radio>\n            <el-radio label=\"1\">以txt格式保存</el-radio>\n            <el-radio label=\"2\">以markdown格式保存</el-radio>\n          </el-radio-group>\n        </el-form>\n        <div slot=\"footer\" class=\"dialog-footer\">\n          <el-button @click=\"noteDialogVisible = false\">取 消</el-button>\n          <el-button type=\"primary\" @click=\"saveNoteConfirm\">保 存</el-button>\n        </div>\n      </el-dialog>\n      <mavon-editor v-model=\"note\" default_open=\"edit\" placeholder=\"记录学习笔记\"  @save=\"_showSaveNoteDialog\">\n      </mavon-editor>\n    </div>\n  </transition>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import axios from 'axios'\n  import { baseUrl, MSG_OK } from 'common/js/data'\n  import { mapGetters } from 'vuex'\n\n  export default{\n    props: {\n      name: String,\n      default: 'CodeNut笔记'\n    },\n    data() {\n      return {\n        note: '',\n        noteDialogVisible: false,\n        fileType: '1',\n        noteName: this.name + '笔记'\n      }\n    },\n    created(){\n      if (this._checkLogin()) {\n        let url = `${baseUrl}/problems/${this.problem.id}/notes`\n        axios.get(url).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.note = response.data.result[0].text\n          }\n        }, response => {})\n      }\n    },\n    methods: {\n      _showSaveNoteDialog() {\n        this.noteDialogVisible = true\n      },\n      saveNoteConfirm() {\n        let FileSaver = require('file-saver')\n        let blob = new Blob([this.note], {type: 'text/plain;charset=utf-8'})\n        if (this.fileType === '1') {\n          // Save as .txt\n          FileSaver.saveAs(blob, this.noteName + '.txt')\n        } else if (this.fileType === '2') {\n          FileSaver.saveAs(blob, this.noteName + '.md')\n        } else if (this.fileType === '0') {\n          if (this.note === '' || this.note === undefined) {\n            this.$notify({\n              title: '警告',\n              type: 'warning',\n              message: '笔记不能为空哦!'\n            })\n          } else {\n            if (this._checkLogin()) {\n              this._saveNote()\n            }\n          }\n        }\n        this.noteDialogVisible = false\n      },\n      _saveNote(){\n        let url = `${baseUrl}/problems/${this.problem.id}/notes`\n        axios.put(url, {\n          text: this.note\n        }).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.$notify({\n              title: '成功',\n              type: 'success',\n              message: '保存笔记成功!'\n            })\n          }\n        }, response => {\n          this._saveNote()\n        })\n      },\n      _checkLogin(){\n        if (this.user.user_id == null) {\n          this.$notify({\n            title: '警告',\n            message: '请先登录！',\n            type: 'warning'\n          })\n          return false\n        } else {\n          return true\n        }\n      }\n    },\n    computed: {\n      ...mapGetters([\n        'problem',\n        'user'\n      ])\n    }\n  }\n</script>\n\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n  .notes\n    margin-top 25px\n    height 590px\n    .v-note-wrapper\n      height 500px\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/notes/notes.vue?bfc954ea","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../scroll/annotatescrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/matchesonscrollbar.js\n// module id = /A6h\n// module chunks = 4 5","<template>\n  <transition name=\"el-fade-in\">\n    <div>\n      <div class=\"description\" v-html=\"data.description\" v-if=\"data.description\">\n      </div>\n      <my-editor></my-editor>\n    </div>\n  </transition>\n</template>\n\n\n<script type=\"text/ecmascript-6\">\n  //  import Editor from 'components/editor/vueeditor'\n  import MyEditor from 'components/description/myeditor'\n\n  export default {\n    props: {\n      data: {\n        type: Object,\n        default: {}\n      }\n    },\n    components: {\n      MyEditor\n    }\n  }\n</script>\n\n<style lang=\"stylus\" scoped rel=\"stylesheet/stylus\">\n  .description\n    border-bottom 1px solid #ddd\n    p\n      margin: 0 0 10px\n      display: block;\n      font-size: 16px;\n      -webkit-margin-before: 1em;\n      -webkit-margin-after: 1em;\n      -webkit-margin-start: 0px;\n      -webkit-margin-end: 0px;\n    pre\n      display: block;\n      padding: 9.5px;\n      margin: 0 0 10px;\n      overflow: auto;\n      font-size: 14px;\n      line-height: 1.9;\n      color: #333;\n      word-break: break-all;\n      word-wrap: break-word;\n      background-color: #F2F2F2;\n      border: 1px solid #ccc;\n      border-radius: 4px;\n      font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace;\n      .nf\n        color: #900;\n        font-weight: bold;\n      .na\n        color: teal;\n      .kt\n        color: #458;\n        font-weight: bold;\n      .o\n        font-weight: bold;\n    code\n      padding: 2px 4px;\n      font-size: 90%;\n      color: #c7254e;\n      background-color: #f9f2f4;\n      border-radius: 4px;\n      font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace;\n    b\n      font-weight: 700;\n    ol\n      margin-top: 10px;\n      li\n        font-size: 16px;\n\n  .editor\n    .ql-editor\n      min-height 300px\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/description/description.vue?0e3fb355","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-062a844c\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./hints.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"0c6bc646\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-062a844c\",\"scoped\":false,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/hints/hints.vue\n// module id = 1LpH\n// module chunks = 4","<template>\n  <div class=\"myeditor\">\n    <div class=\"myeditor-header\">\n      <el-dropdown trigger=\"click\" @command=\"handleCommandLangage\" menu-align=\"start\" class=\"language-dropdown\">\n        <el-button type=\"primary\">{{selectLanguage}}<i class=\"el-icon-caret-bottom el-icon--right\"></i>\n        </el-button>\n        <el-dropdown-menu slot=\"dropdown\">\n          <el-dropdown-item v-for=\"(item , index) in Languages\" :key=\"index\" :command=\"index\">{{item}}\n          </el-dropdown-item>\n        </el-dropdown-menu>\n      </el-dropdown>\n\n      <el-dropdown menu-align=\"start\" trigger=\"click\" class=\"el-dropdown-theme\" @command=\"handleCommandTheme\">\n        <el-button type=\"primary\">\n          {{selectTheme}}<i class=\"el-icon-caret-bottom el-icon--right\"></i>\n        </el-button>\n        <el-dropdown-menu slot=\"dropdown\">\n          <el-dropdown-item v-for=\"(item,index) in editorThemes\" :key=\"index\" :command=\"item\">{{item}}\n          </el-dropdown-item>\n        </el-dropdown-menu>\n      </el-dropdown>\n\n      <el-dropdown menu-align=\"start\" trigger=\"click\" class=\"el-dropdown-keyMap\" @command=\"handleCommandKeyMap\">\n        <el-button type=\"primary\">\n          {{selectkeyMap}}<i class=\"el-icon-caret-bottom el-icon--right\"></i>\n        </el-button>\n        <el-dropdown-menu slot=\"dropdown\">\n          <el-dropdown-item v-for=\"(item,index) in keyMaps\" :key=\"index\" :command=\"item\">{{item}}\n          </el-dropdown-item>\n        </el-dropdown-menu>\n      </el-dropdown>\n    </div>\n    <codemirror ref=\"myEditor\"\n                v-model=\"code\"\n                :options=\"editorOptions\"\n    >\n    </codemirror>\n    <div class=\"myeditor-footer\">\n      <el-button type=\"success\" class=\"custom-button\" @click=\"onClickCustom\">\n        Custom<i class=\"el-icon-upload el-icon--right\"></i>\n      </el-button>\n      <el-button type=\"success\" class=\"submit-button\" @click=\"onClickSubmit\">\n        Submit<i class=\"el-icon-upload el-icon--right\"></i>\n      </el-button>\n      <el-button type=\"primary\" class=\"run-button\" @click=\"onClickRun\">Run\n      </el-button>\n    </div>\n\n    <div class=\"result-wrapper\" v-show=\"result!==[]\"\n         v-for=\"(item, index) in result\" :key=\"index\"\n         v-loading.fullscreen.lock=\"fullscreenLoading\" element-loading-text=\"正在运行中...\">\n      <div class=\"result-type\">\n        <el-tag type=\"success\" v-show=\"item.mytitle === 'SubmitResult'\">{{item.mytitle}}</el-tag>\n        <el-tag type=\"warning\" v-show=\"item.mytitle === 'RunResult'\">{{item.mytitle}}</el-tag>\n      </div>\n      <!--<span class=\"result-item\">-->\n      <!--<span class=\"result-item-text\">程序输出</span> {{item.output}}-->\n      <!--</span>-->\n      <span class=\"result-item\">\n        <span class=\"result-item-text\">耗费内存</span> {{item.memory_used}}\n      </span>\n      <span class=\"result-item\">\n        <span class=\"result-item-text\">耗费时间</span> {{item.time_used}}\n      </span>\n      <span class=\"result-item\">\n        <span class=\"result-item-text\">运行状态\n          <span :class=\"[item.status.includes('Error')?'error':'default']\"> {{item.status}}</span>\n        </span>\n         <img class=\"result-item-img\" src=\"static/target.png\" width=\"32\" height=\"32\"\n              v-show=\"index === (result.length-1)\">\n      </span>\n    </div>\n    <run-result-dialog ref=\"dialog\" :result=\"Runresult\"></run-result-dialog>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  // require active-line.js\n  require('codemirror/addon/selection/active-line.js')\n\n  // closebrackets\n  require('codemirror/addon/edit/closebrackets.js')\n\n  // styleSelectedText\n  require('codemirror/addon/selection/mark-selection.js')\n  require('codemirror/addon/search/searchcursor.js')\n\n  // hint\n  require('codemirror/addon/hint/show-hint.js')\n  require('codemirror/addon/hint/javascript-hint.js')\n  require('codemirror/addon/selection/active-line.js')\n\n  // highlightSelectionMatches\n  require('codemirror/addon/scroll/annotatescrollbar.js')\n  require('codemirror/addon/search/matchesonscrollbar.js')\n  require('codemirror/addon/search/searchcursor.js')\n  require('codemirror/addon/search/match-highlighter.js')\n\n  // keyMap\n  require('codemirror/mode/clike/clike.js')\n  require('codemirror/addon/edit/matchbrackets.js')\n  require('codemirror/addon/comment/comment.js')\n  require('codemirror/addon/dialog/dialog.js')\n  require('codemirror/addon/dialog/dialog.css')\n  require('codemirror/addon/search/searchcursor.js')\n  require('codemirror/addon/search/search.js')\n  require('codemirror/keymap/sublime.js')\n  require('codemirror/keymap/emacs.js')\n  require('codemirror/keymap/vim.js')\n\n  // foldGutter\n  require('codemirror/addon/fold/foldgutter.css')\n  require('codemirror/addon/fold/brace-fold.js')\n  require('codemirror/addon/fold/comment-fold.js')\n  require('codemirror/addon/fold/foldcode.js')\n  require('codemirror/addon/fold/foldgutter.js')\n  require('codemirror/addon/fold/indent-fold.js')\n  require('codemirror/addon/fold/markdown-fold.js')\n  require('codemirror/addon/fold/xml-fold.js')\n\n  // autoCloseTags\n  require('codemirror/addon/edit/closetag.js')\n\n  // 语法高亮，自行替换为你需要的语言\n  import 'codemirror/mode/javascript/javascript'\n  import 'codemirror/mode/go/go'\n  import 'codemirror/mode/python/python'\n  import 'codemirror/mode/ruby/ruby'\n  import 'codemirror/mode/clike/clike'\n\n  // Theme\n  import 'codemirror/theme/ambiance.css'\n  import 'codemirror/theme/base16-dark.css'\n  import 'codemirror/theme/cobalt.css'\n  import 'codemirror/theme/paraiso-light.css'\n  import 'codemirror/theme/paraiso-dark.css'\n  import 'codemirror/theme/rubyblue.css'\n  import 'codemirror/theme/solarized.css'\n  import 'codemirror/theme/mbo.css'\n\n  import { MSG_OK, MSG_NO, baseUrl, editorThemes, keyMaps, editorModes, languages, templateCodes } from 'common/js/data'\n  import axios from 'axios'\n  import { mapGetters } from 'vuex'\n  import ReturnResult from 'common/js/ReturnResult'\n\n  //组件\n  import RunResultDialog from 'components/description/runresultdialog'\n\n  export default {\n    data() {\n      return {\n        code: '',\n        templateCodes: templateCodes,\n        Languages: languages,\n        editorModes: editorModes,\n        selectLanguage: languages[0],\n        editorThemes: editorThemes,\n        selectTheme: editorThemes[0],\n        keyMaps: keyMaps,\n        selectkeyMap: keyMaps[0],\n        editorOptions: {\n          tabSize: 4,\n          mode: 'text/x-csrc',\n          theme: 'default',\n          lineNumbers: true,\n          line: true,\n          keyMap: 'sublime',\n          foldGutter: true,\n          gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n          // 选中文本自动高亮，及高亮方式\n          styleSelectedText: true,\n          highlightSelectionMatches: {showToken: /\\w/, annotateScrollbar: true}\n          // 如果有hint方面的配置，也应该出现在这里\n        },\n        result: [],\n        fullscreenLoading: false,\n        Runresult: {}\n      }\n    },\n    created(){\n      this._getTempletCode(this.selectLanguage)\n    },\n    methods: {\n      handleCommandLangage(command) {\n        // 这里的command 是 index\n        console.log('xuan ' + command)\n        this.editorOptions.mode = this.editorModes[command]\n        this.selectLanguage = this.Languages[command]\n        this._getTempletCode(this.selectLanguage)\n      },\n      _getTempletCode(selectLanguage){\n        let url = `${baseUrl}/problems/${this.problem.id}/codes`\n        axios.get(url).then(response => {\n          let result = JSON.parse(response.data.result[0].code)\n          console.log(result)\n          let templet = result.find((item) => {\n            if (item) {\n              return item.text === selectLanguage\n            }\n          })\n          if (templet && templet.defaultCode) {\n            this.code = templet.defaultCode\n          } else {\n            this.code = ''\n          }\n        }, response => {})\n      },\n      handleCommandKeyMap(command) {\n        this.editorOptions.keyMap = command\n        this.selectkeyMap = command\n        console.log(this.editorOptions)\n      },\n      handleCommandTheme(command) {\n        console.log('click on item ' + command)\n        this.editorOptions.theme = command\n        this.selectTheme = command\n      },\n      onClickSubmit(){\n        if (!this._checkLogin()) {\n          return\n        }\n        let url = `${baseUrl}/problems/${this.problem.id}/codes`\n        axios.post(url, {\n          language: this.selectLanguage,\n          code: this.code\n        }).then(response => {\n          if (response.data.msg === MSG_OK) {\n            console.log(response.data.result[0])\n            this.Runresult = new ReturnResult({\n              mytitle: 'SubmitResult',\n              memory_used: response.data.result[0].memory_used.toFixed(2) + 'kb',\n              output: response.data.result[0].output,\n              status: response.data.result[0].status,\n              time_used: response.data.result[0].time_used.toFixed(2) + 's'\n            })\n            this.result.push(this.Runresult)\n            this._showLoading()\n            this.$refs.dialog.show()\n          } else if (response.data.mag === MSG_NO) {\n            this.$notify.error({\n              title: '错误',\n              message: response.data.error\n            })\n          }\n        }, response => {})\n      },\n      onClickRun(){\n        if (!this._checkLogin()) {\n          return\n        }\n        console.log(this.code)\n        let url = `${baseUrl}/problems/${this.problem.id}/codes`\n        axios.patch(url, {\n          language: this.selectLanguage,\n          code: this.code\n        }).then(response => {\n          if (response.data.msg === MSG_OK) {\n            console.log(response.data.result[0])\n            this.Runresult = new ReturnResult({\n              mytitle: 'RunResult',\n              memory_used: response.data.result[0].memory_used + 'kb',\n              output: response.data.result[0].output,\n              status: response.data.result[0].status,\n              time_used: response.data.result[0].time_used + 's'\n            })\n            this.result.push(this.Runresult)\n            this._showLoading()\n            this.$refs.dialog.show()\n          } else if (response.data.mag === MSG_NO) {\n            this.$notify.error({\n              title: '错误',\n              message: response.data.error\n            })\n          }\n        }, response => {})\n      },\n      onClickCustom(){\n        let url = `${baseUrl}/problems/${this.problem.id}/codes`\n        axios.get(url).then(response => {\n          if (response.data.msg === MSG_OK) {\n            let str = JSON.parse(response.data.result[0].code)\n            console.log(str)\n          }\n        }, response => {})\n      },\n      _checkLogin(){\n        if (this.user.user_id === null || this.user.user_id === undefined || this.user.user_id === '') {\n          this.$notify({\n            title: '警告',\n            message: '请先登录！',\n            type: 'warning'\n          })\n          return false\n        } else {\n          return true\n        }\n      },\n      _showLoading() {\n        this.fullscreenLoading = true\n        setTimeout(() => {\n          this.fullscreenLoading = false\n        }, 1000)\n      }\n    },\n    computed: {\n      ...mapGetters([\n        'problem',\n        'user'\n      ])\n    },\n    components: {\n      RunResultDialog\n    }\n  }\n</script>\n\n<style lang=\"stylus\" scoped rel=\"stylesheet/stylus\">\n  .myeditor\n    margin-top 20px\n    .myeditor-header\n      margin-bottom 12px\n    .language-dropdown\n      .el-dropdown-menu__item\n        padding 0 5px\n    .el-dropdown-theme\n      float right\n    .el-dropdown-keyMap\n      float right\n      margin-right 8px\n    .CodeMirror\n      height 400px\n    .myeditor-footer\n      padding 20px 0 0 0\n      height 100px\n      width 100%\n      .custom-button\n        float left\n        margin-right 10px\n        width 150px\n      .run-button\n        float right\n        margin-right 10px\n        width 150px\n      .submit-button\n        float right\n        width 150px\n    .result-wrapper\n      display flex\n      margin-top -1px\n      padding 10px 0\n      border-bottom 1px solid #ddd\n      border-top 1px solid #ddd\n      .result-type\n        flex 0 1 auto\n        display inline-block\n        .el-tag\n          margin-top 4px\n          font-size: 18px;\n      .result-item\n        flex 1 1 auto\n        text-align center\n        .result-item-text\n          font-size 18px\n          font-weight 600\n          margin 0 5px\n          line-height 30px\n          color: #9E9E9E\n          .error\n            color #ff1744\n          .default\n            color #333\n      .result-item-img\n        vertical-align middle\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/description/myeditor.vue?2a10f70a","<template>\n  <transition name=\"el-fade-in\">\n    <div>\n      <div class=\"solution\" v-if=\"solution\" v-html=\"solution\">\n      </div>\n      <div class=\"nodata\" v-show=\"!solution || solution === {}\">\n        No solution at the moment\n      </div>\n    </div>\n  </transition>\n</template>\n\n\n<script type=\"text/ecmascript-6\">\n  import axios from 'axios'\n  import { baseUrl, MSG_OK } from 'common/js/data'\n  import { mapGetters } from 'vuex'\n\n  export default {\n    data() {\n      return {\n        solution: {}\n      }\n    },\n    mounted() {\n      this._getSolution()\n//      let results = document.getElementsByTagName('a')\n//      for (let i = 0; i < results.length; i++) {\n//        results[i].href = '#'\n//      }\n    },\n    methods: {\n      _getSolution() {\n        console.log(this.id + '1111111111')\n        let url = `${baseUrl}/problems/${this.problem.id}/solutions`\n        axios.get(url).then(response => {\n          if (response.data.msg === MSG_OK) {\n            console.log(response.data.result[0])\n            this.solution = response.data.result[0].solution\n          }\n        }, response => {\n        })\n      }\n    },\n    computed: {\n      ...mapGetters([\n        'problem'\n      ])\n    }\n  }\n</script>\n\n<style lang=\"stylus\" scoped rel=\"stylesheet/stylus\">\n  .solution\n    padding 5px 10px 0 12px\n    background #F2F2F2;\n    line-height: 1.7;\n    .toc\n      display: table;\n      border: 1px solid #aaa;\n      background-color: #f9f9f9;\n      padding: 7px 25px 3px 7px;\n      margin-top: 15px;\n      font-size: 95%;\n      ul\n        margin-top: 0;\n        margin-bottom: 10px;\n        li\n          a\n            pointer-events none\n            color: #08c;\n            text-decoration: none;\n\n  h2\n    font-size: 1.75em;\n    font-weight: 700;\n    margin-top: 1.275em;\n    margin-bottom: .85em;\n    line-height: 1.7;\n\n  h4\n    font-size: 1.25em;\n    font-weight: 700;\n    margin-top: 1.275em;\n    margin-bottom: .85em;\n    line-height: 1.7;\n\n  hr\n    height: 4px;\n    padding: 0;\n    margin: 1.7em 0;\n    overflow: hidden;\n    background-color: #e7e7e7;\n    border: none;\n\n  p\n    margin: 0 0 10px;\n    display: block;\n    -webkit-margin-before: 1em;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0px;\n    -webkit-margin-end: 0px;\n    font-size 16px\n    font-weight: 400;\n\n  code\n    padding: 2px 4px;\n    font-size: 90%;\n    color: #c7254e;\n    background-color: #f9f2f4;\n    border-radius: 4px;\n\n  b, strong\n    font-weight: 700;\n\n  pre\n    display: block;\n    padding: 9.5px;\n    margin: 0 0 10px;\n    overflow: auto;\n    font-size: 14px;\n    line-height: 1.9;\n    color: #333;\n    word-break: break-all;\n    word-wrap: break-word;\n    background-color: #f2f2f2;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace;\n    .nf\n      color: #900;\n      font-weight: bold;\n    .na\n      color: teal;\n    .kt\n      color: #458;\n      font-weight: bold;\n    .o\n      font-weight: bold;\n\n  .nodata\n    height 100%\n    width 100%\n    padding: 8rem 4rem;\n    text-align: center;\n    font-size: 1.5rem;\n    color: #333;\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/solution/solution.vue?3bb0cded","/**\n * Created by qinzhen on 2017/9/17.\n */\nexport default class Problem {\n  constructor ({id, title, tag, level, description, accepted, submitted, like_nums, hate_nums}) {\n    this.id = id\n    this.title = title\n    this.tag = tag\n    this.level = level\n    this.description = description\n    this.accepted = accepted\n    this.submitted = submitted\n    this.like_nums = like_nums\n    this.hate_nums = hate_nums\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/js/problem.js","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"hint-wrapper\"\n  }, [_c('div', {\n    staticClass: \"placeholder-text\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"We do not have any hints for this question at the moment.\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"suggest\"\n  }, [_vm._v(\"Do you have one or more hints?\")])])])\n}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-062a844c\",\"hasScoped\":false,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/hints/hints.vue\n// module id = 6rPU\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  var goSubwordCombo = mac ? \"Ctrl-\" : \"Alt-\";\n\n  cmds[map[goSubwordCombo + \"Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n  cmds[map[goSubwordCombo + \"Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\n  if (mac) map[\"Cmd-Left\"] = \"goLineStartSmart\";\n\n  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\n  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  map[\"Shift-Tab\"] = \"indentLess\";\n\n  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  map[\"Shift-Ctrl-K\"] = \"deleteLine\";\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { return insertLine(cm, false); };\n\n  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))\n        return CodeMirror.Pass\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(range.anchor, dir, \"line\");\n      var newHead = cm.findPosV(range.head, dir, \"line\");\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n\n  var addCursorToLineCombo = mac ? \"Shift-Cmd\" : 'Alt-Ctrl';\n  cmds[map[addCursorToLineCombo + \"Up\"] = \"addCursorToPrevLine\"] = function(cm) { addCursorToSelection(cm, -1); };\n  cmds[map[addCursorToLineCombo + \"Down\"] = \"addCursorToNextLine\"] = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (ranges[i].from() == from && ranges[i].to() == to) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          newRanges.push({anchor: Pos(opening.pos.line, opening.pos.ch + 1),\n                          head: closing.pos});\n          break;\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\n  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[ctrl + \"/\"] = \"toggleCommentIndented\"] = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  if (!mac) map[ctrl + \"T\"] = \"transposeChars\";\n\n  function sortLines(cm, caseSensitive) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\n  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  map[\"Alt-Q\"] = \"wrapLines\";\n\n  var cK = ctrl + \"K \";\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\n  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  var selectLinesCombo = mac ? \"Ctrl-Shift-\" : \"Ctrl-Alt-\";\n  cmds[map[selectLinesCombo + \"Up\"] = \"selectLinesUpward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line > cm.firstLine())\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n      }\n    });\n  };\n  cmds[map[selectLinesCombo + \"Down\"] = \"selectLinesDownward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line < cm.lastLine())\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n      }\n    });\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"J\"] = \"unfoldAll\";\n\n  map[ctrl + \"I\"] = \"findIncremental\";\n  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n  map[ctrl + \"H\"] = \"replace\";\n  map[\"F3\"] = \"findNext\";\n  map[\"Shift-F3\"] = \"findPrev\";\n\n  CodeMirror.normalizeKeyMap(map);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/keymap/sublime.js\n// module id = 7Xsf\n// module chunks = 4 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-4dfc5728\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./description.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./description.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-4dfc5728\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./description.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-4dfc5728\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/description/description.vue\n// module id = 8eAg\n// module chunks = 4","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".hint-wrapper{width:100%;height:100%}.hint-wrapper .placeholder-text{padding:8rem 4rem;text-align:center;font-size:1.5rem;color:#555}.hint-wrapper .placeholder-text .suggest{margin-top:30px;color:gray}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/hints/hints.vue\"],\"names\":[],\"mappings\":\"AACA,cACE,WAAY,AACZ,WAAa,CACd,AACD,gCACE,kBAAmB,AACnB,kBAAmB,AACnB,iBAAkB,AAClB,UAAY,CACb,AACD,yCACE,gBAAiB,AACjB,UAAe,CAChB\",\"file\":\"hints.vue\",\"sourcesContent\":[\"\\n.hint-wrapper {\\n  width: 100%;\\n  height: 100%;\\n}\\n.hint-wrapper .placeholder-text {\\n  padding: 8rem 4rem;\\n  text-align: center;\\n  font-size: 1.5rem;\\n  color: #555;\\n}\\n.hint-wrapper .placeholder-text .suggest {\\n  margin-top: 30px;\\n  color: #808080;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-062a844c\",\"scoped\":false,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/hints/hints.vue\n// module id = 8f5d\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../dialog/dialog\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../dialog/dialog\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function searchOverlay(query, caseInsensitive) {\n    if (typeof query == \"string\")\n      query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\"), caseInsensitive ? \"gi\" : \"g\");\n    else if (!query.global)\n      query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\n\n    return {token: function(stream) {\n      query.lastIndex = stream.pos;\n      var match = query.exec(stream.string);\n      if (match && match.index == stream.pos) {\n        stream.pos += match[0].length || 1;\n        return \"searching\";\n      } else if (match) {\n        stream.pos = match.index;\n      } else {\n        stream.skipToEnd();\n      }\n    }};\n  }\n\n  function SearchState() {\n    this.posFrom = this.posTo = this.lastQuery = this.query = null;\n    this.overlay = null;\n  }\n\n  function getSearchState(cm) {\n    return cm.state.search || (cm.state.search = new SearchState());\n  }\n\n  function queryCaseInsensitive(query) {\n    return typeof query == \"string\" && query == query.toLowerCase();\n  }\n\n  function getSearchCursor(cm, query, pos) {\n    // Heuristic: if the query string is all lowercase, do a case insensitive search.\n    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});\n  }\n\n  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {\n    cm.openDialog(text, onEnter, {\n      value: deflt,\n      selectValueOnOpen: true,\n      closeOnEnter: false,\n      onClose: function() { clearSearch(cm); },\n      onKeyDown: onKeyDown\n    });\n  }\n\n  function dialog(cm, text, shortText, deflt, f) {\n    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});\n    else f(prompt(shortText, deflt));\n  }\n\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n\n  function parseString(string) {\n    return string.replace(/\\\\(.)/g, function(_, ch) {\n      if (ch == \"n\") return \"\\n\"\n      if (ch == \"r\") return \"\\r\"\n      return ch\n    })\n  }\n\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\n    if (isRE) {\n      try { query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\"); }\n      catch(e) {} // Not a regular expression after all, do a string search\n    } else {\n      query = parseString(query)\n    }\n    if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\n      query = /x^/;\n    return query;\n  }\n\n  var queryDialog =\n    '<span class=\"CodeMirror-search-label\">Search:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n\n  function startSearch(cm, state, query) {\n    state.queryText = query;\n    state.query = parseQuery(query);\n    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\n    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\n    cm.addOverlay(state.overlay);\n    if (cm.showMatchesOnScrollbar) {\n      if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\n    }\n  }\n\n  function doSearch(cm, rev, persistent, immediate) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    var q = cm.getSelection() || state.lastQuery;\n    if (persistent && cm.openDialog) {\n      var hiding = null\n      var searchNext = function(query, event) {\n        CodeMirror.e_stop(event);\n        if (!query) return;\n        if (query != state.queryText) {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n        }\n        if (hiding) hiding.style.opacity = 1\n        findNext(cm, event.shiftKey, function(_, to) {\n          var dialog\n          if (to.line < 3 && document.querySelector &&\n              (dialog = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) &&\n              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, \"window\").top)\n            (hiding = dialog).style.opacity = .4\n        })\n      };\n      persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {\n        var keyName = CodeMirror.keyName(event)\n        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName]\n        if (cmd == \"findNext\" || cmd == \"findPrev\" ||\n          cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\n          CodeMirror.e_stop(event);\n          startSearch(cm, getSearchState(cm), query);\n          cm.execCommand(cmd);\n        } else if (cmd == \"find\" || cmd == \"findPersistent\") {\n          CodeMirror.e_stop(event);\n          searchNext(query, event);\n        }\n      });\n      if (immediate && q) {\n        startSearch(cm, state, q);\n        findNext(cm, rev);\n      }\n    } else {\n      dialog(cm, queryDialog, \"Search for:\", q, function(query) {\n        if (query && !state.query) cm.operation(function() {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n          findNext(cm, rev);\n        });\n      });\n    }\n  }\n\n  function findNext(cm, rev, callback) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n    if (callback) callback(cursor.from(), cursor.to())\n  });}\n\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    state.lastQuery = state.query;\n    if (!state.query) return;\n    state.query = state.queryText = null;\n    cm.removeOverlay(state.overlay);\n    if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n  });}\n\n  var replaceQueryDialog =\n    ' <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n  var replacementQueryDialog = '<span class=\"CodeMirror-search-label\">With:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/>';\n  var doReplaceConfirm = '<span class=\"CodeMirror-search-label\">Replace?</span> <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>';\n\n  function replaceAll(cm, query, text) {\n    cm.operation(function() {\n      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {\n        if (typeof query != \"string\") {\n          var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n          cursor.replace(text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n        } else cursor.replace(text);\n      }\n    });\n  }\n\n  function replace(cm, all) {\n    if (cm.getOption(\"readOnly\")) return;\n    var query = cm.getSelection() || getSearchState(cm).lastQuery;\n    var dialogText = '<span class=\"CodeMirror-search-label\">' + (all ? 'Replace all:' : 'Replace:') + '</span>';\n    dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, replacementQueryDialog, \"Replace with:\", \"\", function(text) {\n        text = parseString(text)\n        if (all) {\n          replaceAll(cm, query, text)\n        } else {\n          clearSearch(cm);\n          var cursor = getSearchCursor(cm, query, cm.getCursor(\"from\"));\n          var advance = function() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = getSearchCursor(cm, query);\n              if (!(match = cursor.findNext()) ||\n                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});\n            confirmDialog(cm, doReplaceConfirm, \"Replace?\",\n                          [function() {doReplace(match);}, advance,\n                           function() {replaceAll(cm, query, text)}]);\n          };\n          var doReplace = function(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n            advance();\n          };\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};\n  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};\n  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/search.js\n// module id = CK2l\n// module chunks = 4 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-4dfc5728\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./description.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"79df4bd3\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-4dfc5728\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/description/description.vue\n// module id = CXwt\n// module chunks = 4","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".problem[data-v-4ad8a6d2]{-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}.problem .problem-header .collection[data-v-4ad8a6d2]{float:right;margin-top:5px;vertical-align:bottom}.problem .problem-header h3[data-v-4ad8a6d2]{display:inline-block;margin-bottom:10px;font-weight:500;line-height:1;font-size:24px}.container[data-v-4ad8a6d2]{margin-top:32px}.container .el-tabs__content[data-v-4ad8a6d2]{min-height:800px}.grid-content[data-v-4ad8a6d2]{border-radius:4px;min-height:36px}.bg-purple[data-v-4ad8a6d2]{background:#d3dce6}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/problem-detail/problem-detail.vue\"],\"names\":[],\"mappings\":\"AACA,0BACE,mBAAoB,AAChB,kBAAmB,AACf,aAAe,CACxB,AACD,sDACE,YAAa,AACb,eAAgB,AAChB,qBAAuB,CACxB,AACD,6CACE,qBAAsB,AACtB,mBAAoB,AACpB,gBAAiB,AACjB,cAAe,AACf,cAAgB,CACjB,AACD,4BACE,eAAiB,CAClB,AACD,8CACE,gBAAkB,CACnB,AACD,+BACE,kBAAmB,AACnB,eAAiB,CAClB,AACD,4BACE,kBAAoB,CACrB\",\"file\":\"problem-detail.vue\",\"sourcesContent\":[\"\\n.problem[data-v-4ad8a6d2] {\\n  -webkit-box-flex: 1;\\n      -ms-flex: 1 0 auto;\\n          flex: 1 0 auto;\\n}\\n.problem .problem-header .collection[data-v-4ad8a6d2] {\\n  float: right;\\n  margin-top: 5px;\\n  vertical-align: bottom;\\n}\\n.problem .problem-header h3[data-v-4ad8a6d2] {\\n  display: inline-block;\\n  margin-bottom: 10px;\\n  font-weight: 500;\\n  line-height: 1;\\n  font-size: 24px;\\n}\\n.container[data-v-4ad8a6d2] {\\n  margin-top: 32px;\\n}\\n.container .el-tabs__content[data-v-4ad8a6d2] {\\n  min-height: 800px;\\n}\\n.grid-content[data-v-4ad8a6d2] {\\n  border-radius: 4px;\\n  min-height: 36px;\\n}\\n.bg-purple[data-v-4ad8a6d2] {\\n  background: #d3dce6;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-4ad8a6d2\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/problem-detail/problem-detail.vue\n// module id = FVxK\n// module chunks = 4","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-4ad8a6d2\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./problem-detail.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"b2eb1a16\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-4ad8a6d2\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/problem-detail/problem-detail.vue\n// module id = Fvbh\n// module chunks = 4","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-d7772fc0\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./runresultdialog.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./runresultdialog.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-d7772fc0\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./runresultdialog.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-d7772fc0\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/description/runresultdialog.vue\n// module id = Hid1\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; };\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '['};\n        var selfPaired = {'\\'': true, '\"': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /-?\\d+/g;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        var token;\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0];\n          start = match.index;\n          end = start + token.length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1;\n          var number = parseInt(token) + (increment * actionArgs.repeat);\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          numberStr = number.toString();\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /**\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      var slashes = findUnescapedSlashes(argString) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSlashes(str) {\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySlash(argString) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); };\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n             i++;\n          } else {\n             i+= selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      };\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n            } else {\n                lastChange.changes.push(text);\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    };\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/keymap/vim.js\n// module id = Hyg2\n// module chunks = 4 5","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".dialog-container .explanation[data-v-d7772fc0]{font-size:18px;font-weight:500;color:#222;margin-bottom:10px}.dialog-container .text[data-v-d7772fc0]{font-size:14px;text-align:justify}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/description/runresultdialog.vue\"],\"names\":[],\"mappings\":\"AACA,gDACE,eAAgB,AAChB,gBAAiB,AACjB,WAAY,AACZ,kBAAoB,CACrB,AACD,yCACE,eAAgB,AAChB,kBAAoB,CACrB\",\"file\":\"runresultdialog.vue\",\"sourcesContent\":[\"\\n.dialog-container .explanation[data-v-d7772fc0] {\\n  font-size: 18px;\\n  font-weight: 500;\\n  color: #222;\\n  margin-bottom: 10px;\\n}\\n.dialog-container .text[data-v-d7772fc0] {\\n  font-size: 14px;\\n  text-align: justify;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-d7772fc0\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/description/runresultdialog.vue\n// module id = Iula\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/foldgutter.js\n// module id = Kk9m\n// module chunks = 4 5","module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-define.js\n// module id = LGuY\n// module chunks = 4","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/index.js??ref--6-2!./dialog.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../vue-style-loader/lib/addStylesClient.js\")(\"e2c66042\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/dialog/dialog.css\n// module id = LxZp\n// module chunks = 4 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-4ad8a6d2\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./problem-detail.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./problem-detail.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-4ad8a6d2\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./problem-detail.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-4ad8a6d2\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/problem-detail/problem-detail.vue\n// module id = McHp\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch continue debugger default delete do else false finally for function \" +\n                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/hint/javascript-hint.js\n// module id = Mixr\n// module chunks = 4 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-6701a6dc\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./solution.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"60b01bed\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-6701a6dc\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/solution/solution.vue\n// module id = OEy6\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./matchesonscrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query + \"\\\\b\") : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/match-highlighter.js\n// module id = OkRY\n// module chunks = 4 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-6701a6dc\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./solution.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./solution.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-6701a6dc\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./solution.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-6701a6dc\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/solution/solution.vue\n// module id = P830\n// module chunks = 4","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in-linear\"\n    }\n  }, [_c('div', {\n    staticClass: \"problem\"\n  }, [_c('el-row', [_c('el-col', {\n    attrs: {\n      \"sm\": 0,\n      \"lg\": 2,\n      \"md\": 1,\n      \"xs\": 0\n    }\n  }, [_c('div', {\n    staticClass: \"grid-content\"\n  })]), _vm._v(\" \"), _c('el-col', {\n    attrs: {\n      \"sm\": 24,\n      \"lg\": 20,\n      \"md\": 22,\n      \"xs\": 24\n    }\n  }, [_c('div', {\n    staticClass: \"problem-header\"\n  }, [_c('h3', {\n    attrs: {\n      \"align\": \"left\"\n    }\n  }, [_vm._v(_vm._s(_vm.problemDetail.title))]), _vm._v(\" \"), _c('img', {\n    staticClass: \"collection\",\n    attrs: {\n      \"width\": \"56\",\n      \"height\": \"56\",\n      \"src\": _vm.getFavoriteSrc(_vm.problemDetail)\n    },\n    on: {\n      \"click\": _vm.collection\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"container\"\n  }, [_c('el-tabs', {\n    attrs: {\n      \"type\": \"card\"\n    },\n    model: {\n      value: (_vm.tab),\n      callback: function($$v) {\n        _vm.tab = $$v\n      },\n      expression: \"tab\"\n    }\n  }, [_c('el-tab-pane', {\n    attrs: {\n      \"label\": \"题目描述\",\n      \"name\": \"description\"\n    }\n  }, [_c('description', {\n    attrs: {\n      \"data\": _vm.problemDetail\n    }\n  })], 1), _vm._v(\" \"), _c('el-tab-pane', {\n    attrs: {\n      \"label\": \"解决方案\",\n      \"name\": \"solution\"\n    }\n  }, [_c('solution')], 1), _vm._v(\" \"), _c('el-tab-pane', {\n    attrs: {\n      \"label\": \"提示\",\n      \"name\": \"third\"\n    }\n  }, [_c('hints')], 1), _vm._v(\" \"), _c('el-tab-pane', {\n    attrs: {\n      \"label\": \"笔记\",\n      \"name\": \"fourth\"\n    }\n  }, [_c('notes', {\n    attrs: {\n      \"name\": _vm.problem.title\n    }\n  })], 1)], 1)], 1)]), _vm._v(\" \"), _c('el-col', {\n    attrs: {\n      \"sm\": 0,\n      \"lg\": 2,\n      \"md\": 1,\n      \"xs\": 0\n    }\n  }, [_c('div', {\n    staticClass: \"grid-content\"\n  })])], 1)], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-4ad8a6d2\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/problem-detail/problem-detail.vue\n// module id = PdbZ\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"annotateScrollbar\", function(options) {\n    if (typeof options == \"string\") options = {className: options};\n    return new Annotation(this, options);\n  });\n\n  CodeMirror.defineOption(\"scrollButtonHeight\", 0);\n\n  function Annotation(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.buttonHeight = options.scrollButtonHeight || cm.getOption(\"scrollButtonHeight\");\n    this.annotations = [];\n    this.doRedraw = this.doUpdate = null;\n    this.div = cm.getWrapperElement().appendChild(document.createElement(\"div\"));\n    this.div.style.cssText = \"position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none\";\n    this.computeScale();\n\n    function scheduleRedraw(delay) {\n      clearTimeout(self.doRedraw);\n      self.doRedraw = setTimeout(function() { self.redraw(); }, delay);\n    }\n\n    var self = this;\n    cm.on(\"refresh\", this.resizeHandler = function() {\n      clearTimeout(self.doUpdate);\n      self.doUpdate = setTimeout(function() {\n        if (self.computeScale()) scheduleRedraw(20);\n      }, 100);\n    });\n    cm.on(\"markerAdded\", this.resizeHandler);\n    cm.on(\"markerCleared\", this.resizeHandler);\n    if (options.listenForChanges !== false)\n      cm.on(\"change\", this.changeHandler = function() {\n        scheduleRedraw(250);\n      });\n  }\n\n  Annotation.prototype.computeScale = function() {\n    var cm = this.cm;\n    var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) /\n      cm.getScrollerElement().scrollHeight\n    if (hScale != this.hScale) {\n      this.hScale = hScale;\n      return true;\n    }\n  };\n\n  Annotation.prototype.update = function(annotations) {\n    this.annotations = annotations;\n    this.redraw();\n  };\n\n  Annotation.prototype.redraw = function(compute) {\n    if (compute !== false) this.computeScale();\n    var cm = this.cm, hScale = this.hScale;\n\n    var frag = document.createDocumentFragment(), anns = this.annotations;\n\n    var wrapping = cm.getOption(\"lineWrapping\");\n    var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;\n    var curLine = null, curLineObj = null;\n    function getY(pos, top) {\n      if (curLine != pos.line) {\n        curLine = pos.line;\n        curLineObj = cm.getLineHandle(curLine);\n      }\n      if ((curLineObj.widgets && curLineObj.widgets.length) ||\n          (wrapping && curLineObj.height > singleLineH))\n        return cm.charCoords(pos, \"local\")[top ? \"top\" : \"bottom\"];\n      var topY = cm.heightAtLine(curLineObj, \"local\");\n      return topY + (top ? 0 : curLineObj.height);\n    }\n\n    var lastLine = cm.lastLine()\n    if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {\n      var ann = anns[i];\n      if (ann.to.line > lastLine) continue;\n      var top = nextTop || getY(ann.from, true) * hScale;\n      var bottom = getY(ann.to, false) * hScale;\n      while (i < anns.length - 1) {\n        if (anns[i + 1].to.line > lastLine) break;\n        nextTop = getY(anns[i + 1].from, true) * hScale;\n        if (nextTop > bottom + .9) break;\n        ann = anns[++i];\n        bottom = getY(ann.to, false) * hScale;\n      }\n      if (bottom == top) continue;\n      var height = Math.max(bottom - top, 3);\n\n      var elt = frag.appendChild(document.createElement(\"div\"));\n      elt.style.cssText = \"position: absolute; right: 0px; width: \" + Math.max(cm.display.barWidth - 1, 2) + \"px; top: \"\n        + (top + this.buttonHeight) + \"px; height: \" + height + \"px\";\n      elt.className = this.options.className;\n      if (ann.id) {\n        elt.setAttribute(\"annotation-id\", ann.id);\n      }\n    }\n    this.div.textContent = \"\";\n    this.div.appendChild(frag);\n  };\n\n  Annotation.prototype.clear = function() {\n    this.cm.off(\"refresh\", this.resizeHandler);\n    this.cm.off(\"markerAdded\", this.resizeHandler);\n    this.cm.off(\"markerCleared\", this.resizeHandler);\n    if (this.changeHandler) this.cm.off(\"change\", this.changeHandler);\n    this.div.parentNode.removeChild(this.div);\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/scroll/annotatescrollbar.js\n// module id = QSKu\n// module chunks = 4 5","<template>\n  <div>\n    <el-dialog\n      title=\"运行结果\"\n      :visible.sync=\"dialogVisible\">\n      <span slot=\"title\"> {{result.status}}</span>\n      <div class=\"dialog-container\">\n        <div class=\"explanation\" v-text=\"getExplanation(result.status)\"></div>\n        <div class=\"text\" v-html=\"result.output\">{{}}</div>\n      </div>\n      <span slot=\"footer\" class=\"dialog-footer\">\n         <el-button @click=\"dialogVisible = false\">取 消</el-button>\n         <el-button type=\"primary\" @click=\"dialogVisible = false\">确 定</el-button>\n      </span>\n    </el-dialog>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import { results } from 'common/js/data'\n\n  export default{\n    props: {\n      result: {\n        type: Object\n\n      }\n    },\n    data(){\n      return {\n        dialogVisible: false,\n        results: results\n      }\n    },\n    methods: {\n      show(){\n        this.dialogVisible = true\n      },\n      hide(){\n        this.dialogVisible = false\n      },\n      getExplanation(status){\n        let res = this.results.find((item) => {\n          return item.name === status\n        })\n        return res.value\n      }\n    }\n  }\n</script>\n\n<style lang=\"stylus\" scoped rel=\"stylesheet/stylus\">\n  .dialog-container\n    .explanation\n      font-size 18px\n      font-weight 500\n      color #222\n      margin-bottom 10px\n    .text\n      font-size 14px\n      text-align justify\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/description/runresultdialog.vue?7510837e","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-58438f59\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./myeditor.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./myeditor.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-58438f59\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./myeditor.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-58438f59\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/description/myeditor.vue\n// module id = RKlR\n// module chunks = 4","exports = module.exports = require(\"../../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror-dialog{position:absolute;left:0;right:0;background:inherit;z-index:15;padding:.1em .8em;overflow:hidden;color:inherit}.CodeMirror-dialog-top{border-bottom:1px solid #eee;top:0}.CodeMirror-dialog-bottom{border-top:1px solid #eee;bottom:0}.CodeMirror-dialog input{border:none;outline:none;background:transparent;width:20em;color:inherit;font-family:monospace}.CodeMirror-dialog button{font-size:70%}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/dialog/dialog.css\"],\"names\":[],\"mappings\":\"AAAA,mBACE,kBAAmB,AACnB,OAAQ,AAAC,QAAS,AAClB,mBAAoB,AACpB,WAAY,AACZ,kBAAmB,AACnB,gBAAiB,AACjB,aAAe,CAChB,AAED,uBACE,6BAA8B,AAC9B,KAAO,CACR,AAED,0BACE,0BAA2B,AAC3B,QAAU,CACX,AAED,yBACE,YAAa,AACb,aAAc,AACd,uBAAwB,AACxB,WAAY,AACZ,cAAe,AACf,qBAAuB,CACxB,AAED,0BACE,aAAe,CAChB\",\"file\":\"dialog.css\",\"sourcesContent\":[\".CodeMirror-dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n\\n.CodeMirror-dialog-top {\\n  border-bottom: 1px solid #eee;\\n  top: 0;\\n}\\n\\n.CodeMirror-dialog-bottom {\\n  border-top: 1px solid #eee;\\n  bottom: 0;\\n}\\n\\n.CodeMirror-dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\\n\\n.CodeMirror-dialog button {\\n  font-size: 70%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/codemirror/addon/dialog/dialog.css\n// module id = RkAk\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/dialog/dialog.js\n// module id = RkhK\n// module chunks = 4 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in\"\n    }\n  }, [_c('div', {\n    staticClass: \"notes\"\n  }, [_c('el-dialog', {\n    attrs: {\n      \"title\": \"保存笔记\",\n      \"visible\": _vm.noteDialogVisible\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.noteDialogVisible = $event\n      }\n    }\n  }, [_c('el-form', {\n    ref: \"form\",\n    attrs: {\n      \"label-width\": \"60px\"\n    }\n  }, [_c('el-form-item', {\n    attrs: {\n      \"label\": \"文件名:\"\n    }\n  }, [_c('el-input', {\n    model: {\n      value: (_vm.noteName),\n      callback: function($$v) {\n        _vm.noteName = $$v\n      },\n      expression: \"noteName\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-radio-group', {\n    model: {\n      value: (_vm.fileType),\n      callback: function($$v) {\n        _vm.fileType = $$v\n      },\n      expression: \"fileType\"\n    }\n  }, [_c('el-radio', {\n    attrs: {\n      \"label\": \"0\"\n    }\n  }, [_vm._v(\"保存至云端\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": \"1\"\n    }\n  }, [_vm._v(\"以txt格式保存\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": \"2\"\n    }\n  }, [_vm._v(\"以markdown格式保存\")])], 1)], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"dialog-footer\",\n    slot: \"footer\"\n  }, [_c('el-button', {\n    on: {\n      \"click\": function($event) {\n        _vm.noteDialogVisible = false\n      }\n    }\n  }, [_vm._v(\"取 消\")]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.saveNoteConfirm\n    }\n  }, [_vm._v(\"保 存\")])], 1)], 1), _vm._v(\" \"), _c('mavon-editor', {\n    attrs: {\n      \"default_open\": \"edit\",\n      \"placeholder\": \"记录学习笔记\"\n    },\n    on: {\n      \"save\": _vm._showSaveNoteDialog\n    },\n    model: {\n      value: (_vm.note),\n      callback: function($$v) {\n        _vm.note = $$v\n      },\n      expression: \"note\"\n    }\n  })], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-c64ce914\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/notes/notes.vue\n// module id = SVHh\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/foldcode.js\n// module id = THjC\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter), end;\n      if (!openTag || iter.line != start.line || !(end = toTagEnd(iter))) return;\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && {from: startPos, to: endPos.from};\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/xml-fold.js\n// module id = TQy8\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction lineIndent(cm, lineNo) {\n  var text = cm.getLine(lineNo)\n  var spaceTo = text.search(/\\S/)\n  if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))\n    return -1\n  return CodeMirror.countColumn(text, null, cm.getOption(\"tabSize\"))\n}\n\nCodeMirror.registerHelper(\"fold\", \"indent\", function(cm, start) {\n  var myIndent = lineIndent(cm, start.line)\n  if (myIndent < 0) return\n  var lastLineInFold = null\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    var indent = lineIndent(cm, i)\n    if (indent == -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) return {\n    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n  };\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/indent-fold.js\n// module id = U3HU\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    if (cm.state.markedSelection)\n      cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/selection/mark-selection.js\n// module id = U80t\n// module chunks = 4 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"myeditor\"\n  }, [_c('div', {\n    staticClass: \"myeditor-header\"\n  }, [_c('el-dropdown', {\n    staticClass: \"language-dropdown\",\n    attrs: {\n      \"trigger\": \"click\",\n      \"menu-align\": \"start\"\n    },\n    on: {\n      \"command\": _vm.handleCommandLangage\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    }\n  }, [_vm._v(_vm._s(_vm.selectLanguage)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.Languages), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": index\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n        \")])\n  }))], 1), _vm._v(\" \"), _c('el-dropdown', {\n    staticClass: \"el-dropdown-theme\",\n    attrs: {\n      \"menu-align\": \"start\",\n      \"trigger\": \"click\"\n    },\n    on: {\n      \"command\": _vm.handleCommandTheme\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    }\n  }, [_vm._v(\"\\n        \" + _vm._s(_vm.selectTheme)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.editorThemes), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": item\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n        \")])\n  }))], 1), _vm._v(\" \"), _c('el-dropdown', {\n    staticClass: \"el-dropdown-keyMap\",\n    attrs: {\n      \"menu-align\": \"start\",\n      \"trigger\": \"click\"\n    },\n    on: {\n      \"command\": _vm.handleCommandKeyMap\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    }\n  }, [_vm._v(\"\\n        \" + _vm._s(_vm.selectkeyMap)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.keyMaps), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": item\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n        \")])\n  }))], 1)], 1), _vm._v(\" \"), _c('codemirror', {\n    ref: \"myEditor\",\n    attrs: {\n      \"options\": _vm.editorOptions\n    },\n    model: {\n      value: (_vm.code),\n      callback: function($$v) {\n        _vm.code = $$v\n      },\n      expression: \"code\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"myeditor-footer\"\n  }, [_c('el-button', {\n    staticClass: \"custom-button\",\n    attrs: {\n      \"type\": \"success\"\n    },\n    on: {\n      \"click\": _vm.onClickCustom\n    }\n  }, [_vm._v(\"\\n      Custom\"), _c('i', {\n    staticClass: \"el-icon-upload el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"submit-button\",\n    attrs: {\n      \"type\": \"success\"\n    },\n    on: {\n      \"click\": _vm.onClickSubmit\n    }\n  }, [_vm._v(\"\\n      Submit\"), _c('i', {\n    staticClass: \"el-icon-upload el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"run-button\",\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.onClickRun\n    }\n  }, [_vm._v(\"Run\\n    \")])], 1), _vm._v(\" \"), _vm._l((_vm.result), function(item, index) {\n    return _c('div', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (_vm.result !== []),\n        expression: \"result!==[]\"\n      }, {\n        name: \"loading\",\n        rawName: \"v-loading.fullscreen.lock\",\n        value: (_vm.fullscreenLoading),\n        expression: \"fullscreenLoading\",\n        modifiers: {\n          \"fullscreen\": true,\n          \"lock\": true\n        }\n      }],\n      key: index,\n      staticClass: \"result-wrapper\",\n      attrs: {\n        \"element-loading-text\": \"正在运行中...\"\n      }\n    }, [_c('div', {\n      staticClass: \"result-type\"\n    }, [_c('el-tag', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (item.mytitle === 'SubmitResult'),\n        expression: \"item.mytitle === 'SubmitResult'\"\n      }],\n      attrs: {\n        \"type\": \"success\"\n      }\n    }, [_vm._v(_vm._s(item.mytitle))]), _vm._v(\" \"), _c('el-tag', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (item.mytitle === 'RunResult'),\n        expression: \"item.mytitle === 'RunResult'\"\n      }],\n      attrs: {\n        \"type\": \"warning\"\n      }\n    }, [_vm._v(_vm._s(item.mytitle))])], 1), _vm._v(\" \"), _c('span', {\n      staticClass: \"result-item\"\n    }, [_c('span', {\n      staticClass: \"result-item-text\"\n    }, [_vm._v(\"耗费内存\")]), _vm._v(\" \" + _vm._s(item.memory_used) + \"\\n    \")]), _vm._v(\" \"), _c('span', {\n      staticClass: \"result-item\"\n    }, [_c('span', {\n      staticClass: \"result-item-text\"\n    }, [_vm._v(\"耗费时间\")]), _vm._v(\" \" + _vm._s(item.time_used) + \"\\n    \")]), _vm._v(\" \"), _c('span', {\n      staticClass: \"result-item\"\n    }, [_c('span', {\n      staticClass: \"result-item-text\"\n    }, [_vm._v(\"运行状态\\n        \"), _c('span', {\n      class: [item.status.includes('Error') ? 'error' : 'default']\n    }, [_vm._v(\" \" + _vm._s(item.status))])]), _vm._v(\" \"), _c('img', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (index === (_vm.result.length - 1)),\n        expression: \"index === (result.length-1)\"\n      }],\n      staticClass: \"result-item-img\",\n      attrs: {\n        \"src\": \"static/target.png\",\n        \"width\": \"32\",\n        \"height\": \"32\"\n      }\n    })])])\n  }), _vm._v(\" \"), _c('run-result-dialog', {\n    ref: \"dialog\",\n    attrs: {\n      \"result\": _vm.Runresult\n    }\n  })], 2)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-58438f59\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/description/myeditor.vue\n// module id = WD2d\n// module chunks = 4","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".solution[data-v-6701a6dc]{padding:5px 10px 0 12px;background:#f2f2f2;line-height:1.7}.solution .toc[data-v-6701a6dc]{display:table;border:1px solid #aaa;background-color:#f9f9f9;padding:7px 25px 3px 7px;margin-top:15px;font-size:95%}.solution .toc ul[data-v-6701a6dc]{margin-top:0;margin-bottom:10px}.solution .toc ul li a[data-v-6701a6dc]{pointer-events:none;color:#08c;text-decoration:none}h2[data-v-6701a6dc]{font-size:1.75em}h2[data-v-6701a6dc],h4[data-v-6701a6dc]{font-weight:700;margin-top:1.275em;margin-bottom:.85em;line-height:1.7}h4[data-v-6701a6dc]{font-size:1.25em}hr[data-v-6701a6dc]{height:4px;padding:0;margin:1.7em 0;overflow:hidden;background-color:#e7e7e7;border:none}p[data-v-6701a6dc]{margin:0 0 10px;display:block;-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0;font-size:16px;font-weight:400}code[data-v-6701a6dc]{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}b[data-v-6701a6dc],strong[data-v-6701a6dc]{font-weight:700}pre[data-v-6701a6dc]{display:block;padding:9.5px;margin:0 0 10px;overflow:auto;font-size:14px;line-height:1.9;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f2f2f2;border:1px solid #ccc;border-radius:4px;font-family:Menlo,Monaco,Consolas,Courier New,monospace}pre .nf[data-v-6701a6dc]{color:#900;font-weight:700}pre .na[data-v-6701a6dc]{color:teal}pre .kt[data-v-6701a6dc]{color:#458;font-weight:700}pre .o[data-v-6701a6dc]{font-weight:700}.nodata[data-v-6701a6dc]{height:100%;width:100%;padding:8rem 4rem;text-align:center;font-size:1.5rem;color:#333}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/solution/solution.vue\"],\"names\":[],\"mappings\":\"AACA,2BACE,wBAAyB,AACzB,mBAAoB,AACpB,eAAiB,CAClB,AACD,gCACE,cAAe,AACf,sBAAuB,AACvB,yBAA0B,AAC1B,yBAA0B,AAC1B,gBAAiB,AACjB,aAAe,CAChB,AACD,mCACE,aAAc,AACd,kBAAoB,CACrB,AACD,wCACE,oBAAqB,AACrB,WAAY,AACZ,oBAAsB,CACvB,AACD,oBACE,gBAAkB,CAKnB,AACD,wCALE,gBAAiB,AACjB,mBAAoB,AACpB,oBAAsB,AACtB,eAAiB,CAQlB,AAND,oBACE,gBAAkB,CAKnB,AACD,oBACE,WAAY,AACZ,UAAW,AACX,eAAgB,AAChB,gBAAiB,AACjB,yBAA0B,AAC1B,WAAa,CACd,AACD,mBACE,gBAAiB,AACjB,cAAe,AACf,0BAA2B,AAC3B,yBAA0B,AAC1B,uBAA0B,AAC1B,qBAAwB,AACxB,eAAgB,AAChB,eAAiB,CAClB,AACD,sBACE,gBAAiB,AACjB,cAAe,AACf,cAAe,AACf,yBAA0B,AAC1B,iBAAmB,CACpB,AACD,2CAEE,eAAiB,CAClB,AACD,qBACE,cAAe,AACf,cAAe,AACf,gBAAiB,AACjB,cAAe,AACf,eAAgB,AAChB,gBAAiB,AACjB,WAAY,AACZ,qBAAsB,AACtB,qBAAsB,AACtB,yBAA0B,AAC1B,sBAAuB,AACvB,kBAAmB,AACnB,uDAA+D,CAChE,AACD,yBACE,WAAY,AACZ,eAAkB,CACnB,AACD,yBACE,UAAe,CAChB,AACD,yBACE,WAAY,AACZ,eAAkB,CACnB,AACD,wBACE,eAAkB,CACnB,AACD,yBACE,YAAa,AACb,WAAY,AACZ,kBAAmB,AACnB,kBAAmB,AACnB,iBAAkB,AAClB,UAAY,CACb\",\"file\":\"solution.vue\",\"sourcesContent\":[\"\\n.solution[data-v-6701a6dc] {\\n  padding: 5px 10px 0 12px;\\n  background: #f2f2f2;\\n  line-height: 1.7;\\n}\\n.solution .toc[data-v-6701a6dc] {\\n  display: table;\\n  border: 1px solid #aaa;\\n  background-color: #f9f9f9;\\n  padding: 7px 25px 3px 7px;\\n  margin-top: 15px;\\n  font-size: 95%;\\n}\\n.solution .toc ul[data-v-6701a6dc] {\\n  margin-top: 0;\\n  margin-bottom: 10px;\\n}\\n.solution .toc ul li a[data-v-6701a6dc] {\\n  pointer-events: none;\\n  color: #08c;\\n  text-decoration: none;\\n}\\nh2[data-v-6701a6dc] {\\n  font-size: 1.75em;\\n  font-weight: 700;\\n  margin-top: 1.275em;\\n  margin-bottom: 0.85em;\\n  line-height: 1.7;\\n}\\nh4[data-v-6701a6dc] {\\n  font-size: 1.25em;\\n  font-weight: 700;\\n  margin-top: 1.275em;\\n  margin-bottom: 0.85em;\\n  line-height: 1.7;\\n}\\nhr[data-v-6701a6dc] {\\n  height: 4px;\\n  padding: 0;\\n  margin: 1.7em 0;\\n  overflow: hidden;\\n  background-color: #e7e7e7;\\n  border: none;\\n}\\np[data-v-6701a6dc] {\\n  margin: 0 0 10px;\\n  display: block;\\n  -webkit-margin-before: 1em;\\n  -webkit-margin-after: 1em;\\n  -webkit-margin-start: 0px;\\n  -webkit-margin-end: 0px;\\n  font-size: 16px;\\n  font-weight: 400;\\n}\\ncode[data-v-6701a6dc] {\\n  padding: 2px 4px;\\n  font-size: 90%;\\n  color: #c7254e;\\n  background-color: #f9f2f4;\\n  border-radius: 4px;\\n}\\nb[data-v-6701a6dc],\\nstrong[data-v-6701a6dc] {\\n  font-weight: 700;\\n}\\npre[data-v-6701a6dc] {\\n  display: block;\\n  padding: 9.5px;\\n  margin: 0 0 10px;\\n  overflow: auto;\\n  font-size: 14px;\\n  line-height: 1.9;\\n  color: #333;\\n  word-break: break-all;\\n  word-wrap: break-word;\\n  background-color: #f2f2f2;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\npre .nf[data-v-6701a6dc] {\\n  color: #900;\\n  font-weight: bold;\\n}\\npre .na[data-v-6701a6dc] {\\n  color: #008080;\\n}\\npre .kt[data-v-6701a6dc] {\\n  color: #458;\\n  font-weight: bold;\\n}\\npre .o[data-v-6701a6dc] {\\n  font-weight: bold;\\n}\\n.nodata[data-v-6701a6dc] {\\n  height: 100%;\\n  width: 100%;\\n  padding: 8rem 4rem;\\n  text-align: center;\\n  font-size: 1.5rem;\\n  color: #333;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-6701a6dc\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/solution/solution.vue\n// module id = XgT+\n// module chunks = 4","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-58438f59\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myeditor.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"10d8bb4b\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-58438f59\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/description/myeditor.vue\n// module id = Xh4M\n// module chunks = 4","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/index.js??ref--6-2!./foldgutter.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../vue-style-loader/lib/addStylesClient.js\")(\"da13b76a\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/foldgutter.css\n// module id = Yokd\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  // Rough heuristic to try and detect lines that are part of multi-line string\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode()\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\n    if (open == -1) return false\n    var endLine = end == start ? startLine : self.getLine(end)\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    if (close == -1 && start != end) {\n      endLine = self.getLine(--end);\n      close = endLine.indexOf(endString);\n    }\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\n    if (close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/comment/comment.js\n// module id = Z6qg\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var WRAP_CLASS = \"CodeMirror-activeline\";\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\n  var GUTT_CLASS = \"CodeMirror-activeline-gutter\";\n\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n    var prev = old == CodeMirror.Init ? false : old;\n    if (val == prev) return\n    if (prev) {\n      cm.off(\"beforeSelectionChange\", selectionChange);\n      clearActiveLines(cm);\n      delete cm.state.activeLines;\n    }\n    if (val) {\n      cm.state.activeLines = [];\n      updateActiveLines(cm, cm.listSelections());\n      cm.on(\"beforeSelectionChange\", selectionChange);\n    }\n  });\n\n  function clearActiveLines(cm) {\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\n      cm.removeLineClass(cm.state.activeLines[i], \"wrap\", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"background\", BACK_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"gutter\", GUTT_CLASS);\n    }\n  }\n\n  function sameArray(a, b) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++)\n      if (a[i] != b[i]) return false;\n    return true;\n  }\n\n  function updateActiveLines(cm, ranges) {\n    var active = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var option = cm.getOption(\"styleActiveLine\");\n      if (typeof option == \"object\" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n        continue\n      var line = cm.getLineHandleVisualStart(range.head.line);\n      if (active[active.length - 1] != line) active.push(line);\n    }\n    if (sameArray(cm.state.activeLines, active)) return;\n    cm.operation(function() {\n      clearActiveLines(cm);\n      for (var i = 0; i < active.length; i++) {\n        cm.addLineClass(active[i], \"wrap\", WRAP_CLASS);\n        cm.addLineClass(active[i], \"background\", BACK_CLASS);\n        cm.addLineClass(active[i], \"gutter\", GUTT_CLASS);\n      }\n      cm.state.activeLines = active;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLines(cm, sel.ranges);\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/selection/active-line.js\n// module id = aGTD\n// module chunks = 4 5","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".notes[data-v-c64ce914]{margin-top:25px;height:590px}.notes .v-note-wrapper[data-v-c64ce914]{height:500px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/notes/notes.vue\"],\"names\":[],\"mappings\":\"AACA,wBACE,gBAAiB,AACjB,YAAc,CACf,AACD,wCACE,YAAc,CACf\",\"file\":\"notes.vue\",\"sourcesContent\":[\"\\n.notes[data-v-c64ce914] {\\n  margin-top: 25px;\\n  height: 590px;\\n}\\n.notes .v-note-wrapper[data-v-c64ce914] {\\n  height: 500px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-c64ce914\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/notes/notes.vue\n// module id = aOIS\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var defaults = {\n    pairs: \"()[]{}''\\\"\\\"\",\n    triples: \"\",\n    explode: \"[]{}\"\n  };\n\n  var Pos = CodeMirror.Pos;\n\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.removeKeyMap(keyMap);\n      cm.state.closeBrackets = null;\n    }\n    if (val) {\n      cm.state.closeBrackets = val;\n      cm.addKeyMap(keyMap);\n    }\n  });\n\n  function getOption(conf, name) {\n    if (name == \"pairs\" && typeof conf == \"string\") return conf;\n    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\n    return defaults[name];\n  }\n\n  var bind = defaults.pairs + \"`\";\n  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n  for (var i = 0; i < bind.length; i++)\n    keyMap[\"'\" + bind.charAt(i) + \"'\"] = handler(bind.charAt(i));\n\n  function handler(ch) {\n    return function(cm) { return handleChar(cm, ch); };\n  }\n\n  function getConfig(cm) {\n    var deflt = cm.state.closeBrackets;\n    if (!deflt || deflt.override) return deflt;\n    var mode = cm.getModeAt(cm.getCursor());\n    return mode.closeBrackets || deflt;\n  }\n\n  function handleBackspace(cm) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var cur = ranges[i].head;\n      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), \"+delete\");\n    }\n  }\n\n  function handleEnter(cm) {\n    var conf = getConfig(cm);\n    var explode = conf && getOption(conf, \"explode\");\n    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    cm.operation(function() {\n      cm.replaceSelection(\"\\n\\n\", null);\n      cm.execCommand(\"goCharLeft\");\n      ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var line = ranges[i].head.line;\n        cm.indentLine(line, null, true);\n        cm.indentLine(line + 1, null, true);\n      }\n    });\n  }\n\n  function contractSelection(sel) {\n    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n  }\n\n  function handleChar(cm, ch) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var pos = pairs.indexOf(ch);\n    if (pos == -1) return CodeMirror.Pass;\n    var triples = getOption(conf, \"triples\");\n\n    var identical = pairs.charAt(pos + 1) == ch;\n    var ranges = cm.listSelections();\n    var opening = pos % 2 == 0;\n\n    var type;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], cur = range.head, curType;\n      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n      if (opening && !range.empty()) {\n        curType = \"surround\";\n      } else if ((identical || !opening) && next == ch) {\n        if (identical && stringStartsAfter(cm, cur))\n          curType = \"both\";\n        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n          curType = \"skipThree\";\n        else\n          curType = \"skip\";\n      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&\n                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {\n        curType = \"addFour\";\n      } else if (identical) {\n        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = \"both\";\n        else return CodeMirror.Pass;\n      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||\n                             isClosingBracket(next, pairs) ||\n                             /\\s/.test(next))) {\n        curType = \"both\";\n      } else {\n        return CodeMirror.Pass;\n      }\n      if (!type) type = curType;\n      else if (type != curType) return CodeMirror.Pass;\n    }\n\n    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n    cm.operation(function() {\n      if (type == \"skip\") {\n        cm.execCommand(\"goCharRight\");\n      } else if (type == \"skipThree\") {\n        for (var i = 0; i < 3; i++)\n          cm.execCommand(\"goCharRight\");\n      } else if (type == \"surround\") {\n        var sels = cm.getSelections();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = left + sels[i] + right;\n        cm.replaceSelections(sels, \"around\");\n        sels = cm.listSelections().slice();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = contractSelection(sels[i]);\n        cm.setSelections(sels);\n      } else if (type == \"both\") {\n        cm.replaceSelection(left + right, null);\n        cm.triggerElectric(left + right);\n        cm.execCommand(\"goCharLeft\");\n      } else if (type == \"addFour\") {\n        cm.replaceSelection(left + left + left + left, \"before\");\n        cm.execCommand(\"goCharRight\");\n      }\n    });\n  }\n\n  function isClosingBracket(ch, pairs) {\n    var pos = pairs.lastIndexOf(ch);\n    return pos > -1 && pos % 2 == 1;\n  }\n\n  function charsAround(cm, pos) {\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n                          Pos(pos.line, pos.ch + 1));\n    return str.length == 2 ? str : null;\n  }\n\n  // Project the token type that will exists after the given char is\n  // typed, and use it to determine whether it would cause the start\n  // of a string token.\n  function enteringString(cm, pos, ch) {\n    var line = cm.getLine(pos.line);\n    var token = cm.getTokenAt(pos);\n    if (/\\bstring2?\\b/.test(token.type) || stringStartsAfter(cm, pos)) return false;\n    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\n    stream.pos = stream.start = token.start;\n    for (;;) {\n      var type1 = cm.getMode().token(stream, token.state);\n      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\n      stream.start = stream.pos;\n    }\n  }\n\n  function stringStartsAfter(cm, pos) {\n    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))\n    return /\\bstring/.test(token.type) && token.start == pos.ch\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/edit/closebrackets.js\n// module id = aX1R\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureGlobal(regexp) {\n    return regexp.global ? regexp : new RegExp(regexp.source, regexpFlags(regexp) + \"g\")\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (end.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureGlobal(query)\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/searchcursor.js\n// module id = c+I8\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"markdown\", function(cm, start) {\n  var maxDepth = 100;\n\n  function isHeader(lineNo) {\n    var tokentype = cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0));\n    return tokentype && /\\bheader\\b/.test(tokentype);\n  }\n\n  function headerLevel(lineNo, line, nextLine) {\n    var match = line && line.match(/^#+/);\n    if (match && isHeader(lineNo)) return match[0].length;\n    match = nextLine && nextLine.match(/^[=\\-]+\\s*$/);\n    if (match && isHeader(lineNo + 1)) return nextLine[0] == \"=\" ? 1 : 2;\n    return maxDepth;\n  }\n\n  var firstLine = cm.getLine(start.line), nextLine = cm.getLine(start.line + 1);\n  var level = headerLevel(start.line, firstLine, nextLine);\n  if (level === maxDepth) return undefined;\n\n  var lastLineNo = cm.lastLine();\n  var end = start.line, nextNextLine = cm.getLine(end + 2);\n  while (end < lastLineNo) {\n    if (headerLevel(end + 1, nextLine, nextNextLine) <= level) break;\n    ++end;\n    nextLine = nextNextLine;\n    nextNextLine = cm.getLine(end + 2);\n  }\n\n  return {\n    from: CodeMirror.Pos(start.line, firstLine.length),\n    to: CodeMirror.Pos(end, cm.getLine(end).length)\n  };\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/markdown-fold.js\n// module id = dxBS\n// module chunks = 4 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in\"\n    }\n  }, [_c('div', [(_vm.solution) ? _c('div', {\n    staticClass: \"solution\",\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.solution)\n    }\n  }) : _vm._e(), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.solution || _vm.solution === {}),\n      expression: \"!solution || solution === {}\"\n    }],\n    staticClass: \"nodata\"\n  }, [_vm._v(\"\\n      No solution at the moment\\n    \")])])])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-6701a6dc\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/solution/solution.vue\n// module id = eg3M\n// module chunks = 4","exports = module.exports = require(\"../../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror-foldmarker{color:blue;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\\\"\\\\25BE\\\"}.CodeMirror-foldgutter-folded:after{content:\\\"\\\\25B8\\\"}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/fold/foldgutter.css\"],\"names\":[],\"mappings\":\"AAAA,uBACE,WAAY,AACZ,oFAAwF,AACxF,kBAAmB,AACnB,eAAgB,AAChB,cAAgB,CACjB,AACD,uBACE,UAAY,CACb,AACD,0DAEE,cAAgB,CACjB,AACD,kCACE,eAAiB,CAClB,AACD,oCACE,eAAiB,CAClB\",\"file\":\"foldgutter.css\",\"sourcesContent\":[\".CodeMirror-foldmarker {\\n  color: blue;\\n  text-shadow: #b9f 1px 1px 2px, #b9f -1px -1px 2px, #b9f 1px -1px 2px, #b9f -1px 1px 2px;\\n  font-family: arial;\\n  line-height: .3;\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter {\\n  width: .7em;\\n}\\n.CodeMirror-foldgutter-open,\\n.CodeMirror-foldgutter-folded {\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter-open:after {\\n  content: \\\"\\\\25BE\\\";\\n}\\n.CodeMirror-foldgutter-folded:after {\\n  content: \\\"\\\\25B8\\\";\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/codemirror/addon/fold/foldgutter.css\n// module id = engA\n// module chunks = 4 5","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".myeditor[data-v-58438f59]{margin-top:20px}.myeditor .myeditor-header[data-v-58438f59]{margin-bottom:12px}.myeditor .language-dropdown .el-dropdown-menu__item[data-v-58438f59]{padding:0 5px}.myeditor .el-dropdown-theme[data-v-58438f59]{float:right}.myeditor .el-dropdown-keyMap[data-v-58438f59]{float:right;margin-right:8px}.myeditor .CodeMirror[data-v-58438f59]{height:400px}.myeditor .myeditor-footer[data-v-58438f59]{padding:20px 0 0;height:100px;width:100%}.myeditor .myeditor-footer .custom-button[data-v-58438f59]{float:left;margin-right:10px;width:150px}.myeditor .myeditor-footer .run-button[data-v-58438f59]{float:right;margin-right:10px;width:150px}.myeditor .myeditor-footer .submit-button[data-v-58438f59]{float:right;width:150px}.myeditor .result-wrapper[data-v-58438f59]{display:-webkit-box;display:-ms-flexbox;display:flex;margin-top:-1px;padding:10px 0;border-bottom:1px solid #ddd;border-top:1px solid #ddd}.myeditor .result-wrapper .result-type[data-v-58438f59]{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto;display:inline-block}.myeditor .result-wrapper .result-type .el-tag[data-v-58438f59]{margin-top:4px;font-size:18px}.myeditor .result-wrapper .result-item[data-v-58438f59]{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;text-align:center}.myeditor .result-wrapper .result-item .result-item-text[data-v-58438f59]{font-size:18px;font-weight:600;margin:0 5px;line-height:30px;color:#9e9e9e}.myeditor .result-wrapper .result-item .result-item-text .error[data-v-58438f59]{color:#ff1744}.myeditor .result-wrapper .result-item .result-item-text .default[data-v-58438f59]{color:#333}.myeditor .result-wrapper .result-item-img[data-v-58438f59]{vertical-align:middle}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/description/myeditor.vue\"],\"names\":[],\"mappings\":\"AACA,2BACE,eAAiB,CAClB,AACD,4CACE,kBAAoB,CACrB,AACD,sEACE,aAAe,CAChB,AACD,8CACE,WAAa,CACd,AACD,+CACE,YAAa,AACb,gBAAkB,CACnB,AACD,uCACE,YAAc,CACf,AACD,4CACE,iBAAoB,AACpB,aAAc,AACd,UAAY,CACb,AACD,2DACE,WAAY,AACZ,kBAAmB,AACnB,WAAa,CACd,AACD,wDACE,YAAa,AACb,kBAAmB,AACnB,WAAa,CACd,AACD,2DACE,YAAa,AACb,WAAa,CACd,AACD,2CACE,oBAAqB,AACrB,oBAAqB,AACrB,aAAc,AACd,gBAAiB,AACjB,eAAgB,AAChB,6BAA8B,AAC9B,yBAA2B,CAC5B,AACD,wDACE,mBAAoB,AAChB,kBAAmB,AACf,cAAe,AACvB,oBAAsB,CACvB,AACD,gEACE,eAAgB,AAChB,cAAgB,CACjB,AACD,wDACE,mBAAoB,AAChB,kBAAmB,AACf,cAAe,AACvB,iBAAmB,CACpB,AACD,0EACE,eAAgB,AAChB,gBAAiB,AACjB,aAAc,AACd,iBAAkB,AAClB,aAAe,CAChB,AACD,iFACE,aAAe,CAChB,AACD,mFACE,UAAY,CACb,AACD,4DACE,qBAAuB,CACxB\",\"file\":\"myeditor.vue\",\"sourcesContent\":[\"\\n.myeditor[data-v-58438f59] {\\n  margin-top: 20px;\\n}\\n.myeditor .myeditor-header[data-v-58438f59] {\\n  margin-bottom: 12px;\\n}\\n.myeditor .language-dropdown .el-dropdown-menu__item[data-v-58438f59] {\\n  padding: 0 5px;\\n}\\n.myeditor .el-dropdown-theme[data-v-58438f59] {\\n  float: right;\\n}\\n.myeditor .el-dropdown-keyMap[data-v-58438f59] {\\n  float: right;\\n  margin-right: 8px;\\n}\\n.myeditor .CodeMirror[data-v-58438f59] {\\n  height: 400px;\\n}\\n.myeditor .myeditor-footer[data-v-58438f59] {\\n  padding: 20px 0 0 0;\\n  height: 100px;\\n  width: 100%;\\n}\\n.myeditor .myeditor-footer .custom-button[data-v-58438f59] {\\n  float: left;\\n  margin-right: 10px;\\n  width: 150px;\\n}\\n.myeditor .myeditor-footer .run-button[data-v-58438f59] {\\n  float: right;\\n  margin-right: 10px;\\n  width: 150px;\\n}\\n.myeditor .myeditor-footer .submit-button[data-v-58438f59] {\\n  float: right;\\n  width: 150px;\\n}\\n.myeditor .result-wrapper[data-v-58438f59] {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin-top: -1px;\\n  padding: 10px 0;\\n  border-bottom: 1px solid #ddd;\\n  border-top: 1px solid #ddd;\\n}\\n.myeditor .result-wrapper .result-type[data-v-58438f59] {\\n  -webkit-box-flex: 0;\\n      -ms-flex: 0 1 auto;\\n          flex: 0 1 auto;\\n  display: inline-block;\\n}\\n.myeditor .result-wrapper .result-type .el-tag[data-v-58438f59] {\\n  margin-top: 4px;\\n  font-size: 18px;\\n}\\n.myeditor .result-wrapper .result-item[data-v-58438f59] {\\n  -webkit-box-flex: 1;\\n      -ms-flex: 1 1 auto;\\n          flex: 1 1 auto;\\n  text-align: center;\\n}\\n.myeditor .result-wrapper .result-item .result-item-text[data-v-58438f59] {\\n  font-size: 18px;\\n  font-weight: 600;\\n  margin: 0 5px;\\n  line-height: 30px;\\n  color: #9e9e9e;\\n}\\n.myeditor .result-wrapper .result-item .result-item-text .error[data-v-58438f59] {\\n  color: #ff1744;\\n}\\n.myeditor .result-wrapper .result-item .result-item-text .default[data-v-58438f59] {\\n  color: #333;\\n}\\n.myeditor .result-wrapper .result-item-img[data-v-58438f59] {\\n  vertical-align: middle;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-58438f59\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/description/myeditor.vue\n// module id = f+y5\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var startLine = start.line, has = hasImport(startLine), prev;\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var startLine = start.line, has = hasInclude(startLine);\n  if (has == null || hasInclude(startLine - 1) != null) return null;\n  for (var end = startLine;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(startLine, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/brace-fold.js\n// module id = fo6W\n// module chunks = 4 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in\"\n    }\n  }, [_c('div', [(_vm.data.description) ? _c('div', {\n    staticClass: \"description\",\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.data.description)\n    }\n  }) : _vm._e(), _vm._v(\" \"), _c('my-editor')], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-4dfc5728\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/description/description.vue\n// module id = fpaw\n// module chunks = 4","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-c64ce914\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./notes.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./notes.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-c64ce914\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./notes.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-c64ce914\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/notes/notes.vue\n// module id = j09L\n// module chunks = 4","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-c64ce914\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./notes.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"30ccd70a\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-c64ce914\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/notes/notes.vue\n// module id = jCel\n// module chunks = 4","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    var self = this;\n    cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      this.cm.off(\"cursorActivity\", this.activityFunc);\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i];\n      if (completion.hint) completion.hint(this.cm, data, completion);\n      else this.cm.replaceRange(getText(completion), completion.from || data.from,\n                                completion.to || data.to, \"complete\");\n      CodeMirror.signal(data, \"pick\", completion);\n      this.close();\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||\n          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      if (data && this.data && isNewCompletion(this.data, data)) return;\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function isNewCompletion(old, nw) {\n    var moved = CodeMirror.cmpPos(nw.from, old.from)\n    return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch\n  }\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n\n    var hints = this.hints = document.createElement(\"ul\");\n    hints.className = \"CodeMirror-hints\";\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    hints.style.left = left + \"px\";\n    hints.style.top = top + \"px\";\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n    (completion.options.container || document.body).appendChild(hints);\n    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n    var scrolls = hints.scrollHeight > hints.clientHeight + 1\n    var startScroll = cm.getScrollInfo();\n\n    if (overlapY > 0) {\n      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n      if (curTop - height > 0) { // Fits above cursor\n        hints.style.top = (top = pos.top - height) + \"px\";\n        below = false;\n      } else if (height > winH) {\n        hints.style.height = (winH - 5) + \"px\";\n        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n        var cursor = cm.getCursor();\n        if (data.from.ch != cursor.ch) {\n          pos = cm.cursorCoords(cursor);\n          hints.style.left = (left = pos.left) + \"px\";\n          box = hints.getBoundingClientRect();\n        }\n      }\n    }\n    var overlapX = box.right - winW;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = pos.left - overlapX) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      if (node.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node.offsetTop - 3;\n      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    var to = CodeMirror.Pos(cur.line, token.end);\n    if (token.string && /\\w/.test(token.string[token.string.length - 1])) {\n      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);\n    } else {\n      var term = \"\", from = to;\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnUnfocus: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/hint/show-hint.js\n// module id = jQeI\n// module chunks = 4 5","/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 1.3.2\n * 2016-06-16 18:25:19\n *\n * By Eli Grey, http://eligrey.com\n * License: MIT\n *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs || (function(view) {\n\t\"use strict\";\n\t// IE <10 is explicitly unsupported\n\tif (typeof view === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n\t\treturn;\n\t}\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case Blob.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = new MouseEvent(\"click\");\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, is_safari = /constructor/i.test(view.HTMLElement) || view.safari\n\t\t, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)\n\t\t, throw_outside = function(ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t// the Blob API is fundamentally broken as there is no \"downloadfinished\" event to subscribe to\n\t\t, arbitrary_revoke_timeout = 1000 * 40 // in ms\n\t\t, revoke = function(file) {\n\t\t\tvar revoker = function() {\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tget_URL().revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetTimeout(revoker, arbitrary_revoke_timeout);\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, auto_bom = function(blob) {\n\t\t\t// prepend BOM for UTF-8 XML and text/* types (including HTML)\n\t\t\t// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\t\t\tif (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n\t\t\t\treturn new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});\n\t\t\t}\n\t\t\treturn blob;\n\t\t}\n\t\t, FileSaver = function(blob, name, no_auto_bom) {\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, force = type === force_saveable_type\n\t\t\t\t, object_url\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\tif ((is_chrome_ios || (force && is_safari)) && view.FileReader) {\n\t\t\t\t\t\t// Safari doesn't allow downloading of blob urls\n\t\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\t\treader.onloadend = function() {\n\t\t\t\t\t\t\tvar url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\t\t\t\tvar popup = view.open(url, '_blank');\n\t\t\t\t\t\t\tif(!popup) view.location.href = url;\n\t\t\t\t\t\t\turl=undefined; // release reference before dispatching\n\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\tdispatch_all();\n\t\t\t\t\t\t};\n\t\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (!object_url) {\n\t\t\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opened = view.open(object_url, \"_blank\");\n\t\t\t\t\t\tif (!opened) {\n\t\t\t\t\t\t\t// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html\n\t\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t}\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tsave_link.href = object_url;\n\t\t\t\t\tsave_link.download = name;\n\t\t\t\t\tclick(save_link);\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfs_error();\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name, no_auto_bom) {\n\t\t\treturn new FileSaver(blob, name || blob.name || \"download\", no_auto_bom);\n\t\t}\n\t;\n\t// IE 10+ (native saveAs)\n\tif (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\n\t\treturn function(blob, name, no_auto_bom) {\n\t\t\tname = name || blob.name || \"download\";\n\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\treturn navigator.msSaveOrOpenBlob(blob, name);\n\t\t};\n\t}\n\n\tFS_proto.abort = function(){};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\treturn saveAs;\n}(\n\t   typeof self !== \"undefined\" && self\n\t|| typeof window !== \"undefined\" && window\n\t|| this.content\n));\n// `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports.saveAs = saveAs;\n} else if ((typeof define !== \"undefined\" && define !== null) && (define.amd !== null)) {\n  define(\"FileSaver.js\", function() {\n    return saveAs;\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/file-saver/FileSaver.js\n// module id = lDdF\n// module chunks = 4","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-d7772fc0\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./runresultdialog.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"1ec08980\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-d7772fc0\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/description/runresultdialog.vue\n// module id = lL6t\n// module chunks = 4","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-062a844c\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./hints.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./hints.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-062a844c\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./hints.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/hints/hints.vue\n// module id = lUyH\n// module chunks = 4","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = nErl\n// module chunks = 4","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".description[data-v-4dfc5728]{border-bottom:1px solid #ddd}.description p[data-v-4dfc5728]{margin:0 0 10px;display:block;font-size:16px;-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0}.description pre[data-v-4dfc5728]{display:block;padding:9.5px;margin:0 0 10px;overflow:auto;font-size:14px;line-height:1.9;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f2f2f2;border:1px solid #ccc;border-radius:4px;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.description pre .nf[data-v-4dfc5728]{color:#900;font-weight:700}.description pre .na[data-v-4dfc5728]{color:teal}.description pre .kt[data-v-4dfc5728]{color:#458;font-weight:700}.description pre .o[data-v-4dfc5728]{font-weight:700}.description code[data-v-4dfc5728]{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.description b[data-v-4dfc5728]{font-weight:700}.description ol[data-v-4dfc5728]{margin-top:10px}.description ol li[data-v-4dfc5728]{font-size:16px}.editor .ql-editor[data-v-4dfc5728]{min-height:300px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/description/description.vue\"],\"names\":[],\"mappings\":\"AACA,8BACE,4BAA8B,CAC/B,AACD,gCACE,gBAAiB,AACjB,cAAe,AACf,eAAgB,AAChB,0BAA2B,AAC3B,yBAA0B,AAC1B,uBAA0B,AAC1B,oBAAwB,CACzB,AACD,kCACE,cAAe,AACf,cAAe,AACf,gBAAiB,AACjB,cAAe,AACf,eAAgB,AAChB,gBAAiB,AACjB,WAAY,AACZ,qBAAsB,AACtB,qBAAsB,AACtB,yBAA0B,AAC1B,sBAAuB,AACvB,kBAAmB,AACnB,uDAA+D,CAChE,AACD,sCACE,WAAY,AACZ,eAAkB,CACnB,AACD,sCACE,UAAe,CAChB,AACD,sCACE,WAAY,AACZ,eAAkB,CACnB,AACD,qCACE,eAAkB,CACnB,AACD,mCACE,gBAAiB,AACjB,cAAe,AACf,cAAe,AACf,yBAA0B,AAC1B,kBAAmB,AACnB,uDAA+D,CAChE,AACD,gCACE,eAAiB,CAClB,AACD,iCACE,eAAiB,CAClB,AACD,oCACE,cAAgB,CACjB,AACD,oCACE,gBAAkB,CACnB\",\"file\":\"description.vue\",\"sourcesContent\":[\"\\n.description[data-v-4dfc5728] {\\n  border-bottom: 1px solid #ddd;\\n}\\n.description p[data-v-4dfc5728] {\\n  margin: 0 0 10px;\\n  display: block;\\n  font-size: 16px;\\n  -webkit-margin-before: 1em;\\n  -webkit-margin-after: 1em;\\n  -webkit-margin-start: 0px;\\n  -webkit-margin-end: 0px;\\n}\\n.description pre[data-v-4dfc5728] {\\n  display: block;\\n  padding: 9.5px;\\n  margin: 0 0 10px;\\n  overflow: auto;\\n  font-size: 14px;\\n  line-height: 1.9;\\n  color: #333;\\n  word-break: break-all;\\n  word-wrap: break-word;\\n  background-color: #f2f2f2;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\n.description pre .nf[data-v-4dfc5728] {\\n  color: #900;\\n  font-weight: bold;\\n}\\n.description pre .na[data-v-4dfc5728] {\\n  color: #008080;\\n}\\n.description pre .kt[data-v-4dfc5728] {\\n  color: #458;\\n  font-weight: bold;\\n}\\n.description pre .o[data-v-4dfc5728] {\\n  font-weight: bold;\\n}\\n.description code[data-v-4dfc5728] {\\n  padding: 2px 4px;\\n  font-size: 90%;\\n  color: #c7254e;\\n  background-color: #f9f2f4;\\n  border-radius: 4px;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\n.description b[data-v-4dfc5728] {\\n  font-weight: 700;\\n}\\n.description ol[data-v-4dfc5728] {\\n  margin-top: 10px;\\n}\\n.description ol li[data-v-4dfc5728] {\\n  font-size: 16px;\\n}\\n.editor .ql-editor[data-v-4dfc5728] {\\n  min-height: 300px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-4dfc5728\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/description/description.vue\n// module id = oFfA\n// module chunks = 4","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('el-dialog', {\n    attrs: {\n      \"title\": \"运行结果\",\n      \"visible\": _vm.dialogVisible\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.dialogVisible = $event\n      }\n    }\n  }, [_c('span', {\n    slot: \"title\"\n  }, [_vm._v(\" \" + _vm._s(_vm.result.status))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"dialog-container\"\n  }, [_c('div', {\n    staticClass: \"explanation\",\n    domProps: {\n      \"textContent\": _vm._s(_vm.getExplanation(_vm.result.status))\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"text\",\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.result.output)\n    }\n  }, [_vm._v(\"{{}}\")])]), _vm._v(\" \"), _c('span', {\n    staticClass: \"dialog-footer\",\n    slot: \"footer\"\n  }, [_c('el-button', {\n    on: {\n      \"click\": function($event) {\n        _vm.dialogVisible = false\n      }\n    }\n  }, [_vm._v(\"取 消\")]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": function($event) {\n        _vm.dialogVisible = false\n      }\n    }\n  }, [_vm._v(\"确 定\")])], 1)])], 1)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-d7772fc0\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/description/runresultdialog.vue\n// module id = q8U2\n// module chunks = 4","/**\n * Created by qinzhen on 2017/9/30.\n */\nexport default class ReturnResult {\n  constructor ({mytitle, memory_used, output, status, time_used}) {\n    this.mytitle = mytitle\n    this.memory_used = memory_used\n    this.output = output\n    this.status = status\n    this.time_used = time_used\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/js/ReturnResult.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerGlobalHelper(\"fold\", \"comment\", function(mode) {\n  return mode.blockCommentStart && mode.blockCommentEnd;\n}, function(cm, start) {\n  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;\n  if (!startToken || !endToken) return;\n  var line = start.line, lineText = cm.getLine(line);\n\n  var startCh;\n  for (var at = start.ch, pass = 0;;) {\n    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);\n    if (found == -1) {\n      if (pass == 1) return;\n      pass = 1;\n      at = lineText.length;\n      continue;\n    }\n    if (pass == 1 && found < start.ch) return;\n    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&\n        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||\n         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {\n      startCh = found + startToken.length;\n      break;\n    }\n    at = found - 1;\n  }\n\n  var depth = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (pos == nextOpen) ++depth;\n      else if (!--depth) { end = i; endCh = pos; break outer; }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/comment-fold.js\n// module id = soCA\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  function kill(cm, from, to, mayGrow, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (mayGrow) lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      kill(cm, cursor, findEnd(cm, cursor, by, dir), true);\n    }\n  }\n\n  function killRegion(cm) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        kill(cm, selection.anchor, selection.head);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  function setMark(cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(msg + \": <input type=\\\"text\\\" style=\\\"width: 10em\\\"/>\", f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  function quit(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  CodeMirror.emacs = {kill: kill, killRegion: killRegion, repeated: repeated};\n\n  // Actual keymap\n\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": function(cm) {kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"));},\n    \"Ctrl-K\": repeated(function(cm) {\n      var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n      var text = cm.getRange(start, end);\n      if (!/\\S/.test(text)) {\n        text += \"\\n\";\n        end = Pos(start.line + 1, 0);\n      }\n      kill(cm, start, end, true, text);\n    }),\n    \"Alt-W\": function(cm) {\n      addToRing(cm.getSelection());\n      clearMark(cm);\n    },\n    \"Ctrl-Y\": function(cm) {\n      var start = cm.getCursor();\n      cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n      cm.setSelection(start, cm.getCursor());\n    },\n    \"Alt-Y\": function(cm) {cm.replaceSelection(popFromRing(), \"around\", \"paste\");},\n\n    \"Ctrl-Space\": setMark, \"Ctrl-Shift-2\": setMark,\n\n    \"Ctrl-F\": move(byChar, 1), \"Ctrl-B\": move(byChar, -1),\n    \"Right\": move(byChar, 1), \"Left\": move(byChar, -1),\n    \"Ctrl-D\": function(cm) { killTo(cm, byChar, 1); },\n    \"Delete\": function(cm) { killRegion(cm) || killTo(cm, byChar, 1); },\n    \"Ctrl-H\": function(cm) { killTo(cm, byChar, -1); },\n    \"Backspace\": function(cm) { killRegion(cm) || killTo(cm, byChar, -1); },\n\n    \"Alt-F\": move(byWord, 1), \"Alt-B\": move(byWord, -1),\n    \"Alt-D\": function(cm) { killTo(cm, byWord, 1); },\n    \"Alt-Backspace\": function(cm) { killTo(cm, byWord, -1); },\n\n    \"Ctrl-N\": move(byLine, 1), \"Ctrl-P\": move(byLine, -1),\n    \"Down\": move(byLine, 1), \"Up\": move(byLine, -1),\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStart\",\n\n    \"Alt-V\": move(byPage, -1), \"Ctrl-V\": move(byPage, 1),\n    \"PageUp\": move(byPage, -1), \"PageDown\": move(byPage, 1),\n\n    \"Ctrl-Up\": move(byParagraph, -1), \"Ctrl-Down\": move(byParagraph, 1),\n\n    \"Alt-A\": move(bySentence, -1), \"Alt-E\": move(bySentence, 1),\n    \"Alt-K\": function(cm) { killTo(cm, bySentence, 1); },\n\n    \"Ctrl-Alt-K\": function(cm) { killTo(cm, byExpr, 1); },\n    \"Ctrl-Alt-Backspace\": function(cm) { killTo(cm, byExpr, -1); },\n    \"Ctrl-Alt-F\": move(byExpr, 1), \"Ctrl-Alt-B\": move(byExpr, -1),\n\n    \"Shift-Ctrl-Alt-2\": function(cm) {\n      var cursor = cm.getCursor();\n      cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n    },\n    \"Ctrl-Alt-T\": function(cm) {\n      var leftStart = byExpr(cm, cm.getCursor(), -1), leftEnd = byExpr(cm, leftStart, 1);\n      var rightEnd = byExpr(cm, leftEnd, 1), rightStart = byExpr(cm, rightEnd, -1);\n      cm.replaceRange(cm.getRange(rightStart, rightEnd) + cm.getRange(leftEnd, rightStart) +\n                      cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n    },\n    \"Ctrl-Alt-U\": repeated(toEnclosingExpr),\n\n    \"Alt-Space\": function(cm) {\n      var pos = cm.getCursor(), from = pos.ch, to = pos.ch, text = cm.getLine(pos.line);\n      while (from && /\\s/.test(text.charAt(from - 1))) --from;\n      while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n      cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n    },\n    \"Ctrl-O\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"start\"); }),\n    \"Ctrl-T\": repeated(function(cm) {\n      cm.execCommand(\"transposeChars\");\n    }),\n\n    \"Alt-C\": repeated(function(cm) {\n      operateOnWord(cm, function(w) {\n        var letter = w.search(/\\w/);\n        if (letter == -1) return w;\n        return w.slice(0, letter) + w.charAt(letter).toUpperCase() + w.slice(letter + 1).toLowerCase();\n      });\n    }),\n    \"Alt-U\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toUpperCase(); });\n    }),\n    \"Alt-L\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toLowerCase(); });\n    }),\n\n    \"Alt-;\": \"toggleComment\",\n\n    \"Ctrl-/\": repeated(\"undo\"), \"Shift-Ctrl--\": repeated(\"undo\"),\n    \"Ctrl-Z\": repeated(\"undo\"), \"Cmd-Z\": repeated(\"undo\"),\n    \"Shift-Alt-,\": \"goDocStart\", \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\", \"Ctrl-R\": \"findPersistentPrev\", \"Ctrl-G\": quit, \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); }),\n    \"Tab\": \"indentAuto\",\n\n    \"Alt-G G\": function(cm) {\n      var prefix = getPrefix(cm, true);\n      if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n      getInput(cm, \"Goto line\", function(str) {\n        var num;\n        if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n          cm.setCursor(num - 1);\n      });\n    },\n\n    \"Ctrl-X Tab\": function(cm) {\n      cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n    },\n    \"Ctrl-X Ctrl-X\": function(cm) {\n      cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n    },\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X U\": repeated(\"undo\"),\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X Delete\": function(cm) { kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), true); },\n    \"Ctrl-X H\": \"selectAll\",\n\n    \"Ctrl-Q Tab\": repeated(\"insertTab\"),\n    \"Ctrl-U\": addPrefixMap\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/keymap/emacs.js\n// module id = tjx/\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && matching[line.text.charAt(pos)]) ||\n        matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/edit/matchbrackets.js\n// module id = vq+x\n// module chunks = 4 5","<template>\n  <transition name=\"el-fade-in-linear\">\n    <div class=\"problem\">\n      <el-row>\n        <el-col :sm=\"0\" :lg=\"2\" :md=\"1\" :xs=\"0\">\n          <div class=\"grid-content\">\n          </div>\n        </el-col>\n        <el-col :sm=\"24\" :lg=\"20\" :md=\"22\" :xs=\"24\">\n          <div class=\"problem-header\">\n            <h3 align=\"left\">{{problemDetail.title}}</h3>\n            <img width=\"56\" height=\"56\"\n                 class=\"collection\" :src=\"getFavoriteSrc(problemDetail)\"\n                 @click=\"collection\">\n          </div>\n          <div class=\"container\">\n            <el-tabs v-model=\"tab\" type=\"card\">\n              <el-tab-pane label=\"题目描述\" name=\"description\">\n                <description :data=\"problemDetail\"></description>\n              </el-tab-pane>\n              <el-tab-pane label=\"解决方案\" name=\"solution\">\n                <solution></solution>\n              </el-tab-pane>\n              <el-tab-pane label=\"提示\" name=\"third\">\n                <hints></hints>\n              </el-tab-pane>\n              <el-tab-pane label=\"笔记\" name=\"fourth\">\n                <notes :name=\"problem.title\"></notes>\n              </el-tab-pane>\n            </el-tabs>\n          </div>\n        </el-col>\n        <el-col :sm=\"0\" :lg=\"2\" :md=\"1\" :xs=\"0\">\n          <div class=\"grid-content\">\n          </div>\n        </el-col>\n      </el-row>\n    </div>\n  </transition>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import { mapGetters, mapActions } from 'vuex'\n  import axios from 'axios'\n  import Description from 'components/description/description'\n  import Solution from 'components/solution/solution'\n  import Hints from 'components/hints/hints'\n  import Notes from 'components/notes/notes'\n  import Problem from 'common/js/problem'\n  import { baseUrl, MSG_OK } from 'common/js/data'\n\n  export default {\n    data() {\n      return {\n        loading: true,\n        problemDetail: {},\n        tab: 'description'\n      }\n    },\n    created() {\n      this._getProblemDetail()\n    },\n    methods: {\n      _getProblemDetail() {\n        if (!this.problem.id) {\n          this.$router.push('/home')\n          return\n        }\n        console.log('problem detail id')\n        console.log(this.problem.id)\n        let url = `${baseUrl}/problems/${this.problem.id}`\n        axios.get(url).then(response => {\n          if (response.data.msg === MSG_OK) {\n            console.log(response.data.result)\n            this.problemDetail = response.data.result[0]\n            console.log(this.problemDetail.id)\n            this.loading = false\n          }\n        }, response => {\n          this._getProblemDetail()\n        })\n      },\n      collection() {\n        if (!this.user.user_id) {\n          this.$notify({\n            title: '无法收藏题目',\n            message: '请先登录',\n            type: 'error'\n          })\n        } else {\n          if (!this.hasCollect(this.problemDetail.id)) {\n            this.saveFavoriteList(new Problem({\n              id: this.problemDetail.id,\n              title: this.problemDetail.title,\n              tag: this.problemDetail.tag,\n              level: this.problemDetail.level,\n              accepted: this.problemDetail.accepted,\n              submitted: this.problemDetail.submitted\n            }))\n            this.$notify({\n              title: '收藏成功',\n              message: `收藏题目:${this.problemDetail.title}`,\n              type: 'success'\n            })\n          } else {\n            this.deleteFavoriteList(new Problem({\n              id: this.problemDetail.id,\n              title: this.problemDetail.title,\n              tag: this.problemDetail.tag,\n              level: this.problemDetail.level,\n              accepted: this.problemDetail.accepted,\n              submitted: this.problemDetail.submitted\n            }))\n            this.$notify.info({\n              title: '取消成功',\n              message: `取消收藏题目:${this.problemDetail.title}`\n            })\n          }\n        }\n      },\n      hasCollect(id) {\n        const index = this.collectionList.findIndex((item) => {\n          return item.id === id\n        })\n        return index > -1\n      },\n      getFavoriteSrc(problemDetail) {\n        if (this.user.user_id != null && this.hasCollect(problemDetail.id)) {\n          return 'static/collection.png'\n        } else {\n          return 'static/nocollection.png'\n        }\n      },\n      ...mapActions([\n        'saveFavoriteList',\n        'deleteFavoriteList'\n      ])\n    },\n    computed: {\n      ...mapGetters([\n        'problem',\n        'collectionList',\n        'user'\n      ])\n    },\n    components: {\n      Description,\n      Solution,\n      Hints,\n      Notes\n    }\n  }\n</script>\n\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n  .problem\n    flex: 1 0 auto;\n    .problem-header\n      .collection\n        float right\n        margin-top 5px\n        vertical-align bottom\n      h3\n        display: inline-block;\n        margin-bottom: 10px;\n        font-weight: 500;\n        line-height: 1.0;\n        font-size: 24px;\n\n  .container\n    margin-top: 32px;\n    .el-tabs__content\n      min-height 800px\n\n  .grid-content\n    border-radius: 4px\n    min-height: 36px\n\n  .bg-purple\n    background: #d3dce6\n\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/problem-detail/problem-detail.vue?f75b413a"],"sourceRoot":""}