{"version":3,"sources":["webpack:///static/js/5.e1e540a677db9d0c2e7e.js","webpack:///./~/codemirror/addon/edit/closetag.js?5e13","webpack:///./~/codemirror/addon/search/matchesonscrollbar.js?ba1e","webpack:///./src/components/search/search.vue?195a*","webpack:///./src/base/confirm/confirm.vue?ec96**","webpack:///src/base/confirm/confirm.vue?4bfc*","webpack:///./src/common/js/problem.js?e44c*","webpack:///./~/codemirror/keymap/sublime.js?595d","webpack:///src/components/search/search.vue?a000","webpack:///./src/components/manager/manage-problems.vue","webpack:///./~/codemirror/addon/search/search.js?82ab","webpack:///./~/base64-js/index.js","webpack:///src/components/manager/manage-problem-edit.vue","webpack:///./~/buffer/index.js","webpack:///./src/components/manager/manage-problem-edit.vue","webpack:///./~/codemirror/keymap/vim.js?4baf","webpack:///./src/base/confirm/confirm.vue?f15f**","webpack:///./src/base/confirm/confirm.vue?f1f9**","webpack:///./~/codemirror/addon/fold/foldgutter.js?8645","webpack:///./~/codemirror/addon/dialog/dialog.css?ae99*","webpack:///./~/codemirror/addon/hint/javascript-hint.js?7f9d","webpack:///./~/codemirror/addon/search/match-highlighter.js?bf60","webpack:///./~/codemirror/addon/scroll/annotatescrollbar.js?2d94","webpack:///./~/codemirror/addon/dialog/dialog.css?7d4f","webpack:///./~/codemirror/addon/dialog/dialog.js?3114","webpack:///./src/components/search/search.vue?1980*","webpack:///./src/components/manager/manage-problems.vue?6356","webpack:///./~/codemirror/addon/fold/foldcode.js?1a0b","webpack:///./~/codemirror/addon/fold/xml-fold.js?8688","webpack:///./~/codemirror/addon/fold/indent-fold.js?3b0d","webpack:///./~/codemirror/addon/selection/mark-selection.js?0c6f","webpack:///./src/base/confirm/confirm.vue","webpack:///./src/components/search/search.vue?f391","webpack:///./~/codemirror/addon/fold/foldgutter.css?9068*","webpack:///./~/codemirror/addon/comment/comment.js?8634","webpack:///./~/codemirror/addon/selection/active-line.js?3dbe","webpack:///./~/codemirror/addon/edit/closebrackets.js?d13b","webpack:///./~/codemirror/addon/search/searchcursor.js?b9a9","webpack:///./src/components/manager/manage-problem-edit.vue?d772","webpack:///./src/components/manager/manage-problem-edit.vue?5540","webpack:///./~/codemirror/addon/fold/markdown-fold.js?4d58","webpack:///./~/codemirror/addon/fold/foldgutter.css?cc73","webpack:///./~/codemirror/addon/fold/brace-fold.js?b412","webpack:///./src/components/manager/manage-problem-edit.vue?dbf8","webpack:///./~/codemirror/addon/hint/show-hint.js?12d2","webpack:///src/components/manager/manage-problems.vue","webpack:///./~/babel-runtime/core-js/json/stringify.js?4574*","webpack:///./src/components/manager/manage-problems.vue?9bc3","webpack:///./~/core-js/library/fn/json/stringify.js?6708*","webpack:///./src/components/manager/manage-problems.vue?d6b0","webpack:///./~/isarray/index.js","webpack:///./~/codemirror/addon/fold/comment-fold.js?8312","webpack:///./~/codemirror/keymap/emacs.js?dd5c","webpack:///./~/ieee754/index.js","webpack:///./~/codemirror/addon/edit/matchbrackets.js?0c12","webpack:///./~/js-base64/base64.js","webpack:///./src/components/search/search.vue?afb0*"],"names":["webpackJsonp","+/ra","module","exports","__webpack_require__","mod","CodeMirror","autoCloseGT","cm","getOption","Pass","ranges","listSelections","replacements","i","length","empty","pos","head","tok","getTokenAt","inner","innerMode","getMode","state","mode","name","tagName","opt","html","configuration","dontCloseTags","htmlDontClose","indentTags","htmlIndent","end","ch","slice","lowerTagName","toLowerCase","type","test","string","charAt","indexOf","closingTagExists","indent","text","newPos","Pos","line","info","replaceRange","anchor","sel","setSelections","indentLine","autoCloseCurrent","typingSlash","start","replacement","context","getLine","replaceSelections","autoCloseSlash","collection","elt","e","newTag","scanForClosingTag","Math","min","lastLine","nextClose","tag","cx","onCx","prev","to","next","defineOption","val","old","Init","removeKeyMap","map","whenClosing","whenOpening","addKeyMap","commands","closeTag","/A6h","SearchAnnotation","query","caseFold","options","this","annotateOptions","listenForChanges","prop","className","annotation","annotateScrollbar","gap","from","firstLine","matches","update","findMatches","self","on","changeHandler","_cm","change","onChange","offsetLine","changeStart","sizeChange","max","defineExtension","prototype","match","splice","cursor","getSearchCursor","maxMatches","findNext","startLine","endLine","changeEnd","newFrom","newTo","clearTimeout","setTimeout","updateAfterChange","clear","off","0tR3","__webpack_exports__","render","_vm","_h","$createElement","_c","_self","command","handleCommandDropdown","staticClass","attrs","placeholder","icon","spellcheck","on-icon-click","_onSearch","focus","model","value","callback","$$v","mysearch","trim","expression","_v","slot","directives","rawName","_l","item","index","dropdownLoading","key","id","_s","title","width","height","src","staticRenderFns","esExports","2EAN","push","version","sources","names","mappings","file","sourcesContent","sourceRoot","3CS+","props","String","default","confirmBtnText","cancelBtnText","data","visible","methods","show","hide","confirm","$emit","cancel","5Ey+","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default","n","Problem","_ref","level","description","accepted","submitted","like_nums","hate_nums","7Xsf","findPosSubword","doc","dir","clipPos","cat","isWordChar","toUpperCase","moveSubword","extendSelectionsBy","range","display","shift","extend","insertLine","above","isReadOnly","operation","len","newSelection","last","at","execCommand","wordAt","word","addCursorToSelection","newRanges","newAnchor","findPosV","newHead","newRange","isSelectedRange","selectBetweenBrackets","opening","scanForBracket","closing","mirror","sortLines","caseSensitive","selected","toSort","lines","getRange","sort","a","b","au","bu","modifyWordOrSelection","indices","cmpPos","getTarget","getCursor","findAndGoTo","forward","target","cur","findPrevious","setSelection","keyMap","sublime","fallthrough","cmds","mac","macDefault","ctrl","goSubwordCombo","scrollLineCombo","getScrollInfo","somethingSelected","visibleBottomLine","lineAtHeight","top","clientHeight","scrollTo","defaultTextHeight","visibleTopLine","lineRanges","scroll","extended","fullWord","sublimeFindFullWord","RegExp","found","addSelection","addCursorToLineCombo","swapLineCombo","linesToMove","newSels","scrollIntoView","toggleComment","joined","offset","obj","actual","exec","rangeCount","marks","sublimeBookmarks","current","find","unshift","pop","findMarks","j","sublimeBookmark","k","markText","clearWhenEmpty","cK","cursors","indentUnit","toStartOfLine","column","countColumn","deletePos","findPosH","prevIndent","findColumn","str","sublimeMark","setBookmark","tmp","sublimeKilled","setCursor","replaceSelection","cursorCoords","bottom","selectLinesCombo","primaryIndex","normalizeKeyMap","A1IV","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default","__WEBPACK_IMPORTED_MODULE_1_common_js_problem__","__WEBPACK_IMPORTED_MODULE_2_axios__","__WEBPACK_IMPORTED_MODULE_2_axios___default","__WEBPACK_IMPORTED_MODULE_3_common_js_data__","__WEBPACK_IMPORTED_MODULE_4_vuex__","searchResult","_this","console","log","url","post","content","then","response","result","setProblem","$router","BUZr","injectStyle","ssrContext","Object","defineProperty","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manage_problems_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1ffcf786_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_manage_problems_vue__","normalizeComponent","__vue_styles__","Component","CK2l","searchOverlay","caseInsensitive","replace","global","source","ignoreCase","token","stream","lastIndex","skipToEnd","SearchState","posFrom","posTo","lastQuery","overlay","getSearchState","search","queryCaseInsensitive","multiline","persistentDialog","deflt","onEnter","onKeyDown","openDialog","selectValueOnOpen","closeOnEnter","onClose","clearSearch","dialog","shortText","f","prompt","confirmDialog","fs","openConfirm","parseString","_","parseQuery","isRE","startSearch","queryText","removeOverlay","addOverlay","showMatchesOnScrollbar","annotate","doSearch","rev","persistent","immediate","q","getSelection","hiding","searchNext","event","e_stop","style","opacity","shiftKey","document","querySelector","wrapper","getBoundingClientRect","queryDialog","keyName","extra","cmd","replaceAll","all","dialogText","replaceQueryDialog","replacementQueryDialog","advance","doReplaceConfirm","doReplace","findPersistent","findPersistentNext","findPersistentPrev","findPrev","EKta","placeHoldersCount","b64","Error","byteLength","toByteArray","l","placeHolders","arr","Arr","L","revLookup","charCodeAt","tripletToBase64","num","lookup","encodeChunk","uint8","output","join","fromByteArray","extraBytes","parts","len2","Uint8Array","Array","code","ELu2","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default","__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends__","__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default","__WEBPACK_IMPORTED_MODULE_2_codemirror_mode_javascript_javascript__","__WEBPACK_IMPORTED_MODULE_3_codemirror_mode_go_go__","__WEBPACK_IMPORTED_MODULE_4_codemirror_mode_python_python__","__WEBPACK_IMPORTED_MODULE_5_codemirror_mode_ruby_ruby__","__WEBPACK_IMPORTED_MODULE_6_codemirror_mode_clike_clike__","__WEBPACK_IMPORTED_MODULE_7_codemirror_theme_ambiance_css__","__WEBPACK_IMPORTED_MODULE_8_codemirror_theme_base16_dark_css__","__WEBPACK_IMPORTED_MODULE_9_codemirror_theme_cobalt_css__","__WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_light_css__","__WEBPACK_IMPORTED_MODULE_11_codemirror_theme_paraiso_dark_css__","__WEBPACK_IMPORTED_MODULE_12_codemirror_theme_rubyblue_css__","__WEBPACK_IMPORTED_MODULE_13_codemirror_theme_solarized_css__","__WEBPACK_IMPORTED_MODULE_14_codemirror_theme_mbo_css__","__WEBPACK_IMPORTED_MODULE_15_vuex__","__WEBPACK_IMPORTED_MODULE_16_common_js_data__","__WEBPACK_IMPORTED_MODULE_17_axios__","__WEBPACK_IMPORTED_MODULE_17_axios___default","isEdit","Boolean","form","program","input","checkLanguageList","toolbars","bold","italic","header","underline","strikethrough","mark","quote","ol","ul","link","table","undo","redo","trash","alignleft","aligncenter","alignright","preview","editorOptions1","tabSize","theme","lineNumbers","foldGutter","gutters","styleSelectedText","highlightSelectionMatches","showToken","editorOptions2","editorThemes","selectTheme","Languages","selectLanguage","editorModes","templetC","defaultCode","templetCpp","templetCsharp","templetJava","templetPython","templetJs","templetRuby","templetGolang","newTitle","quit","_clearAllData","clickBtn","Base64","_addTemplet","array","_pushALLTemplets","resultTemplets","reviseProblem","setupProblem","_this2","encode","msg","$notify","message","error","problem","reviseProblemWithTitle","reviseProblemWithoutTitle","_this3","put","_this4","setTemplets","handleCommandLangage","_this5","templets","dropdownChange","isShow","res","showPromblemInfo","_this6","url1","get","url2","JSON","parse","changeTemplets","getProblemStd","_this7","decode","_this8","tempC","tempCpp","tempCsharp","tempJava","tempPython","tempJs","tempRuby","tempGo","calcBtnText","handleCommandTheme","computed","EuP9","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","arg","encodingOrOffset","allocUnsafe","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","undefined","checked","isEncoding","write","fromArrayLike","byteOffset","isBuffer","copy","buffer","isnan","isArray","toString","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","isNaN","arrayIndexOf","call","lastIndexOf","read","buf","indexSize","readUInt16BE","arrLength","valLength","foundIndex","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","ret","out","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","units","Infinity","leadSurrogate","byteArray","c","hi","lo","dst","INSPECT_MAX_BYTES","foo","subarray","poolSize","_augment","Symbol","species","configurable","allocUnsafeSlow","_isBuffer","compare","x","y","concat","list","swap16","swap32","swap64","arguments","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","HbqP","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manage_problem_edit_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_49e52881_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_manage_problem_edit_vue__","Hyg2","defaultKeymap","keys","toKeys","action","motion","motionArgs","linewise","toJumplist","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","Vim","enterVimMode","setOption","signal","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","vim","detachVimMap","rmClass","getWrapperElement","attach","attachVimMap","addClass","cmKey","vimKey","cmKeyToVimKey","findKey","pieces","split","lastPiece","hasCharacter","piece","modifiers","specialKeys","isUpperCase","onPasteFn","insertMode","offsetCursor","actions","enterInsertMode","makeKeyRange","isLine","isLowerCase","isMatchableSymbol","isNumber","numberRegex","isWhiteSpaceString","inArray","defaultValue","aliases","cfg","option","scope","local","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","createInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","resetVimGlobalState","vimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","createCircularJumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","prefixRepeat","motionRepeat","keyBuffer","registerName","clearInputState","reason","Register","insertModeChanges","searchQueries","defineRegister","register","registers","validRegisters","unnamedRegister","historyBuffer","iterator","initialPrefix","defineMotion","fn","motions","fillArray","times","defineOperator","operators","defineAction","clipCursorToContent","includeLineBreak","maxCh","lineLength","copyArgs","args","hasOwnProperty","offsetCh","getOffset","commandMatches","partial","full","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","lastChar","repeatFn","repeat","copyCursor","cursorEqual","cur1","cur2","cursorIsBefore","cursorMin","cursorMax","cursorIsBetween","cur3","cur1before2","cur2before3","lineNum","s","escapeRegex","extendLineToColumn","endCh","spaces","selectBlock","selectionEnd","selections","isClipped","curHead","primIndex","getIndex","wasClipped","base","baseCh","headCh","newDir","selectForInsert","lineHead","atAnchor","atHead","getSelectedAreaRange","selectionStart","block","anchorMark","headMark","updateLastSelection","posFromIndex","indexFromPos","expandSelection","updateCmSelection","cmSel","makeCmSelection","primary","updateFakeCursor","exclusive","headOffset","anchorOffset","left","right","getHead","exitVisualMode","moveHead","clipToLine","curStart","curEnd","selection","expandSelectionToLine","findFirstNonWhiteSpaceCharacter","firstNonWS","expandWordUnderCursor","_forward","noSymbol","idx","wordCharTest","bigWordCharTest","wordStart","recordJumpPosition","oldCur","newCur","add","recordLastCharacterSearch","findSymbol","symb","lineCount","curCh","lineText","nextCh","lastCh","reverseSymb",")","}","(","{","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","moveToWord","words","eodCh","shortCircuit","firstWord","lastWord","moveToCharacter","character","charIdxInLine","moveToColumn","updateMark","markName","validMarks","includeChar","findParagraph","isEmpty","isBoundary","any","startState","selectCompanionObject","bracketRegexp","[","]","openSym","curChar","bracketRegex","findBeginningAndEnd","chars","firstIndex","searchState_","template","onKeyUp","splitBySlash","argString","slashes","findUnescapedSlashes","tokens","substring","escapeNextChar","translateRegex","specials","unescape","specialComesNext","translateRegexReplace","charUnescapes","unescapeRegexReplace","StringStream","eol","peek","matched","matcher","unescapes","smartCase","getRegister","setText","regexPart","forceIgnoreCase","showConfirm","openNotification","duration","alert","makePrompt","prefix","desc","raw","showPrompt","regexEqual","r1","r2","updateSearchQuery","rawQuery","highlightSearchMatches","getQuery","setQuery","matchSol","sol","backUp","searchState","getOverlay","getScrollbarAnnotate","setScrollbarAnnotate","setOverlay","clearSearchHighlight","isInRange","getUserVisibleLines","scrollInfo","coordsChar","bottomY","getMarkPos","history","done","lineStart","lineEnd","searchCursor","replaceWith","newText","lastPos","close","exMode","onPromptKeyDown","_value","savedCallback","exitInsertMode","insertModeChangeRegister","lastChange","selLength","inVisualBlock","changes","InsertModeKey","onKeyEventTargetKeyDown","repeatLastEdit","repeatOverride","toggleOverwrite","logInsertModeChange","_mapCommand","mapCommand","executeMacroRegister","exCommandDispatcher","processCommand","imc","handleKey","repeatInsertModeChanges","logKey","pushText","pushInsertModeChanges","logSearchQuery","pushSearchQuery","changeObj","expectCursorActivityForChange","origin","maybeReset","overwrite","curOp","isVimOp","handleExternalSelection","onKeyFound","lookupKey","repeatForInsert","repeatCommand","isAction","commandDispatcher","processAction","evalInput","repeatInsert","changeObject","cachedInputState","keyHandler","binding","lastSel","Shift","Ctrl","Alt","Cmd","Mod","Enter","Backspace","Delete","Insert","upperCaseAlphabet","lowerCaseAlphabet","numbers","useNextSlot","pointer","trashMark","curMark","markPos","tail","move","inc","cachedCursor","exitMacroRecordMode","enterMacroRecordMode","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","lhs","rhs","ctx","unmap","defineEx","func","exCommands","commandMap_","handleMacroRecording","handleEsc","doKeyToKey","keysAreChars","matchCommand","thisMatch","window","here","keysMatcher","pushRepeatDigit","handleEx","getRepeat","isValidRegister","shiftNumericRegisters_","nextMatch","up","element","pushInput","reset","bestMatch","processMotion","processOperator","processOperatorMotion","processSearch","processEx","repeatIsExplicit","recordLastEdit","handleQuery","onPromptClose","originalScrollPos","onPromptKeyUp","parsedQuery","originalQuery","setReversed","promptPrefix","searchPromptDesc","isKeyword","exArgs","origHead","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","lineOffset","abs","chOffset","operatorMoveTo","actionCommand","moveToTopLine","_head","moveToMiddleLine","moveToBottomLine","expandToLine","isReversed","goToMark","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","moveByCharacters","moveByLines","moveByDisplayLines","moveByScroll","moveToEol","first","moveToStartOfLine","charCoords","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","scrollbox","orig","dest","moveByWords","moveTillCharacter","moveToSymbol","retval","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","getTokenTypeAt","findMatchingBracket","moveToLineOrEdgeOfDocument","textObjectManipulation","mirroredPairs","selfPaired","'","\"","repeatLastCharacterSearch","lastSearch","moveH","finalHead","lastState","prevLineEnd","MAX_VALUE","wasLastLine","newlineAndIndent","delete","changeCase","getSelections","swapped","toSwap","yank","endPos","jumpListWalk","lineHeight","delta","ceil","newBottom","scrollToCursor","replayMacro","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineAndIndentContinueComment","paste","whitespaceLength","tabs","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","selectedText","emptyStrings","setRegister","setMark","replaceTo","replaceWithStr","incrementNumberToken","numberStr","lineStr","re","number","*","/","M","#","bracket","section","comment","method","preprocess","reversed","\\n","\\r","\\t","\\/","\\\\","ExCommandDispatcher","buildCommandMap_","opt_params","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","mapping","colorscheme","mapArgs","imap","nmap","vmap","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","setOptionReturn","setlocal","setglobal","regArgs","regInfo","compareFn","reverse","anum","bnum","radix","comparePatternFn","unique","pattern","err","eatSpace","opts","decimal","hex","octal","numPart","textPart","matchPart","textOld","matchedLines","nextCommand","substitute","trailing","flagsPart","count","replacePart","startPos","save","nohlsearch","delmarks","sym","startMark","finishMark","finish","detach","IruO","update:visible","$event","click","JM2O","locals","Kk9m","State","parseOptions","gutter","indicatorOpen","indicatorFolded","isFolded","__isFold","marker","spec","createElement","cloneNode","updateFoldInfo","minSize","foldOption","eachLine","setGutterMarker","updateInViewport","vp","getViewport","onGutterClick","folded","foldCode","rangeFinder","changeUpdate","foldOnChangeTimeSpan","onViewportChange","updateViewportTimeSpan","onFold","clearGutter","LxZp","Mixr","forEach","arrayContains","scriptHint","editor","keywords","getToken","tprop","getCompletions","javascriptHint","javascriptKeywords","getCoffeeScriptToken","coffeescriptHint","coffeescriptKeywords","forAllProps","getOwnPropertyNames","getPrototypeOf","o","maybeAdd","gatherCompletions","stringProps","arrayProps","Function","funcProps","globalScope","additionalContext","useGlobalScope","jQuery","v","localVars","globalVars","registerHelper","OkRY","defaults","timeout","matchesonscroll","active","cursorActivity","matchHighlighter","hasFocus","scheduleHighlight","onFocus","highlightMatches","delay","hasBoundary","makeOverlay","searchFor","wordsOnly","isWord","minChars","chr","boundariesAround","skipTo","QSKu","Annotation","scheduleRedraw","doRedraw","redraw","buttonHeight","scrollButtonHeight","annotations","doUpdate","div","appendChild","cssText","computeScale","resizeHandler","hScale","barHeight","getScrollerElement","scrollHeight","compute","getY","curLine","curLineObj","getLineHandle","widgets","wrapping","singleLineH","heightAtLine","frag","createDocumentFragment","anns","barWidth","nextTop","ann","setAttribute","textContent","parentNode","removeChild","RkAk","RkhK","dialogDiv","wrap","innerHTML","closeNotification","newVal","currentNotificationClose","inp","closed","me","button","getElementsByTagName","select","onInput","keyCode","blur","closeOnBlur","callbacks","buttons","blurring","e_preventDefault","doneTimer","RrKZ","S1i8","THjC","doFold","force","allowFolded","finder","findMarksAt","cleared","myWidget","makeWidget","myRange","replacedWith","clearOnEnter","widget","createTextNode","editorOptions","foldOptions","defaultOptions","newFoldFunction","toggleFold","fold","unfold","foldAll","unfoldAll","funcs","helpers","getHelpers","auto","minFoldSize","scanUp","TQy8","cmp","Iter","tagAt","iter","nextLine","prevLine","toTagEnd","gt","lastSlash","selfClose","toTagStart","lt","xmlTagStart","toNextTag","toPrevTag","findMatchingClose","stack","startCh","findMatchingOpen","nameStartChar","openTag","findMatchingTag","open","findEnclosingTag","U3HU","lineIndent","lineNo","spaceTo","myIndent","lastLineInFold","U80t","markedSelection","coverRange","addAt","cls","markedSelectionStyle","CHUNK_SIZE","atEnd","coverStart","coverEnd","XEAW","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_confirm_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_48f25eaf_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_confirm_vue__","YOyO","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_search_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d96e4b2_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_search_vue__","Yokd","Z6qg","nonWS","probablyInsideString","useInnerComments","getModeAt","noOptions","minLine","uncomment","lineComment","commentString","blockCommentStart","fullLines","blockComment","pad","padding","blankLines","commentBlankLines","baseString","whitespace","cut","startString","endString","blockCommentEnd","lastLineHasText","lead","blockCommentLead","didSomething","lineString","insideStart","insideEnd","lastStart","firstEnd","almostLastStart","openEnd","foundEnd","aGTD","clearActiveLines","activeLines","removeLineClass","WRAP_CLASS","BACK_CLASS","GUTT_CLASS","sameArray","updateActiveLines","nonEmpty","getLineHandleVisualStart","addLineClass","selectionChange","aX1R","conf","getConfig","closeBrackets","override","handleBackspace","pairs","around","charsAround","handleEnter","explode","contractSelection","inverted","handleChar","triples","identical","curType","enteringString","isClosingBracket","stringStartsAfter","sels","triggerElectric","type1","bind","c+I8","regexpFlags","regexp","flags","ensureGlobal","maybeMultiline","searchRegexpForward","searchRegexpForwardMultiline","chunk","before","inside","lastMatchIn","cutOff","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","adjustPos","foldFunc","mid","searchStringForward","noFold","cutFrom","searchStringBackward","topString","SearchCursor","atOccurrence","normalize","splitLines","defineDocExtension","c2Vz","stopPropagation","nativeOn","ref","label-width","label","default_open","rows","trigger","menu-align","visible-change","domProps","drNd","dxBS","isHeader","tokentype","headerLevel","maxDepth","lastLineNo","nextNextLine","engA","fo6W","findOpening","openCh","pass","tokenType","startToken","endToken","outer","nextOpen","hasImport","semi","has","hasInclude","hdeF","jQeI","Completion","debounce","tick","startLen","activityFunc","isNewCompletion","nw","hintOptions","hint","resolve","getText","completion","handle","addBinding","bound","baseMap","ourMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","pick","Tab","Esc","custom","customKeys","extraKeys","getHintElement","hintsElement","el","nodeName","Widget","picked","hints","selectedHint","completions","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","displayText","hintId","alignWithWord","below","winW","innerWidth","body","offsetWidth","documentElement","winH","innerHeight","offsetHeight","container","box","overlapY","scrolls","startScroll","overlapX","node","firstChild","nextSibling","paddingRight","nativeBarWidth","avoidWrap","changeActive","screenAmount","closeOnUnfocus","closingOnBlur","onBlur","onScroll","curScroll","newTop","point","pageYOffset","scrollTop","t","srcElement","completeOnSingleClick","applicableHelpers","supportsSelection","fetchHints","async","resolveAutoHints","resolved","run","app","getHelper","fromList","anyword","showHint","getHints","newOpts","completionActive","requestAnimationFrame","cancelAnimationFrame","closeCharacters","disable","myTick","finishUpdate","completeSingle","childNodes","offsetTop","term","autocomplete","kYSO","__WEBPACK_IMPORTED_MODULE_1_common_js_data__","__WEBPACK_IMPORTED_MODULE_3__node_modules_element_ui_packages_form_src_form_item__","__WEBPACK_IMPORTED_MODULE_4_components_search_search__","__WEBPACK_IMPORTED_MODULE_5_components_manager_manage_problem_edit__","__WEBPACK_IMPORTED_MODULE_6_vuex__","__WEBPACK_IMPORTED_MODULE_7_common_js_problem__","__WEBPACK_IMPORTED_MODULE_8_base_confirm_confirm__","problemDatas","cur_page","multipleSelection","select_cate","select_word","del_list","is_search","rules","required","isShowEdit","confirmText","curProblemId","curProblemTitle","created","_getProblemsData","showSetupProblem","handleCurrentChange","curPage","formatter","row","address","filterTag","handleEdit","saveOneProblem","$refs","problemEdit","handleDelete","confirmDele","$message","delAll","calcTag","cellValue","handleSelectionChange","hideEdit","refreshProblems","contestDatas","filter","d","is_del","components","ElFormItem","Search","ProblemEdit","Confirm","mvHQ","__esModule","oxMS","staticStyle","border","selection-change","sortable","fixed","scopedSlots","_u","$index","layout","current-page","total","current-change","editFinish","qkKv","core","$JSON","stringify","it","qm6i","sOR5","soCA","registerGlobalHelper","tjx/","posEq","addToRing","killRing","growRingTop","getFromRing","popFromRing","kill","mayGrow","lastKill","isClean","gen","changeGeneration","byChar","byWord","byLine","goalColumn","byPage","byParagraph","no","sawText","fst","lst","bySentence","sawWord","byExpr","strict","getPrefix","precise","digits","emacsPrefix","clearPrefix","repeated","findEnd","by","extendSelection","killTo","killRegion","addPrefix","digit","maybeClearPrefix","maybeDuplicateInput","emacsPrefixMap","prefixPreservingKeys","dup","one","txt","addPrefixMap","prefixMap","maybeRemovePrefixMap","setExtending","getExtending","clearMark","getInput","operateOnWord","op","toEnclosingExpr","regPrefix","Alt-G","Ctrl-X","Ctrl-Q","Ctrl-U","emacs","Ctrl-W","Ctrl-K","Alt-W","Ctrl-Y","Alt-Y","Ctrl-Space","Ctrl-Shift-2","Ctrl-F","Ctrl-B","Right","Left","Ctrl-D","Ctrl-H","Alt-F","Alt-B","Alt-D","Alt-Backspace","Ctrl-N","Ctrl-P","Ctrl-A","Ctrl-E","Alt-V","Ctrl-V","Ctrl-Up","Ctrl-Down","Alt-A","Alt-E","Alt-K","Ctrl-Alt-K","Ctrl-Alt-Backspace","Ctrl-Alt-F","Ctrl-Alt-B","Shift-Ctrl-Alt-2","Ctrl-Alt-T","leftStart","leftEnd","rightEnd","rightStart","Ctrl-Alt-U","Alt-Space","Ctrl-O","Ctrl-T","Alt-C","w","letter","Alt-U","Alt-L","Alt-;","Ctrl-/","Shift-Ctrl--","Ctrl-Z","Cmd-Z","Shift-Alt-,","Shift-Alt-.","Ctrl-S","Ctrl-R","Ctrl-G","Shift-Alt-5","Alt-/","Ctrl-J","Alt-G G","Ctrl-X Tab","indentSelection","Ctrl-X Ctrl-X","Ctrl-X Ctrl-S","Ctrl-X Ctrl-W","Ctrl-X S","Ctrl-X F","Ctrl-X U","Ctrl-X K","Ctrl-X Delete","Ctrl-X H","Ctrl-Q Tab","ujcs","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","LN2","vq+x","where","config","afterCursor","matching","maxScanLen","maxScanLineLength","maxScanLines","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","ie_lt8","focused","doMatchBrackets","currentlyHighlighted","navigator","userAgent","documentMode","oldConfig","xrTZ","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_Base64","b64chars","b64tab","bin","cb_utob","cc","re_utob","utob","u","cb_encode","ccc","padlen","ord","btoa","_encode","constructor","urisafe","m0","encodeURI","re_btou","cb_btou","cccc","cp","btou","cb_decode","atob","_decode","noConflict","VERSION","fromBase64","toBase64","noEnum","enumerable","writable","extendString","yGpH"],"mappings":"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","file":"static/js/5.e1e540a677db9d0c2e7e.js","sourcesContent":["webpackJsonp([5],{\n\n/***/ \"+/ra\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Tag-closer extension for CodeMirror.\n *\n * This extension adds an \"autoCloseTags\" option that can be set to\n * either true to get the default behavior, or an object to further\n * configure its behavior.\n *\n * These are supported options:\n *\n * `whenClosing` (default true)\n *   Whether to autoclose when the '/' of a closing tag is typed.\n * `whenOpening` (default true)\n *   Whether to autoclose the tag when the final '>' of an opening\n *   tag is typed.\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\n *   An array of tag names that should not be autoclosed.\n * `indentTags` (default is block tags for HTML, none for XML)\n *   An array of tag names that should, when opened, cause a\n *   blank line to be added inside the tag, and the blank line and\n *   closing line to be indented.\n *\n * See demos/closetag.html for a usage example.\n */\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"TQy8\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../fold/xml-fold\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  CodeMirror.defineOption(\"autoCloseTags\", false, function(cm, val, old) {\n    if (old != CodeMirror.Init && old)\n      cm.removeKeyMap(\"autoCloseTags\");\n    if (!val) return;\n    var map = {name: \"autoCloseTags\"};\n    if (typeof val != \"object\" || val.whenClosing)\n      map[\"'/'\"] = function(cm) { return autoCloseSlash(cm); };\n    if (typeof val != \"object\" || val.whenOpening)\n      map[\"'>'\"] = function(cm) { return autoCloseGT(cm); };\n    cm.addKeyMap(map);\n  });\n\n  var htmlDontClose = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n                       \"source\", \"track\", \"wbr\"];\n  var htmlIndent = [\"applet\", \"blockquote\", \"body\", \"button\", \"div\", \"dl\", \"fieldset\", \"form\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\",\n                    \"h5\", \"h6\", \"head\", \"html\", \"iframe\", \"layer\", \"legend\", \"object\", \"ol\", \"p\", \"select\", \"table\", \"ul\"];\n\n  function autoCloseGT(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (inner.mode.name != \"xml\" || !state.tagName) return CodeMirror.Pass;\n\n      var opt = cm.getOption(\"autoCloseTags\"), html = inner.mode.configuration == \"html\";\n      var dontCloseTags = (typeof opt == \"object\" && opt.dontCloseTags) || (html && htmlDontClose);\n      var indentTags = (typeof opt == \"object\" && opt.indentTags) || (html && htmlIndent);\n\n      var tagName = state.tagName;\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n      var lowerTagName = tagName.toLowerCase();\n      // Don't process the '>' at the end of an end-tag or self-closing tag\n      if (!tagName ||\n          tok.type == \"string\" && (tok.end != pos.ch || !/[\\\"\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||\n          tok.type == \"tag\" && state.type == \"closeTag\" ||\n          tok.string.indexOf(\"/\") == (tok.string.length - 1) || // match something like <someTagName />\n          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||\n          closingTagExists(cm, tagName, pos, state, true))\n        return CodeMirror.Pass;\n\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n      replacements[i] = {indent: indent,\n                         text: \">\" + (indent ? \"\\n\\n\" : \"\") + \"</\" + tagName + \">\",\n                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};\n    }\n\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var info = replacements[i];\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, \"+insert\");\n      var sel = cm.listSelections().slice(0);\n      sel[i] = {head: info.newPos, anchor: info.newPos};\n      cm.setSelections(sel);\n      if (info.indent) {\n        cm.indentLine(info.newPos.line, null, true);\n        cm.indentLine(info.newPos.line + 1, null, true);\n      }\n    }\n  }\n\n  function autoCloseCurrent(cm, typingSlash) {\n    var ranges = cm.listSelections(), replacements = [];\n    var head = typingSlash ? \"/\" : \"</\";\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (typingSlash && (tok.type == \"string\" || tok.string.charAt(0) != \"<\" ||\n                          tok.start != pos.ch - 1))\n        return CodeMirror.Pass;\n      // Kludge to get around the fact that we are not in XML mode\n      // when completing in JS/CSS snippet in htmlmixed mode. Does not\n      // work for other XML embedded languages (there is no general\n      // way to go from a mixed mode to its current XML state).\n      var replacement;\n      if (inner.mode.name != \"xml\") {\n        if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"javascript\")\n          replacement = head + \"script\";\n        else if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"css\")\n          replacement = head + \"style\";\n        else\n          return CodeMirror.Pass;\n      } else {\n        if (!state.context || !state.context.tagName ||\n            closingTagExists(cm, state.context.tagName, pos, state))\n          return CodeMirror.Pass;\n        replacement = head + state.context.tagName;\n      }\n      if (cm.getLine(pos.line).charAt(tok.end) != \">\") replacement += \">\";\n      replacements[i] = replacement;\n    }\n    cm.replaceSelections(replacements);\n    ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\n        cm.indentLine(ranges[i].head.line);\n  }\n\n  function autoCloseSlash(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    return autoCloseCurrent(cm, true);\n  }\n\n  CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  // If xml-fold is loaded, we use its functionality to try and verify\n  // whether a given tag is actually unclosed.\n  function closingTagExists(cm, tagName, pos, state, newTag) {\n    if (!CodeMirror.scanForClosingTag) return false;\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n    if (!nextClose || nextClose.tag != tagName) return false;\n    var cx = state.context;\n    // If the immediate wrapping context contains onCx instances of\n    // the same tag, a closing tag only exists if there are at least\n    // that many closing tags of that type following.\n    for (var onCx = newTag ? 1 : 0; cx && cx.tagName == tagName; cx = cx.prev) ++onCx;\n    pos = nextClose.to;\n    for (var i = 1; i < onCx; i++) {\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n      if (!next || next.tag != tagName) return false;\n      pos = next.to;\n    }\n    return true;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"/A6h\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"QSKu\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n\n\n/***/ }),\n\n/***/ \"0tR3\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('el-dropdown', {\n    on: {\n      \"command\": _vm.handleCommandDropdown\n    }\n  }, [_c('el-input', {\n    staticClass: \"search-input\",\n    attrs: {\n      \"placeholder\": \"请输入要搜索的题目\",\n      \"icon\": \"search\",\n      \"spellcheck\": \"false\",\n      \"on-icon-click\": _vm._onSearch\n    },\n    on: {\n      \"change\": _vm._onSearch,\n      \"focus\": _vm._onSearch\n    },\n    model: {\n      value: (_vm.mysearch),\n      callback: function($$v) {\n        _vm.mysearch = (typeof $$v === 'string' ? $$v.trim() : $$v)\n      },\n      expression: \"mysearch\"\n    }\n  }), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, [_c('el-dropdown-item', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.dropdownLoading),\n      expression: \"dropdownLoading\"\n    }]\n  }, [_vm._v(\"拼命加载中...\")]), _vm._v(\" \"), _vm._l((_vm.searchResult), function(item, index) {\n    return _c('el-dropdown-item', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (index <= 10 && !_vm.dropdownLoading),\n        expression: \"index <= 10 && !dropdownLoading\"\n      }],\n      key: index,\n      attrs: {\n        \"command\": item.id\n      }\n    }, [_c('span', {\n      staticClass: \"problem-item-title\"\n    }, [_vm._v(_vm._s(item.title))]), _vm._v(\" \"), _c('img', {\n      staticClass: \"problem-item-img\",\n      attrs: {\n        \"width\": \"16\",\n        \"height\": \"16 \",\n        \"src\": \"static/problem.png\"\n      }\n    })])\n  })], 2)], 1)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"2EAN\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".el-dialog .el-dialog__body[data-v-48f25eaf]{padding:10px 20px}.el-dialog .el-dialog__body .text[data-v-48f25eaf]{font-size:18px;font-weight:400}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/base/confirm/confirm.vue\"],\"names\":[],\"mappings\":\"AACA,6CACE,iBAAmB,CACpB,AACD,mDACE,eAAgB,AAChB,eAAiB,CAClB\",\"file\":\"confirm.vue\",\"sourcesContent\":[\"\\n.el-dialog .el-dialog__body[data-v-48f25eaf] {\\n  padding: 10px 20px;\\n}\\n.el-dialog .el-dialog__body .text[data-v-48f25eaf] {\\n  font-size: 18px;\\n  font-weight: 400;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"3CS+\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  props: {\n    text: {\n      type: String,\n      default: ''\n    },\n    confirmBtnText: {\n      type: String,\n      default: '确 定'\n    },\n    cancelBtnText: {\n      type: String,\n      default: '取 消'\n    }\n  },\n  data: function data() {\n    return {\n      visible: false\n    };\n  },\n\n  methods: {\n    show: function show() {\n      this.visible = true;\n    },\n    hide: function hide() {\n      this.visible = false;\n    },\n    confirm: function confirm() {\n      this.hide();\n      this.$emit('confirm');\n    },\n    cancel: function cancel() {\n      this.hide();\n      this.$emit('cancel');\n    }\n  }\n});\n\n/***/ }),\n\n/***/ \"5Ey+\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(\"Zrlr\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);\n\n\n/**\n * Created by qinzhen on 2017/9/17.\n */\nvar Problem = function Problem(_ref) {\n  var id = _ref.id,\n      title = _ref.title,\n      tag = _ref.tag,\n      level = _ref.level,\n      description = _ref.description,\n      accepted = _ref.accepted,\n      submitted = _ref.submitted,\n      like_nums = _ref.like_nums,\n      hate_nums = _ref.hate_nums;\n\n  __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Problem);\n\n  this.id = id;\n  this.title = title;\n  this.tag = tag;\n  this.level = level;\n  this.description = description;\n  this.accepted = accepted;\n  this.submitted = submitted;\n  this.like_nums = like_nums;\n  this.hate_nums = hate_nums;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Problem);\n\n/***/ }),\n\n/***/ \"7Xsf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"vq+x\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  var goSubwordCombo = mac ? \"Ctrl-\" : \"Alt-\";\n\n  cmds[map[goSubwordCombo + \"Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n  cmds[map[goSubwordCombo + \"Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\n  if (mac) map[\"Cmd-Left\"] = \"goLineStartSmart\";\n\n  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\n  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  map[\"Shift-Tab\"] = \"indentLess\";\n\n  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  map[\"Shift-Ctrl-K\"] = \"deleteLine\";\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { return insertLine(cm, false); };\n\n  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))\n        return CodeMirror.Pass\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(range.anchor, dir, \"line\");\n      var newHead = cm.findPosV(range.head, dir, \"line\");\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n\n  var addCursorToLineCombo = mac ? \"Shift-Cmd\" : 'Alt-Ctrl';\n  cmds[map[addCursorToLineCombo + \"Up\"] = \"addCursorToPrevLine\"] = function(cm) { addCursorToSelection(cm, -1); };\n  cmds[map[addCursorToLineCombo + \"Down\"] = \"addCursorToNextLine\"] = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (ranges[i].from() == from && ranges[i].to() == to) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          newRanges.push({anchor: Pos(opening.pos.line, opening.pos.ch + 1),\n                          head: closing.pos});\n          break;\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\n  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[ctrl + \"/\"] = \"toggleCommentIndented\"] = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  if (!mac) map[ctrl + \"T\"] = \"transposeChars\";\n\n  function sortLines(cm, caseSensitive) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\n  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  map[\"Alt-Q\"] = \"wrapLines\";\n\n  var cK = ctrl + \"K \";\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\n  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  var selectLinesCombo = mac ? \"Ctrl-Shift-\" : \"Ctrl-Alt-\";\n  cmds[map[selectLinesCombo + \"Up\"] = \"selectLinesUpward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line > cm.firstLine())\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n      }\n    });\n  };\n  cmds[map[selectLinesCombo + \"Down\"] = \"selectLinesDownward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line < cm.lastLine())\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n      }\n    });\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"J\"] = \"unfoldAll\";\n\n  map[ctrl + \"I\"] = \"findIncremental\";\n  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n  map[ctrl + \"H\"] = \"replace\";\n  map[\"F3\"] = \"findNext\";\n  map[\"Shift-F3\"] = \"findPrev\";\n\n  CodeMirror.normalizeKeyMap(map);\n});\n\n\n/***/ }),\n\n/***/ \"A1IV\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(\"Dd8w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_js_problem__ = __webpack_require__(\"5Ey+\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_axios__ = __webpack_require__(\"mtWM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_js_data__ = __webpack_require__(\"DW9A\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_vuex__ = __webpack_require__(\"NYxO\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  data: function data() {\n    return {\n      mysearch: '',\n      dropdownLoading: false,\n      searchResult: []\n    };\n  },\n\n  methods: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({\n    _onSearch: function _onSearch() {\n      var _this = this;\n\n      if (this.mysearch === '') {\n        this.searchResult = [];\n        return;\n      }\n      this.dropdownLoading = true;\n      console.log('SearchClick');\n      var url = __WEBPACK_IMPORTED_MODULE_3_common_js_data__[\"a\" /* baseUrl */] + '/search';\n      // 清空之前的结果\n      this.searchResult = [];\n      __WEBPACK_IMPORTED_MODULE_2_axios___default.a.post(url, {\n        'target': 'Problem',\n        'content': this.mysearch,\n        'type': 'title'\n      }).then(function (response) {\n        if (response.data.result.length === 0) {\n          _this.searchResult = [{ title: '\\u65E0\\u6CD5\\u67E5\\u8BE2\\u5230\\u542B\\u6709\\u5173\\u952E\\u5B57:' + _this.mysearch + '\\u7684\\u9898\\u76EE' }];\n        } else {\n          _this.searchResult = response.data.result;\n        }\n        _this.dropdownLoading = false;\n      }, function (response) {\n        console.log(response);\n        _this._onSearch();\n      });\n    },\n    handleCommandDropdown: function handleCommandDropdown(command) {\n      this.setProblem(new __WEBPACK_IMPORTED_MODULE_1_common_js_problem__[\"a\" /* default */]({\n        id: command\n      }));\n      this.$router.push('/home/problem');\n    }\n  }, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_vuex__[\"a\" /* mapMutations */])({\n    setProblem: 'SET_PROBLEM'\n  }))\n});\n\n/***/ }),\n\n/***/ \"BUZr\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manage_problems_vue__ = __webpack_require__(\"kYSO\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1ffcf786_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_manage_problems_vue__ = __webpack_require__(\"oxMS\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"S1i8\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-1ffcf786\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manage_problems_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1ffcf786_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_manage_problems_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"CK2l\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"RkhK\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../dialog/dialog\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function searchOverlay(query, caseInsensitive) {\n    if (typeof query == \"string\")\n      query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\"), caseInsensitive ? \"gi\" : \"g\");\n    else if (!query.global)\n      query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\n\n    return {token: function(stream) {\n      query.lastIndex = stream.pos;\n      var match = query.exec(stream.string);\n      if (match && match.index == stream.pos) {\n        stream.pos += match[0].length || 1;\n        return \"searching\";\n      } else if (match) {\n        stream.pos = match.index;\n      } else {\n        stream.skipToEnd();\n      }\n    }};\n  }\n\n  function SearchState() {\n    this.posFrom = this.posTo = this.lastQuery = this.query = null;\n    this.overlay = null;\n  }\n\n  function getSearchState(cm) {\n    return cm.state.search || (cm.state.search = new SearchState());\n  }\n\n  function queryCaseInsensitive(query) {\n    return typeof query == \"string\" && query == query.toLowerCase();\n  }\n\n  function getSearchCursor(cm, query, pos) {\n    // Heuristic: if the query string is all lowercase, do a case insensitive search.\n    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});\n  }\n\n  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {\n    cm.openDialog(text, onEnter, {\n      value: deflt,\n      selectValueOnOpen: true,\n      closeOnEnter: false,\n      onClose: function() { clearSearch(cm); },\n      onKeyDown: onKeyDown\n    });\n  }\n\n  function dialog(cm, text, shortText, deflt, f) {\n    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});\n    else f(prompt(shortText, deflt));\n  }\n\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n\n  function parseString(string) {\n    return string.replace(/\\\\(.)/g, function(_, ch) {\n      if (ch == \"n\") return \"\\n\"\n      if (ch == \"r\") return \"\\r\"\n      return ch\n    })\n  }\n\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\n    if (isRE) {\n      try { query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\"); }\n      catch(e) {} // Not a regular expression after all, do a string search\n    } else {\n      query = parseString(query)\n    }\n    if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\n      query = /x^/;\n    return query;\n  }\n\n  var queryDialog =\n    '<span class=\"CodeMirror-search-label\">Search:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n\n  function startSearch(cm, state, query) {\n    state.queryText = query;\n    state.query = parseQuery(query);\n    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\n    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\n    cm.addOverlay(state.overlay);\n    if (cm.showMatchesOnScrollbar) {\n      if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\n    }\n  }\n\n  function doSearch(cm, rev, persistent, immediate) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    var q = cm.getSelection() || state.lastQuery;\n    if (persistent && cm.openDialog) {\n      var hiding = null\n      var searchNext = function(query, event) {\n        CodeMirror.e_stop(event);\n        if (!query) return;\n        if (query != state.queryText) {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n        }\n        if (hiding) hiding.style.opacity = 1\n        findNext(cm, event.shiftKey, function(_, to) {\n          var dialog\n          if (to.line < 3 && document.querySelector &&\n              (dialog = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) &&\n              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, \"window\").top)\n            (hiding = dialog).style.opacity = .4\n        })\n      };\n      persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {\n        var keyName = CodeMirror.keyName(event)\n        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName]\n        if (cmd == \"findNext\" || cmd == \"findPrev\" ||\n          cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\n          CodeMirror.e_stop(event);\n          startSearch(cm, getSearchState(cm), query);\n          cm.execCommand(cmd);\n        } else if (cmd == \"find\" || cmd == \"findPersistent\") {\n          CodeMirror.e_stop(event);\n          searchNext(query, event);\n        }\n      });\n      if (immediate && q) {\n        startSearch(cm, state, q);\n        findNext(cm, rev);\n      }\n    } else {\n      dialog(cm, queryDialog, \"Search for:\", q, function(query) {\n        if (query && !state.query) cm.operation(function() {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n          findNext(cm, rev);\n        });\n      });\n    }\n  }\n\n  function findNext(cm, rev, callback) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n    if (callback) callback(cursor.from(), cursor.to())\n  });}\n\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    state.lastQuery = state.query;\n    if (!state.query) return;\n    state.query = state.queryText = null;\n    cm.removeOverlay(state.overlay);\n    if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n  });}\n\n  var replaceQueryDialog =\n    ' <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n  var replacementQueryDialog = '<span class=\"CodeMirror-search-label\">With:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/>';\n  var doReplaceConfirm = '<span class=\"CodeMirror-search-label\">Replace?</span> <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>';\n\n  function replaceAll(cm, query, text) {\n    cm.operation(function() {\n      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {\n        if (typeof query != \"string\") {\n          var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n          cursor.replace(text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n        } else cursor.replace(text);\n      }\n    });\n  }\n\n  function replace(cm, all) {\n    if (cm.getOption(\"readOnly\")) return;\n    var query = cm.getSelection() || getSearchState(cm).lastQuery;\n    var dialogText = '<span class=\"CodeMirror-search-label\">' + (all ? 'Replace all:' : 'Replace:') + '</span>';\n    dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, replacementQueryDialog, \"Replace with:\", \"\", function(text) {\n        text = parseString(text)\n        if (all) {\n          replaceAll(cm, query, text)\n        } else {\n          clearSearch(cm);\n          var cursor = getSearchCursor(cm, query, cm.getCursor(\"from\"));\n          var advance = function() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = getSearchCursor(cm, query);\n              if (!(match = cursor.findNext()) ||\n                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});\n            confirmDialog(cm, doReplaceConfirm, \"Replace?\",\n                          [function() {doReplace(match);}, advance,\n                           function() {replaceAll(cm, query, text)}]);\n          };\n          var doReplace = function(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n            advance();\n          };\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};\n  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};\n  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n});\n\n\n/***/ }),\n\n/***/ \"EKta\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n/***/ }),\n\n/***/ \"ELu2\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(\"mvHQ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends__ = __webpack_require__(\"Dd8w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_codemirror_mode_javascript_javascript__ = __webpack_require__(\"5IAE\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_codemirror_mode_javascript_javascript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_codemirror_mode_javascript_javascript__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_codemirror_mode_go_go__ = __webpack_require__(\"CQVp\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_codemirror_mode_go_go___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_codemirror_mode_go_go__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_codemirror_mode_python_python__ = __webpack_require__(\"tWbI\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_codemirror_mode_python_python___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_codemirror_mode_python_python__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_codemirror_mode_ruby_ruby__ = __webpack_require__(\"uOPQ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_codemirror_mode_ruby_ruby___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_codemirror_mode_ruby_ruby__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_codemirror_mode_clike_clike__ = __webpack_require__(\"6S2o\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_codemirror_mode_clike_clike___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_codemirror_mode_clike_clike__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_codemirror_theme_ambiance_css__ = __webpack_require__(\"vX90\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_codemirror_theme_ambiance_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_codemirror_theme_ambiance_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_codemirror_theme_base16_dark_css__ = __webpack_require__(\"jGSh\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_codemirror_theme_base16_dark_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_codemirror_theme_base16_dark_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_codemirror_theme_cobalt_css__ = __webpack_require__(\"t9xi\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_codemirror_theme_cobalt_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_codemirror_theme_cobalt_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_light_css__ = __webpack_require__(\"Y0SK\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_light_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_codemirror_theme_paraiso_light_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_codemirror_theme_paraiso_dark_css__ = __webpack_require__(\"BR0Y\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_codemirror_theme_paraiso_dark_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_codemirror_theme_paraiso_dark_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_codemirror_theme_rubyblue_css__ = __webpack_require__(\"0tbE\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_codemirror_theme_rubyblue_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_codemirror_theme_rubyblue_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_codemirror_theme_solarized_css__ = __webpack_require__(\"Xdwu\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_codemirror_theme_solarized_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_codemirror_theme_solarized_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_codemirror_theme_mbo_css__ = __webpack_require__(\"1XTk\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_codemirror_theme_mbo_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_codemirror_theme_mbo_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_vuex__ = __webpack_require__(\"NYxO\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_common_js_data__ = __webpack_require__(\"DW9A\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_axios__ = __webpack_require__(\"mtWM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_axios__);\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n// require active-line.js\n__webpack_require__(\"aGTD\");\n\n// closebrackets\n__webpack_require__(\"aX1R\");\n\n// styleSelectedText\n__webpack_require__(\"U80t\");\n__webpack_require__(\"c+I8\");\n\n// hint\n__webpack_require__(\"jQeI\");\n__webpack_require__(\"Mixr\");\n__webpack_require__(\"aGTD\");\n\n// highlightSelectionMatches\n__webpack_require__(\"QSKu\");\n__webpack_require__(\"/A6h\");\n__webpack_require__(\"c+I8\");\n__webpack_require__(\"OkRY\");\n\n// keyMap\n__webpack_require__(\"6S2o\");\n__webpack_require__(\"vq+x\");\n__webpack_require__(\"Z6qg\");\n__webpack_require__(\"RkhK\");\n__webpack_require__(\"LxZp\");\n__webpack_require__(\"c+I8\");\n__webpack_require__(\"CK2l\");\n__webpack_require__(\"7Xsf\");\n__webpack_require__(\"tjx/\");\n__webpack_require__(\"Hyg2\");\n\n// foldGutter\n__webpack_require__(\"Yokd\");\n__webpack_require__(\"fo6W\");\n__webpack_require__(\"soCA\");\n__webpack_require__(\"THjC\");\n__webpack_require__(\"Kk9m\");\n__webpack_require__(\"U3HU\");\n__webpack_require__(\"dxBS\");\n__webpack_require__(\"TQy8\");\n\n// autoCloseTags\n__webpack_require__(\"+/ra\");\n\n// 语法高亮，自行替换为你需要的语言\n\n\n\n\n\n\n// Theme\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  props: {\n    isEdit: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function data() {\n    return {\n      form: {\n        title: '',\n        description: '',\n        level: 1,\n        tag: '',\n        program: '',\n        input: '',\n        output: '',\n        checkLanguageList: ['C']\n      },\n      toolbars: {\n        bold: true, // 粗体\n        italic: true, // 斜体\n        header: true, // 标题\n        underline: true, // 下划线\n        strikethrough: true, // 中划线\n        mark: true, // 标记\n        quote: true, // 引用\n        ol: true, // 有序列表\n        ul: true, // 无序列表\n        link: true, // 链接\n        code: true, // code\n        table: true, // 表格\n        undo: true, // 上一步\n        redo: true, // 下一步\n        trash: true, // 清空\n        alignleft: true, // 左对齐\n        aligncenter: true, // 居中\n        alignright: true, // 右对齐\n        preview: true // 预览\n      },\n      editorOptions1: {\n        tabSize: 4,\n        mode: 'text/x-csrc',\n        theme: 'default',\n        lineNumbers: true,\n        line: true,\n        keyMap: 'sublime',\n        foldGutter: true,\n        gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n        // 选中文本自动高亮，及高亮方式\n        styleSelectedText: true,\n        highlightSelectionMatches: { showToken: /\\w/, annotateScrollbar: true\n          // 如果有hint方面的配置，也应该出现在这里\n        } },\n      editorOptions2: {\n        tabSize: 4,\n        mode: 'text/x-csrc',\n        theme: 'default',\n        lineNumbers: true,\n        line: true,\n        keyMap: 'sublime',\n        foldGutter: true,\n        gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n        // 选中文本自动高亮，及高亮方式\n        styleSelectedText: true,\n        highlightSelectionMatches: { showToken: /\\w/, annotateScrollbar: true\n          // 如果有hint方面的配置，也应该出现在这里\n        } },\n      editorThemes: __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"d\" /* editorThemes */],\n      selectTheme: __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"d\" /* editorThemes */][0],\n      Languages: __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"e\" /* languages */],\n      selectLanguage: __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"e\" /* languages */][0],\n      editorModes: __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"f\" /* editorModes */],\n      code: '',\n      templetC: { value: 'c', text: 'C', defaultCode: '' },\n      templetCpp: { value: 'cpp', text: 'C++', defaultCode: '' },\n      templetCsharp: { value: 'csharp', text: 'C#', defaultCode: '' },\n      templetJava: { value: 'java', text: 'Java', defaultCode: '' },\n      templetPython: { value: 'python3', text: 'Python3', defaultCode: '' },\n      templetJs: { value: 'javascript', text: 'JavaScript', defaultCode: '' },\n      templetRuby: { value: 'ruby', text: 'Ruby', defaultCode: '' },\n      templetGolang: { value: 'golang', text: 'Go', defaultCode: '' },\n      newTitle: ''\n    };\n  },\n\n  methods: __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({\n    quit: function quit() {\n      this._clearAllData();\n      this.$emit('editFinish');\n    },\n    clickBtn: function clickBtn() {\n      var _this = this;\n\n      var Base64 = __webpack_require__(\"xrTZ\").Base64;\n      //把最后一次模板templet加上\n      this._addTemplet();\n      var array = this._pushALLTemplets();\n      console.log(array);\n      var resultTemplets = [];\n\n      var _loop = function _loop(i) {\n        resultTemplets.push(array.find(function (item) {\n          return item.text === _this.form.checkLanguageList[i];\n        }));\n      };\n\n      for (var i = 0; i < this.form.checkLanguageList.length; i++) {\n        _loop(i);\n      }\n      //console.log(resultTemplets)\n      console.log(this.isEdit);\n\n      if (this.isEdit) {\n        //修改题目\n        console.log('修改题目');\n        this.reviseProblem(Base64, resultTemplets);\n      } else {\n        //创建题目\n        this.setupProblem(Base64, resultTemplets);\n      }\n    },\n    setupProblem: function setupProblem(Base64, resultTemplets) {\n      var _this2 = this;\n\n      var url = __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"a\" /* baseUrl */] + '/problems';\n      __WEBPACK_IMPORTED_MODULE_17_axios___default.a.post(url, {\n        title: this.form.title,\n        description: this.form.description,\n        level: this.form.level + '',\n        tag: this.form.tag,\n        program: Base64.encode(this.form.program),\n        code: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(resultTemplets),\n        input: Base64.encode(this.form.input),\n        output: Base64.encode(this.form.output)\n      }).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this2.$notify({\n            title: '成功',\n            message: '\\u6210\\u529F\\u521B\\u5EFA\\u9898\\u76EE:' + response.data.result[0].title,\n            type: 'success'\n          });\n          //成功后清除数据\n          _this2._clearAllData();\n          _this2.$emit('editFinish');\n        } else if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"c\" /* MSG_NO */]) {\n          _this2.$notify({\n            title: '创建失败',\n            message: '' + response.data.error,\n            type: 'error'\n          });\n        }\n      }, function (response) {});\n    },\n    reviseProblem: function reviseProblem(Base64, resultTemplets) {\n      var url = __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id;\n      var resultTitle = this.form.title === this.newTitle ? null : this.form.title;\n      if (resultTitle) {\n        this.reviseProblemWithTitle(url, Base64, resultTemplets);\n      } else {\n        this.reviseProblemWithoutTitle(url, Base64, resultTemplets);\n      }\n    },\n    reviseProblemWithTitle: function reviseProblemWithTitle(url, Base64, resultTemplets) {\n      var _this3 = this;\n\n      __WEBPACK_IMPORTED_MODULE_17_axios___default.a.put(url, {\n        title: this.form.title,\n        description: this.form.description,\n        level: this.form.level + '',\n        tag: this.form.tag,\n        program: Base64.encode(this.form.program),\n        code: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(resultTemplets),\n        input: Base64.encode(this.form.input),\n        output: Base64.encode(this.form.output)\n      }).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this3.$notify({\n            title: '成功',\n            message: '修改题目成功',\n            type: 'success'\n          });\n          //成功后清除数据\n          _this3._clearAllData();\n          _this3.$emit('editFinish');\n        } else if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"c\" /* MSG_NO */]) {\n          _this3.$notify({\n            title: '修改失败',\n            message: '' + response.data.error,\n            type: 'error'\n          });\n        }\n      }, function (response) {});\n    },\n    reviseProblemWithoutTitle: function reviseProblemWithoutTitle(url, Base64, resultTemplets) {\n      var _this4 = this;\n\n      __WEBPACK_IMPORTED_MODULE_17_axios___default.a.put(url, {\n        description: this.form.description,\n        level: this.form.level + '',\n        tag: this.form.tag,\n        program: Base64.encode(this.form.program),\n        code: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(resultTemplets),\n        input: Base64.encode(this.form.input),\n        output: Base64.encode(this.form.output)\n      }).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this4.$notify({\n            title: '成功',\n            message: '修改题目成功',\n            type: 'success'\n          });\n          //成功后清除数据\n          _this4._clearAllData();\n          _this4.$emit('editFinish');\n        } else if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"c\" /* MSG_NO */]) {\n          _this4.$notify({\n            title: '修改失败',\n            message: '' + response.data.error,\n            type: 'error'\n          });\n        }\n      }, function (response) {});\n    },\n    _clearAllData: function _clearAllData() {\n      //清除所有数据 回到默认状态\n      this.form.title = '';\n      this.form.description = '';\n      this.form.level = 1;\n      this.form.tag = '';\n      this.form.program = '';\n      this.form.input = '';\n      this.form.output = '';\n      this.form.checkLanguageList = ['C'];\n      this.code = '';\n      this.selectTheme = __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"d\" /* editorThemes */][0];\n      this.selectLanguage = __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"e\" /* languages */][0];\n      this.editorOptions2.mode = this.editorModes[0];\n      this.editorOptions2.theme = this.selectTheme;\n      this.templetC = { value: 'c', text: 'C', defaultCode: '' };\n      this.templetCpp = { value: 'cpp', text: 'C++', defaultCode: '' };\n      this.templetCsharp = { value: 'csharp', text: 'C#', defaultCode: '' };\n      this.templetJava = { value: 'java', text: 'Java', defaultCode: '' };\n      this.templetPython = { value: 'python3', text: 'Python3', defaultCode: '' };\n      this.templetJs = { value: 'javascript', text: 'JavaScript', defaultCode: '' };\n      this.templetRuby = { value: 'ruby', text: 'Ruby', defaultCode: '' };\n      this.templetGolang = { value: 'golang', text: 'Go', defaultCode: ''\n        //最后清空vuex中的Templets\n      };this.setTemplets([]);\n    },\n    handleCommandLangage: function handleCommandLangage(index) {\n      var _this5 = this;\n\n      //切换语言\n      console.log('xuan ' + index);\n      this.editorOptions2.mode = this.editorModes[index];\n      this.selectLanguage = this.Languages[index];\n      //如果之前(一次编辑中)写过code   那么code=之前的对应的templet的defaultCode\n      var result = this.templets.find(function (item) {\n        return item && item.text === _this5.selectLanguage;\n      });\n      if (result) {\n        this.code = result.defaultCode;\n      } else {\n        this.code = '';\n      }\n    },\n    dropdownChange: function dropdownChange(isShow) {\n      //当语言下拉菜单状态改变\n      if (isShow) {\n        //当语言下拉菜单展开\n        this._addTemplet();\n        var res = this._pushALLTemplets();\n        //  这里有bug (showPromblemInfo获取了setTemplets 这里又修改了Templets )\n        //   解决：在此之前 每个对应模板加入相应的的数据\n        this.setTemplets(res);\n      }\n    },\n    _pushALLTemplets: function _pushALLTemplets() {\n      //把所有模板集合成一个数组返回\n      var result = [];\n      result.push(this.templetC);\n      result.push(this.templetCpp);\n      result.push(this.templetCsharp);\n      result.push(this.templetJava);\n      result.push(this.templetPython);\n      result.push(this.templetJs);\n      result.push(this.templetRuby);\n      result.push(this.templetGolang);\n      return result;\n    },\n    _addTemplet: function _addTemplet() {\n      //把code加入到当前选中的语言的 对应的语言模板的defaultCode中\n      if (this.selectLanguage === 'C') {\n        this.templetC.defaultCode = this.code;\n      } else if (this.selectLanguage === 'C++') {\n        this.templetCpp.defaultCode = this.code;\n      } else if (this.selectLanguage === 'C#') {\n        this.templetCsharp.defaultCode = this.code;\n      } else if (this.selectLanguage === 'Java') {\n        this.templetJava.defaultCode = this.code;\n      } else if (this.selectLanguage === 'Python3') {\n        this.templetPython.defaultCode = this.code;\n      } else if (this.selectLanguage === 'JavaScript') {\n        this.templetJs.defaultCode = this.code;\n      } else if (this.selectLanguage === 'Ruby') {\n        this.templetRuby.defaultCode = this.code;\n      } else if (this.selectLanguage === 'Go') {\n        this.templetGolang.defaultCode = this.code;\n      }\n    },\n    showPromblemInfo: function showPromblemInfo() {\n      var _this6 = this;\n\n      this._clearAllData();\n      //处于编辑题目模式 先展示出题目信息\n      var url1 = __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id;\n      __WEBPACK_IMPORTED_MODULE_17_axios___default.a.get(url1).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this6.form.title = response.data.result[0].title;\n          _this6.newTitle = response.data.result[0].title;\n          _this6.form.description = response.data.result[0].description;\n          _this6.form.level = response.data.result[0].level;\n          _this6.form.tag = response.data.result[0].tag;\n        }\n      }, function (response) {});\n      var url2 = __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/codes';\n      __WEBPACK_IMPORTED_MODULE_17_axios___default.a.get(url2).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"b\" /* MSG_OK */]) {\n          console.log(JSON.parse(response.data.result[0].code));\n          _this6.setTemplets(JSON.parse(response.data.result[0].code));\n          //templetC templetCpp templetCsharp... 加入对应的数据 明天写。\n          _this6.changeTemplets();\n        }\n      }, function (response) {});\n      this.getProblemStd();\n    },\n    getProblemStd: function getProblemStd() {\n      var _this7 = this;\n\n      var Base64 = __webpack_require__(\"xrTZ\").Base64;\n      var url = __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.problem.id + '/std';\n      __WEBPACK_IMPORTED_MODULE_17_axios___default.a.get(url).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_16_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this7.form.input = Base64.decode(response.data.result[0].input);\n          _this7.form.output = Base64.decode(response.data.result[0].output);\n          _this7.form.program = Base64.decode(response.data.result[0].program);\n          console.log(response.data.result[0]);\n        }\n      }, function (response) {});\n    },\n    changeTemplets: function changeTemplets() {\n      var _this8 = this;\n\n      this.form.checkLanguageList = [];\n      var tempC = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'C';\n        }\n      });\n      if (tempC) {\n        this.templetC = tempC;\n        this.form.checkLanguageList.push(this.templetC.text);\n      }\n\n      var tempCpp = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'C++';\n        }\n      });\n      if (tempCpp) {\n        this.templetCpp = tempCpp;\n        this.form.checkLanguageList.push(this.templetCpp.text);\n      }\n\n      var tempCsharp = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'C#';\n        }\n      });\n      if (tempCsharp) {\n        this.templetCsharp = tempCsharp;\n        this.form.checkLanguageList.push(this.templetCsharp.text);\n      }\n\n      var tempJava = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'Java';\n        }\n      });\n      if (tempJava) {\n        this.templetJava = tempJava;\n        this.form.checkLanguageList.push(this.templetJava.text);\n      }\n      var tempPython = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'Python3';\n        }\n      });\n      if (tempPython) {\n        this.templetPython = tempPython;\n        this.form.checkLanguageList.push(this.templetPython.text);\n      }\n\n      var tempJs = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'JavaScript';\n        }\n      });\n      if (tempJs) {\n        this.templetJs = tempJs;\n        this.form.checkLanguageList.push(this.templetJs.text);\n      }\n\n      var tempRuby = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'Ruby';\n        }\n      });\n      if (tempRuby) {\n        this.templetRuby = tempRuby;\n        this.form.checkLanguageList.push(this.templetRuby.text);\n      }\n\n      var tempGo = this.templets.find(function (item) {\n        if (item) {\n          return item.text === 'Go';\n        }\n      });\n      if (tempGo) {\n        this.templetGolang = tempGo;\n        this.form.checkLanguageList.push(this.templetGolang.text);\n      }\n\n      this.code = this.templets.find(function (item) {\n        return item && item.text === _this8.selectLanguage;\n      }).defaultCode || '';\n    },\n    calcBtnText: function calcBtnText() {\n      //计算btn的文字\n      if (this.isEdit) {\n        return '修改题目';\n      } else {\n        return '创建题目';\n      }\n    },\n    handleCommandTheme: function handleCommandTheme(command) {\n      //修改主题\n      this.editorOptions2.theme = command;\n      this.selectTheme = command;\n    }\n  }, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15_vuex__[\"a\" /* mapMutations */])({\n    setTemplets: 'SET_TEMPLETS'\n  })),\n  computed: __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15_vuex__[\"c\" /* mapGetters */])(['problem', 'templets']))\n});\n\n/***/ }),\n\n/***/ \"EuP9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(\"EKta\")\nvar ieee754 = __webpack_require__(\"ujcs\")\nvar isArray = __webpack_require__(\"sOR5\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"DuR2\")))\n\n/***/ }),\n\n/***/ \"HbqP\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manage_problem_edit_vue__ = __webpack_require__(\"ELu2\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_49e52881_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_manage_problem_edit_vue__ = __webpack_require__(\"c2Vz\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"hdeF\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-49e52881\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_manage_problem_edit_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_49e52881_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_manage_problem_edit_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"Hyg2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"c+I8\"), __webpack_require__(\"RkhK\"), __webpack_require__(\"vq+x\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; };\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '['};\n        var selfPaired = {'\\'': true, '\"': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /-?\\d+/g;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        var token;\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0];\n          start = match.index;\n          end = start + token.length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1;\n          var number = parseInt(token) + (increment * actionArgs.repeat);\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          numberStr = number.toString();\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /**\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      var slashes = findUnescapedSlashes(argString) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSlashes(str) {\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySlash(argString) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); };\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n             i++;\n          } else {\n             i+= selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      };\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n            } else {\n                lastChange.changes.push(text);\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    };\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n\n\n/***/ }),\n\n/***/ \"IruO\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('el-dialog', {\n    attrs: {\n      \"title\": \"提示\",\n      \"visible\": _vm.visible\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.visible = $event\n      }\n    }\n  }, [_c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(_vm._s(_vm.text))]), _vm._v(\" \"), _c('span', {\n    staticClass: \"dialog-footer\",\n    slot: \"footer\"\n  }, [_c('el-button', {\n    on: {\n      \"click\": _vm.cancel\n    }\n  }, [_vm._v(_vm._s(_vm.cancelBtnText))]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.confirm\n    }\n  }, [_vm._v(_vm._s(_vm.confirmBtnText))])], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"JM2O\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"2EAN\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"013a4c5f\", content, true);\n\n/***/ }),\n\n/***/ \"Kk9m\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"THjC\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"LxZp\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"RkAk\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"e2c66042\", content, true);\n\n/***/ }),\n\n/***/ \"Mixr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch continue debugger default delete do else false finally for function \" +\n                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"OkRY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"), __webpack_require__(\"/A6h\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query + \"\\\\b\") : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n\n\n/***/ }),\n\n/***/ \"QSKu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"annotateScrollbar\", function(options) {\n    if (typeof options == \"string\") options = {className: options};\n    return new Annotation(this, options);\n  });\n\n  CodeMirror.defineOption(\"scrollButtonHeight\", 0);\n\n  function Annotation(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.buttonHeight = options.scrollButtonHeight || cm.getOption(\"scrollButtonHeight\");\n    this.annotations = [];\n    this.doRedraw = this.doUpdate = null;\n    this.div = cm.getWrapperElement().appendChild(document.createElement(\"div\"));\n    this.div.style.cssText = \"position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none\";\n    this.computeScale();\n\n    function scheduleRedraw(delay) {\n      clearTimeout(self.doRedraw);\n      self.doRedraw = setTimeout(function() { self.redraw(); }, delay);\n    }\n\n    var self = this;\n    cm.on(\"refresh\", this.resizeHandler = function() {\n      clearTimeout(self.doUpdate);\n      self.doUpdate = setTimeout(function() {\n        if (self.computeScale()) scheduleRedraw(20);\n      }, 100);\n    });\n    cm.on(\"markerAdded\", this.resizeHandler);\n    cm.on(\"markerCleared\", this.resizeHandler);\n    if (options.listenForChanges !== false)\n      cm.on(\"change\", this.changeHandler = function() {\n        scheduleRedraw(250);\n      });\n  }\n\n  Annotation.prototype.computeScale = function() {\n    var cm = this.cm;\n    var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) /\n      cm.getScrollerElement().scrollHeight\n    if (hScale != this.hScale) {\n      this.hScale = hScale;\n      return true;\n    }\n  };\n\n  Annotation.prototype.update = function(annotations) {\n    this.annotations = annotations;\n    this.redraw();\n  };\n\n  Annotation.prototype.redraw = function(compute) {\n    if (compute !== false) this.computeScale();\n    var cm = this.cm, hScale = this.hScale;\n\n    var frag = document.createDocumentFragment(), anns = this.annotations;\n\n    var wrapping = cm.getOption(\"lineWrapping\");\n    var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;\n    var curLine = null, curLineObj = null;\n    function getY(pos, top) {\n      if (curLine != pos.line) {\n        curLine = pos.line;\n        curLineObj = cm.getLineHandle(curLine);\n      }\n      if ((curLineObj.widgets && curLineObj.widgets.length) ||\n          (wrapping && curLineObj.height > singleLineH))\n        return cm.charCoords(pos, \"local\")[top ? \"top\" : \"bottom\"];\n      var topY = cm.heightAtLine(curLineObj, \"local\");\n      return topY + (top ? 0 : curLineObj.height);\n    }\n\n    var lastLine = cm.lastLine()\n    if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {\n      var ann = anns[i];\n      if (ann.to.line > lastLine) continue;\n      var top = nextTop || getY(ann.from, true) * hScale;\n      var bottom = getY(ann.to, false) * hScale;\n      while (i < anns.length - 1) {\n        if (anns[i + 1].to.line > lastLine) break;\n        nextTop = getY(anns[i + 1].from, true) * hScale;\n        if (nextTop > bottom + .9) break;\n        ann = anns[++i];\n        bottom = getY(ann.to, false) * hScale;\n      }\n      if (bottom == top) continue;\n      var height = Math.max(bottom - top, 3);\n\n      var elt = frag.appendChild(document.createElement(\"div\"));\n      elt.style.cssText = \"position: absolute; right: 0px; width: \" + Math.max(cm.display.barWidth - 1, 2) + \"px; top: \"\n        + (top + this.buttonHeight) + \"px; height: \" + height + \"px\";\n      elt.className = this.options.className;\n      if (ann.id) {\n        elt.setAttribute(\"annotation-id\", ann.id);\n      }\n    }\n    this.div.textContent = \"\";\n    this.div.appendChild(frag);\n  };\n\n  Annotation.prototype.clear = function() {\n    this.cm.off(\"refresh\", this.resizeHandler);\n    this.cm.off(\"markerAdded\", this.resizeHandler);\n    this.cm.off(\"markerCleared\", this.resizeHandler);\n    if (this.changeHandler) this.cm.off(\"change\", this.changeHandler);\n    this.div.parentNode.removeChild(this.div);\n  };\n});\n\n\n/***/ }),\n\n/***/ \"RkAk\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror-dialog{position:absolute;left:0;right:0;background:inherit;z-index:15;padding:.1em .8em;overflow:hidden;color:inherit}.CodeMirror-dialog-top{border-bottom:1px solid #eee;top:0}.CodeMirror-dialog-bottom{border-top:1px solid #eee;bottom:0}.CodeMirror-dialog input{border:none;outline:none;background:transparent;width:20em;color:inherit;font-family:monospace}.CodeMirror-dialog button{font-size:70%}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/dialog/dialog.css\"],\"names\":[],\"mappings\":\"AAAA,mBACE,kBAAmB,AACnB,OAAQ,AAAC,QAAS,AAClB,mBAAoB,AACpB,WAAY,AACZ,kBAAmB,AACnB,gBAAiB,AACjB,aAAe,CAChB,AAED,uBACE,6BAA8B,AAC9B,KAAO,CACR,AAED,0BACE,0BAA2B,AAC3B,QAAU,CACX,AAED,yBACE,YAAa,AACb,aAAc,AACd,uBAAwB,AACxB,WAAY,AACZ,cAAe,AACf,qBAAuB,CACxB,AAED,0BACE,aAAe,CAChB\",\"file\":\"dialog.css\",\"sourcesContent\":[\".CodeMirror-dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n\\n.CodeMirror-dialog-top {\\n  border-bottom: 1px solid #eee;\\n  top: 0;\\n}\\n\\n.CodeMirror-dialog-bottom {\\n  border-top: 1px solid #eee;\\n  bottom: 0;\\n}\\n\\n.CodeMirror-dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\\n\\n.CodeMirror-dialog button {\\n  font-size: 70%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"RkhK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n\n\n/***/ }),\n\n/***/ \"RrKZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".el-dropdown .el-input[data-v-2d96e4b2]{width:500px}.el-dropdown-menu__item[data-v-2d96e4b2]{width:auto}.el-dropdown-menu__item .problem-item-title[data-v-2d96e4b2]{display:inline-block}.el-dropdown-menu__item .problem-item-img[data-v-2d96e4b2]{float:right;margin-top:10px}.el-dropdown-menu[data-v-2d96e4b2]{width:500px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/search/search.vue\"],\"names\":[],\"mappings\":\"AACA,wCACE,WAAa,CACd,AACD,yCACE,UAAY,CACb,AACD,6DACE,oBAAsB,CACvB,AACD,2DACE,YAAa,AACb,eAAiB,CAClB,AACD,mCACE,WAAa,CACd\",\"file\":\"search.vue\",\"sourcesContent\":[\"\\n.el-dropdown .el-input[data-v-2d96e4b2] {\\n  width: 500px;\\n}\\n.el-dropdown-menu__item[data-v-2d96e4b2] {\\n  width: auto;\\n}\\n.el-dropdown-menu__item .problem-item-title[data-v-2d96e4b2] {\\n  display: inline-block;\\n}\\n.el-dropdown-menu__item .problem-item-img[data-v-2d96e4b2] {\\n  float: right;\\n  margin-top: 10px;\\n}\\n.el-dropdown-menu[data-v-2d96e4b2] {\\n  width: 500px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"S1i8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"qm6i\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"a0ec5c32\", content, true);\n\n/***/ }),\n\n/***/ \"THjC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n\n\n/***/ }),\n\n/***/ \"TQy8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter), end;\n      if (!openTag || iter.line != start.line || !(end = toTagEnd(iter))) return;\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && {from: startPos, to: endPos.from};\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n\n\n/***/ }),\n\n/***/ \"U3HU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction lineIndent(cm, lineNo) {\n  var text = cm.getLine(lineNo)\n  var spaceTo = text.search(/\\S/)\n  if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))\n    return -1\n  return CodeMirror.countColumn(text, null, cm.getOption(\"tabSize\"))\n}\n\nCodeMirror.registerHelper(\"fold\", \"indent\", function(cm, start) {\n  var myIndent = lineIndent(cm, start.line)\n  if (myIndent < 0) return\n  var lastLineInFold = null\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    var indent = lineIndent(cm, i)\n    if (indent == -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) return {\n    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n  };\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"U80t\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    if (cm.state.markedSelection)\n      cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n\n\n/***/ }),\n\n/***/ \"XEAW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_confirm_vue__ = __webpack_require__(\"3CS+\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_48f25eaf_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_confirm_vue__ = __webpack_require__(\"IruO\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"JM2O\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-48f25eaf\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_confirm_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_48f25eaf_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_confirm_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"YOyO\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_search_vue__ = __webpack_require__(\"A1IV\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d96e4b2_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_search_vue__ = __webpack_require__(\"0tR3\");\nfunction injectStyle (ssrContext) {\n  __webpack_require__(\"yGpH\")\n}\nvar normalizeComponent = __webpack_require__(\"VU/8\")\n/* script */\n\n/* template */\n\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-2d96e4b2\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_search_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2d96e4b2_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_node_modules_vue_loader_lib_selector_type_template_index_0_search_vue__[\"a\" /* default */],\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ \"Yokd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"engA\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"da13b76a\", content, true);\n\n/***/ }),\n\n/***/ \"Z6qg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  // Rough heuristic to try and detect lines that are part of multi-line string\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode()\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\n    if (open == -1) return false\n    var endLine = end == start ? startLine : self.getLine(end)\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    if (close == -1 && start != end) {\n      endLine = self.getLine(--end);\n      close = endLine.indexOf(endString);\n    }\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\n    if (close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n/***/ }),\n\n/***/ \"aGTD\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var WRAP_CLASS = \"CodeMirror-activeline\";\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\n  var GUTT_CLASS = \"CodeMirror-activeline-gutter\";\n\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n    var prev = old == CodeMirror.Init ? false : old;\n    if (val == prev) return\n    if (prev) {\n      cm.off(\"beforeSelectionChange\", selectionChange);\n      clearActiveLines(cm);\n      delete cm.state.activeLines;\n    }\n    if (val) {\n      cm.state.activeLines = [];\n      updateActiveLines(cm, cm.listSelections());\n      cm.on(\"beforeSelectionChange\", selectionChange);\n    }\n  });\n\n  function clearActiveLines(cm) {\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\n      cm.removeLineClass(cm.state.activeLines[i], \"wrap\", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"background\", BACK_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"gutter\", GUTT_CLASS);\n    }\n  }\n\n  function sameArray(a, b) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++)\n      if (a[i] != b[i]) return false;\n    return true;\n  }\n\n  function updateActiveLines(cm, ranges) {\n    var active = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var option = cm.getOption(\"styleActiveLine\");\n      if (typeof option == \"object\" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n        continue\n      var line = cm.getLineHandleVisualStart(range.head.line);\n      if (active[active.length - 1] != line) active.push(line);\n    }\n    if (sameArray(cm.state.activeLines, active)) return;\n    cm.operation(function() {\n      clearActiveLines(cm);\n      for (var i = 0; i < active.length; i++) {\n        cm.addLineClass(active[i], \"wrap\", WRAP_CLASS);\n        cm.addLineClass(active[i], \"background\", BACK_CLASS);\n        cm.addLineClass(active[i], \"gutter\", GUTT_CLASS);\n      }\n      cm.state.activeLines = active;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLines(cm, sel.ranges);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"aX1R\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var defaults = {\n    pairs: \"()[]{}''\\\"\\\"\",\n    triples: \"\",\n    explode: \"[]{}\"\n  };\n\n  var Pos = CodeMirror.Pos;\n\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.removeKeyMap(keyMap);\n      cm.state.closeBrackets = null;\n    }\n    if (val) {\n      cm.state.closeBrackets = val;\n      cm.addKeyMap(keyMap);\n    }\n  });\n\n  function getOption(conf, name) {\n    if (name == \"pairs\" && typeof conf == \"string\") return conf;\n    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\n    return defaults[name];\n  }\n\n  var bind = defaults.pairs + \"`\";\n  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n  for (var i = 0; i < bind.length; i++)\n    keyMap[\"'\" + bind.charAt(i) + \"'\"] = handler(bind.charAt(i));\n\n  function handler(ch) {\n    return function(cm) { return handleChar(cm, ch); };\n  }\n\n  function getConfig(cm) {\n    var deflt = cm.state.closeBrackets;\n    if (!deflt || deflt.override) return deflt;\n    var mode = cm.getModeAt(cm.getCursor());\n    return mode.closeBrackets || deflt;\n  }\n\n  function handleBackspace(cm) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var cur = ranges[i].head;\n      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), \"+delete\");\n    }\n  }\n\n  function handleEnter(cm) {\n    var conf = getConfig(cm);\n    var explode = conf && getOption(conf, \"explode\");\n    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    cm.operation(function() {\n      cm.replaceSelection(\"\\n\\n\", null);\n      cm.execCommand(\"goCharLeft\");\n      ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var line = ranges[i].head.line;\n        cm.indentLine(line, null, true);\n        cm.indentLine(line + 1, null, true);\n      }\n    });\n  }\n\n  function contractSelection(sel) {\n    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n  }\n\n  function handleChar(cm, ch) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var pos = pairs.indexOf(ch);\n    if (pos == -1) return CodeMirror.Pass;\n    var triples = getOption(conf, \"triples\");\n\n    var identical = pairs.charAt(pos + 1) == ch;\n    var ranges = cm.listSelections();\n    var opening = pos % 2 == 0;\n\n    var type;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], cur = range.head, curType;\n      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n      if (opening && !range.empty()) {\n        curType = \"surround\";\n      } else if ((identical || !opening) && next == ch) {\n        if (identical && stringStartsAfter(cm, cur))\n          curType = \"both\";\n        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n          curType = \"skipThree\";\n        else\n          curType = \"skip\";\n      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&\n                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {\n        curType = \"addFour\";\n      } else if (identical) {\n        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = \"both\";\n        else return CodeMirror.Pass;\n      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||\n                             isClosingBracket(next, pairs) ||\n                             /\\s/.test(next))) {\n        curType = \"both\";\n      } else {\n        return CodeMirror.Pass;\n      }\n      if (!type) type = curType;\n      else if (type != curType) return CodeMirror.Pass;\n    }\n\n    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n    cm.operation(function() {\n      if (type == \"skip\") {\n        cm.execCommand(\"goCharRight\");\n      } else if (type == \"skipThree\") {\n        for (var i = 0; i < 3; i++)\n          cm.execCommand(\"goCharRight\");\n      } else if (type == \"surround\") {\n        var sels = cm.getSelections();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = left + sels[i] + right;\n        cm.replaceSelections(sels, \"around\");\n        sels = cm.listSelections().slice();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = contractSelection(sels[i]);\n        cm.setSelections(sels);\n      } else if (type == \"both\") {\n        cm.replaceSelection(left + right, null);\n        cm.triggerElectric(left + right);\n        cm.execCommand(\"goCharLeft\");\n      } else if (type == \"addFour\") {\n        cm.replaceSelection(left + left + left + left, \"before\");\n        cm.execCommand(\"goCharRight\");\n      }\n    });\n  }\n\n  function isClosingBracket(ch, pairs) {\n    var pos = pairs.lastIndexOf(ch);\n    return pos > -1 && pos % 2 == 1;\n  }\n\n  function charsAround(cm, pos) {\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n                          Pos(pos.line, pos.ch + 1));\n    return str.length == 2 ? str : null;\n  }\n\n  // Project the token type that will exists after the given char is\n  // typed, and use it to determine whether it would cause the start\n  // of a string token.\n  function enteringString(cm, pos, ch) {\n    var line = cm.getLine(pos.line);\n    var token = cm.getTokenAt(pos);\n    if (/\\bstring2?\\b/.test(token.type) || stringStartsAfter(cm, pos)) return false;\n    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\n    stream.pos = stream.start = token.start;\n    for (;;) {\n      var type1 = cm.getMode().token(stream, token.state);\n      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\n      stream.start = stream.pos;\n    }\n  }\n\n  function stringStartsAfter(cm, pos) {\n    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))\n    return /\\bstring/.test(token.type) && token.start == pos.ch\n  }\n});\n\n\n/***/ }),\n\n/***/ \"c+I8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureGlobal(regexp) {\n    return regexp.global ? regexp : new RegExp(regexp.source, regexpFlags(regexp) + \"g\")\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (end.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureGlobal(query)\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n\n\n/***/ }),\n\n/***/ \"c2Vz\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"problem-edit\"\n  }, [_c('div', {\n    staticClass: \"panel\"\n  }, [_c('div', {\n    staticClass: \"panel-heading\"\n  }, [_c('i', {\n    staticClass: \"el-icon-arrow-left\",\n    on: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.quit($event)\n      }\n    }\n  }), _vm._v(\" \"), _c('h3', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.isEdit),\n      expression: \"!isEdit\"\n    }],\n    staticClass: \"panel-title\"\n  }, [_vm._v(\"创建题目\")]), _vm._v(\" \"), _c('h3', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.isEdit),\n      expression: \"isEdit\"\n    }],\n    staticClass: \"panel-title\"\n  }, [_vm._v(\"修改题目(ID:\" + _vm._s(_vm.problem.id) + \")\")]), _vm._v(\" \"), _c('el-tag', {\n    staticClass: \"quit-tag\",\n    attrs: {\n      \"type\": \"danger\"\n    },\n    nativeOn: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.quit($event)\n      }\n    }\n  }, [_vm._v(\"退出\")])], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"panel-body\"\n  }, [_c('el-form', {\n    ref: \"form\",\n    attrs: {\n      \"model\": _vm.form,\n      \"label-width\": \"80px\"\n    }\n  }, [_c('el-form-item', {\n    attrs: {\n      \"label\": \"题目标题\"\n    }\n  }, [_c('el-input', {\n    staticClass: \"short-input\",\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"size\": \"small\"\n    },\n    model: {\n      value: (_vm.form.title),\n      callback: function($$v) {\n        _vm.form.title = $$v\n      },\n      expression: \"form.title\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"题目标签\"\n    }\n  }, [_c('el-input', {\n    staticClass: \"short-input\",\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"size\": \"small\"\n    },\n    model: {\n      value: (_vm.form.tag),\n      callback: function($$v) {\n        _vm.form.tag = $$v\n      },\n      expression: \"form.tag\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"题目难度\"\n    }\n  }, [_c('el-radio-group', {\n    model: {\n      value: (_vm.form.level),\n      callback: function($$v) {\n        _vm.form.level = $$v\n      },\n      expression: \"form.level\"\n    }\n  }, [_c('el-radio', {\n    attrs: {\n      \"label\": 1\n    }\n  }, [_vm._v(\"1\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 2\n    }\n  }, [_vm._v(\"2\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 3\n    }\n  }, [_vm._v(\"3\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 4\n    }\n  }, [_vm._v(\"4\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 5\n    }\n  }, [_vm._v(\"5\")])], 1)], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"题目描述\"\n    }\n  }, [_c('mavon-editor', {\n    attrs: {\n      \"default_open\": \"edit\",\n      \"toolbars\": _vm.toolbars\n    },\n    model: {\n      value: (_vm.form.description),\n      callback: function($$v) {\n        _vm.form.description = $$v\n      },\n      expression: \"form.description\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"官方程序代码\"\n    }\n  }, [_c('div', {\n    staticClass: \"program-edit\"\n  }, [_c('codemirror', {\n    staticClass: \"program-edit-inner\",\n    attrs: {\n      \"options\": _vm.editorOptions1\n    },\n    model: {\n      value: (_vm.form.program),\n      callback: function($$v) {\n        _vm.form.program = $$v\n      },\n      expression: \"form.program\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"输入样例\"\n    }\n  }, [_c('el-input', {\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"type\": \"textarea\",\n      \"rows\": 5,\n      \"placeholder\": \"Enter a sample input testcase\"\n    },\n    model: {\n      value: (_vm.form.input),\n      callback: function($$v) {\n        _vm.form.input = $$v\n      },\n      expression: \"form.input\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"输出样例\"\n    }\n  }, [_c('el-input', {\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"type\": \"textarea\",\n      \"rows\": 5,\n      \"placeholder\": \"Enter a sample output testcase\"\n    },\n    model: {\n      value: (_vm.form.output),\n      callback: function($$v) {\n        _vm.form.output = $$v\n      },\n      expression: \"form.output\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"模板选择\"\n    }\n  }, [_c('el-checkbox-group', {\n    model: {\n      value: (_vm.form.checkLanguageList),\n      callback: function($$v) {\n        _vm.form.checkLanguageList = $$v\n      },\n      expression: \"form.checkLanguageList\"\n    }\n  }, _vm._l((_vm.Languages), function(item, index) {\n    return _c('el-checkbox', {\n      key: index,\n      attrs: {\n        \"label\": item\n      }\n    })\n  }))], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"editor-wrapper\"\n  }, [_c('div', {\n    staticClass: \"dropdown-wrapper\"\n  }, [_c('el-dropdown', {\n    staticClass: \"language-dropdown\",\n    attrs: {\n      \"trigger\": \"click\",\n      \"menu-align\": \"start\"\n    },\n    on: {\n      \"command\": _vm.handleCommandLangage,\n      \"visible-change\": _vm.dropdownChange\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\",\n      \"size\": \"small\"\n    }\n  }, [_vm._v(_vm._s(_vm.selectLanguage)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.Languages), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": index\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n                \")])\n  }))], 1), _vm._v(\" \"), _c('el-dropdown', {\n    staticClass: \"el-dropdown-theme\",\n    attrs: {\n      \"menu-align\": \"start\",\n      \"trigger\": \"click\"\n    },\n    on: {\n      \"command\": _vm.handleCommandTheme\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"success\",\n      \"size\": \"small\"\n    }\n  }, [_vm._v(\"\\n                \" + _vm._s(_vm.selectTheme)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.editorThemes), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": item\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n                \")])\n  }))], 1)], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"editor\"\n  }, [_c('codemirror', {\n    ref: \"myEditor\",\n    attrs: {\n      \"options\": _vm.editorOptions2\n    },\n    model: {\n      value: (_vm.code),\n      callback: function($$v) {\n        _vm.code = $$v\n      },\n      expression: \"code\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"setup-btn\",\n    attrs: {\n      \"type\": \"success\"\n    },\n    domProps: {\n      \"textContent\": _vm._s(_vm.calcBtnText())\n    },\n    on: {\n      \"click\": _vm.clickBtn\n    }\n  })], 1)], 1)], 1)])])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"drNd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".problem-edit .panel[data-v-49e52881]{border-radius:5px;margin-bottom:20px;background-color:#fff;border:1px solid #ddd;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.problem-edit .panel .panel-heading[data-v-49e52881]{padding:10px 15px;color:#333;background-color:#f5f5f5;border-color:#ddd;border-top-left-radius:5px;border-top-right-radius:5px;border-bottom:1px solid transparent}.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881]{color:#b0c4de}.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881]:hover{cursor:pointer}.problem-edit .panel .panel-heading .panel-title[data-v-49e52881]{display:inline-block;margin-left:5px;margin-top:0;margin-bottom:0;font-size:18px;color:inherit;font-weight:500;line-height:1.1}.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881]{float:right}.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881]:hover{cursor:pointer}.problem-edit .panel .panel-body[data-v-49e52881]{padding:15px 45px}.problem-edit .panel .panel-body .el-form .el-form-item[data-v-49e52881]{margin-right:10%}.problem-edit .panel .panel-body .el-form .el-form-item .program-edit[data-v-49e52881]{display:inline-block;width:83%;border:1px solid #ddd}.problem-edit .panel .panel-body .el-form .el-form-item .short-input[data-v-49e52881]{width:50%}.problem-edit .panel .panel-body .el-form .editor-wrapper[data-v-49e52881]{position:relative}.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper[data-v-49e52881]{position:absolute;top:0;left:0;display:inline-block}.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper .language-dropdown[data-v-49e52881]{margin-right:5px}.problem-edit .panel .panel-body .el-form .editor-wrapper .editor[data-v-49e52881]{margin-left:205px;display:inline-block;width:70%;border:1px solid #ddd}.problem-edit .panel .panel-body .el-form .editor-wrapper .editor .CodeMirror[data-v-49e52881]{height:330px}.problem-edit .panel .panel-body .el-form .editor-wrapper .setup-btn[data-v-49e52881]{position:relative;left:10px;bottom:10px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/manager/manage-problem-edit.vue\"],\"names\":[],\"mappings\":\"AACA,sCACE,kBAAmB,AACnB,mBAAoB,AACpB,sBAAuB,AACvB,sBAAuB,AACvB,6CAA+C,AAC/C,oCAAuC,CACxC,AACD,qDACE,kBAAmB,AACnB,WAAY,AACZ,yBAA0B,AAC1B,kBAAmB,AACnB,2BAA4B,AAC5B,4BAA6B,AAC7B,mCAAqC,CACtC,AACD,yEACE,aAAe,CAChB,AACD,+EACE,cAAgB,CACjB,AACD,kEACE,qBAAsB,AACtB,gBAAiB,AACjB,aAAc,AACd,gBAAiB,AACjB,eAAgB,AAChB,cAAe,AACf,gBAAiB,AACjB,eAAiB,CAClB,AACD,+DACE,WAAa,CACd,AACD,qEACE,cAAgB,CACjB,AACD,kDACE,iBAAmB,CACpB,AACD,yEACE,gBAAkB,CACnB,AACD,uFACE,qBAAsB,AACtB,UAAW,AACX,qBAAuB,CACxB,AACD,sFACE,SAAW,CACZ,AACD,2EACE,iBAAmB,CACpB,AACD,6FACE,kBAAmB,AACnB,MAAO,AACP,OAAQ,AACR,oBAAsB,CACvB,AACD,gHACE,gBAAkB,CACnB,AACD,mFACE,kBAAmB,AACnB,qBAAsB,AACtB,UAAW,AACX,qBAAuB,CACxB,AACD,+FACE,YAAc,CACf,AACD,sFACE,kBAAmB,AACnB,UAAW,AACX,WAAa,CACd\",\"file\":\"manage-problem-edit.vue\",\"sourcesContent\":[\"\\n.problem-edit .panel[data-v-49e52881] {\\n  border-radius: 5px;\\n  margin-bottom: 20px;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n  -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.05);\\n  box-shadow: 0 1px 1px rgba(0,0,0,0.05);\\n}\\n.problem-edit .panel .panel-heading[data-v-49e52881] {\\n  padding: 10px 15px;\\n  color: #333;\\n  background-color: #f5f5f5;\\n  border-color: #ddd;\\n  border-top-left-radius: 5px;\\n  border-top-right-radius: 5px;\\n  border-bottom: 1px solid transparent;\\n}\\n.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881] {\\n  color: #b0c4de;\\n}\\n.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881]:hover {\\n  cursor: pointer;\\n}\\n.problem-edit .panel .panel-heading .panel-title[data-v-49e52881] {\\n  display: inline-block;\\n  margin-left: 5px;\\n  margin-top: 0;\\n  margin-bottom: 0;\\n  font-size: 18px;\\n  color: inherit;\\n  font-weight: 500;\\n  line-height: 1.1;\\n}\\n.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881] {\\n  float: right;\\n}\\n.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881]:hover {\\n  cursor: pointer;\\n}\\n.problem-edit .panel .panel-body[data-v-49e52881] {\\n  padding: 15px 45px;\\n}\\n.problem-edit .panel .panel-body .el-form .el-form-item[data-v-49e52881] {\\n  margin-right: 10%;\\n}\\n.problem-edit .panel .panel-body .el-form .el-form-item .program-edit[data-v-49e52881] {\\n  display: inline-block;\\n  width: 83%;\\n  border: 1px solid #ddd;\\n}\\n.problem-edit .panel .panel-body .el-form .el-form-item .short-input[data-v-49e52881] {\\n  width: 50%;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper[data-v-49e52881] {\\n  position: relative;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper[data-v-49e52881] {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  display: inline-block;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper .language-dropdown[data-v-49e52881] {\\n  margin-right: 5px;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .editor[data-v-49e52881] {\\n  margin-left: 205px;\\n  display: inline-block;\\n  width: 70%;\\n  border: 1px solid #ddd;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .editor .CodeMirror[data-v-49e52881] {\\n  height: 330px;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .setup-btn[data-v-49e52881] {\\n  position: relative;\\n  left: 10px;\\n  bottom: 10px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"dxBS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"markdown\", function(cm, start) {\n  var maxDepth = 100;\n\n  function isHeader(lineNo) {\n    var tokentype = cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0));\n    return tokentype && /\\bheader\\b/.test(tokentype);\n  }\n\n  function headerLevel(lineNo, line, nextLine) {\n    var match = line && line.match(/^#+/);\n    if (match && isHeader(lineNo)) return match[0].length;\n    match = nextLine && nextLine.match(/^[=\\-]+\\s*$/);\n    if (match && isHeader(lineNo + 1)) return nextLine[0] == \"=\" ? 1 : 2;\n    return maxDepth;\n  }\n\n  var firstLine = cm.getLine(start.line), nextLine = cm.getLine(start.line + 1);\n  var level = headerLevel(start.line, firstLine, nextLine);\n  if (level === maxDepth) return undefined;\n\n  var lastLineNo = cm.lastLine();\n  var end = start.line, nextNextLine = cm.getLine(end + 2);\n  while (end < lastLineNo) {\n    if (headerLevel(end + 1, nextLine, nextNextLine) <= level) break;\n    ++end;\n    nextLine = nextNextLine;\n    nextNextLine = cm.getLine(end + 2);\n  }\n\n  return {\n    from: CodeMirror.Pos(start.line, firstLine.length),\n    to: CodeMirror.Pos(end, cm.getLine(end).length)\n  };\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"engA\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".CodeMirror-foldmarker{color:blue;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\\\"\\\\25BE\\\"}.CodeMirror-foldgutter-folded:after{content:\\\"\\\\25B8\\\"}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/fold/foldgutter.css\"],\"names\":[],\"mappings\":\"AAAA,uBACE,WAAY,AACZ,oFAAwF,AACxF,kBAAmB,AACnB,eAAgB,AAChB,cAAgB,CACjB,AACD,uBACE,UAAY,CACb,AACD,0DAEE,cAAgB,CACjB,AACD,kCACE,eAAiB,CAClB,AACD,oCACE,eAAiB,CAClB\",\"file\":\"foldgutter.css\",\"sourcesContent\":[\".CodeMirror-foldmarker {\\n  color: blue;\\n  text-shadow: #b9f 1px 1px 2px, #b9f -1px -1px 2px, #b9f 1px -1px 2px, #b9f -1px 1px 2px;\\n  font-family: arial;\\n  line-height: .3;\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter {\\n  width: .7em;\\n}\\n.CodeMirror-foldgutter-open,\\n.CodeMirror-foldgutter-folded {\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter-open:after {\\n  content: \\\"\\\\25BE\\\";\\n}\\n.CodeMirror-foldgutter-folded:after {\\n  content: \\\"\\\\25B8\\\";\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"fo6W\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var startLine = start.line, has = hasImport(startLine), prev;\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var startLine = start.line, has = hasInclude(startLine);\n  if (has == null || hasInclude(startLine - 1) != null) return null;\n  for (var end = startLine;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(startLine, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"hdeF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"drNd\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"aa779c20\", content, true);\n\n/***/ }),\n\n/***/ \"jQeI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    var self = this;\n    cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      this.cm.off(\"cursorActivity\", this.activityFunc);\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i];\n      if (completion.hint) completion.hint(this.cm, data, completion);\n      else this.cm.replaceRange(getText(completion), completion.from || data.from,\n                                completion.to || data.to, \"complete\");\n      CodeMirror.signal(data, \"pick\", completion);\n      this.close();\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||\n          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      if (data && this.data && isNewCompletion(this.data, data)) return;\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function isNewCompletion(old, nw) {\n    var moved = CodeMirror.cmpPos(nw.from, old.from)\n    return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch\n  }\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n\n    var hints = this.hints = document.createElement(\"ul\");\n    hints.className = \"CodeMirror-hints\";\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    hints.style.left = left + \"px\";\n    hints.style.top = top + \"px\";\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n    (completion.options.container || document.body).appendChild(hints);\n    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n    var scrolls = hints.scrollHeight > hints.clientHeight + 1\n    var startScroll = cm.getScrollInfo();\n\n    if (overlapY > 0) {\n      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n      if (curTop - height > 0) { // Fits above cursor\n        hints.style.top = (top = pos.top - height) + \"px\";\n        below = false;\n      } else if (height > winH) {\n        hints.style.height = (winH - 5) + \"px\";\n        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n        var cursor = cm.getCursor();\n        if (data.from.ch != cursor.ch) {\n          pos = cm.cursorCoords(cursor);\n          hints.style.left = (left = pos.left) + \"px\";\n          box = hints.getBoundingClientRect();\n        }\n      }\n    }\n    var overlapX = box.right - winW;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = pos.left - overlapX) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      if (node.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node.offsetTop - 3;\n      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    var to = CodeMirror.Pos(cur.line, token.end);\n    if (token.string && /\\w/.test(token.string[token.string.length - 1])) {\n      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);\n    } else {\n      var term = \"\", from = to;\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnUnfocus: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n\n\n/***/ }),\n\n/***/ \"kYSO\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(\"Dd8w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_js_data__ = __webpack_require__(\"DW9A\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_axios__ = __webpack_require__(\"mtWM\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_axios__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__node_modules_element_ui_packages_form_src_form_item__ = __webpack_require__(\"95Re\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_components_search_search__ = __webpack_require__(\"YOyO\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_components_manager_manage_problem_edit__ = __webpack_require__(\"HbqP\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vuex__ = __webpack_require__(\"NYxO\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_js_problem__ = __webpack_require__(\"5Ey+\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_confirm_confirm__ = __webpack_require__(\"XEAW\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  data: function data() {\n    return {\n      problemDatas: [],\n      cur_page: 1,\n      multipleSelection: [],\n      select_cate: '',\n      select_word: '',\n      del_list: [],\n      is_search: false,\n      rules: {\n        id: [{ required: true, message: 'id不能为空', trigger: 'blur' }, { min: 3, max: 3, message: 'id为3位字母', trigger: 'blur' }],\n        title: [{ required: true, message: '标题不能为空', trigger: 'blur' }, { min: 5, message: '标题过短', trigger: 'blur' }],\n        description: [{ required: true, message: '描述不能为空', trigger: 'blur' }, { min: 5, message: '描述过短', trigger: 'blur' }]\n      },\n      isShowEdit: false, //是否展示编辑页面\n      isEdit: false, //false新建题目 true编辑题目\n      confirmText: '',\n      curProblemId: '',\n      curProblemTitle: '',\n      editorThemes: __WEBPACK_IMPORTED_MODULE_1_common_js_data__[\"d\" /* editorThemes */],\n      selectTheme: __WEBPACK_IMPORTED_MODULE_1_common_js_data__[\"d\" /* editorThemes */][0]\n    };\n  },\n  created: function created() {\n    this._getProblemsData(this.cur_page);\n  },\n\n  methods: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({\n    showSetupProblem: function showSetupProblem() {\n      this.isEdit = false;\n      this.isShowEdit = true;\n    },\n    handleCurrentChange: function handleCurrentChange(val) {\n      this.cur_page = val;\n      this._getProblemsData(this.cur_page);\n    },\n    _getProblemsData: function _getProblemsData(curPage) {\n      var _this = this;\n\n      var url = __WEBPACK_IMPORTED_MODULE_1_common_js_data__[\"a\" /* baseUrl */] + '/problems?page=' + curPage;\n      __WEBPACK_IMPORTED_MODULE_2_axios___default.a.get(url).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_1_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this.problemDatas = response.data.result;\n        }\n      }, function (response) {});\n    },\n    formatter: function formatter(row, column) {\n      return row.address;\n    },\n    filterTag: function filterTag(value, row) {\n      return row.tag === value;\n    },\n    handleEdit: function handleEdit(index, row) {\n      //点击编辑按钮\n      console.log(row);\n      this.saveOneProblem(new __WEBPACK_IMPORTED_MODULE_7_common_js_problem__[\"a\" /* default */](row));\n      this.isEdit = true;\n      this.isShowEdit = true;\n      this.$refs.problemEdit.showPromblemInfo();\n    },\n    handleDelete: function handleDelete(index, row) {\n      //点击删除按钮\n      this.curProblemId = row.id;\n      this.curProblemTitle = row.title;\n      this.confirmText = '\\u786E\\u5B9A\\u8981\\u5220\\u9664\\u9898\\u76EE \\u201C' + this.curProblemTitle + '\\u201D\\u5417?';\n      this.$refs.confirm.show();\n    },\n    confirmDele: function confirmDele() {\n      var _this2 = this;\n\n      //确认删除\n      var url = __WEBPACK_IMPORTED_MODULE_1_common_js_data__[\"a\" /* baseUrl */] + '/problems/' + this.curProblemId;\n      __WEBPACK_IMPORTED_MODULE_2_axios___default.a.delete(url).then(function (response) {\n        if (response.data.msg === __WEBPACK_IMPORTED_MODULE_1_common_js_data__[\"b\" /* MSG_OK */]) {\n          _this2._getProblemsData(_this2.cur_page);\n          _this2.$message({\n            message: '\\u6210\\u529F\\u5220\\u9664\\u9898\\u76EE:' + _this2.curProblemTitle,\n            type: 'success'\n          });\n        } else if (response.data.msg === __WEBPACK_IMPORTED_MODULE_1_common_js_data__[\"c\" /* MSG_NO */]) {\n          _this2.$notify.error({\n            title: '无法删除',\n            message: '' + response.data.error\n          });\n        }\n      }, function (response) {\n        _this2.$message.error('\\u65E0\\u6CD5\\u5220\\u9664\\u9898\\u76EE' + _this2.curProblemTitle);\n      });\n    },\n    delAll: function delAll() {\n      var self = this,\n          length = self.multipleSelection.length;\n      var str = '';\n      self.del_list = self.del_list.concat(self.multipleSelection);\n      for (var i = 0; i < length; i++) {\n        str += self.multipleSelection[i].name + ' ';\n      }\n      self.$message.error('删除了' + str);\n      self.multipleSelection = [];\n    },\n    calcTag: function calcTag(row, column, cellValue) {\n      if (cellValue === '') {\n        return 'Nothing';\n      }\n      return cellValue.replace(',', ' & ');\n    },\n    handleSelectionChange: function handleSelectionChange(val) {\n      this.multipleSelection = val;\n    },\n    hideEdit: function hideEdit() {\n      // 隐藏编辑页面\n      this.isShowEdit = false;\n      this._getProblemsData(this.cur_page);\n    },\n    refreshProblems: function refreshProblems() {\n      //刷新manage-problems界面\n      this.cur_page = 1;\n      this._getProblemsData(this.cur_page);\n    }\n  }, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_vuex__[\"b\" /* mapActions */])(['saveOneProblem'])),\n  computed: {\n    data: function data() {\n      var self = this;\n      return self.contestDatas.filter(function (d) {\n        var is_del = false;\n        for (var i = 0; i < self.del_list.length; i++) {\n          if (d.name === self.del_list[i].name) {\n            is_del = true;\n            break;\n          }\n        }\n        if (!is_del) {\n          if (d.address.indexOf(self.select_cate) > -1 && (d.name.indexOf(self.select_word) > -1 || d.address.indexOf(self.select_word) > -1)) {\n            return d;\n          }\n        }\n      });\n    }\n  },\n  components: {\n    ElFormItem: __WEBPACK_IMPORTED_MODULE_3__node_modules_element_ui_packages_form_src_form_item__[\"a\" /* default */],\n    Search: __WEBPACK_IMPORTED_MODULE_4_components_search_search__[\"a\" /* default */],\n    ProblemEdit: __WEBPACK_IMPORTED_MODULE_5_components_manager_manage_problem_edit__[\"a\" /* default */],\n    Confirm: __WEBPACK_IMPORTED_MODULE_8_base_confirm_confirm__[\"a\" /* default */]\n  }\n});\n\n/***/ }),\n\n/***/ \"mvHQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(\"qkKv\"), __esModule: true };\n\n/***/ }),\n\n/***/ \"oxMS\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"manage-problem\"\n  }, [_c('confirm', {\n    ref: \"confirm\",\n    attrs: {\n      \"text\": _vm.confirmText\n    },\n    on: {\n      \"confirm\": _vm.confirmDele\n    }\n  }), _vm._v(\" \"), _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in-linear\"\n    }\n  }, [_c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.isShowEdit),\n      expression: \"!isShowEdit\"\n    }]\n  }, [_c('div', {\n    staticClass: \"handle-box\"\n  }, [_c('el-button-group', [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.showSetupProblem($event)\n      }\n    }\n  }, [_vm._v(\"创建题目\")]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"success\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.refreshProblems($event)\n      }\n    }\n  }, [_vm._v(\"刷新数据\")])], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"search-wrapper\"\n  }, [_c('search')], 1)], 1), _vm._v(\" \"), _c('el-table', {\n    ref: \"multipleTable\",\n    staticStyle: {\n      \"width\": \"80%\"\n    },\n    attrs: {\n      \"data\": _vm.problemDatas,\n      \"border\": \"\"\n    },\n    on: {\n      \"selection-change\": _vm.handleSelectionChange\n    }\n  }, [_c('el-table-column', {\n    attrs: {\n      \"type\": \"selection\",\n      \"width\": \"55\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"id\",\n      \"label\": \"ID\",\n      \"width\": \"150\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"title\",\n      \"label\": \"标题\",\n      \"sortable\": \"\",\n      \"width\": \"350\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"tag\",\n      \"label\": \"标签\",\n      \"sortable\": \"\",\n      \"width\": \"250\",\n      \"formatter\": _vm.calcTag\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"level\",\n      \"label\": \"难度\",\n      \"sortable\": \"\",\n      \"width\": \"100\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"submitted\",\n      \"label\": \"提交数\",\n      \"sortable\": \"\",\n      \"width\": \"100\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"accepted\",\n      \"label\": \"通过数\",\n      \"sortable\": \"\",\n      \"width\": \"100\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"label\": \"操作\",\n      \"width\": \"150\",\n      \"fixed\": \"right\"\n    },\n    scopedSlots: _vm._u([{\n      key: \"default\",\n      fn: function(scope) {\n        return [_c('el-button', {\n          attrs: {\n            \"size\": \"small\"\n          },\n          on: {\n            \"click\": function($event) {\n              $event.stopPropagation();\n              _vm.handleEdit(scope.$index, scope.row)\n            }\n          }\n        }, [_vm._v(\"编辑\\n            \")]), _vm._v(\" \"), _c('el-button', {\n          attrs: {\n            \"size\": \"small\",\n            \"type\": \"danger\"\n          },\n          on: {\n            \"click\": function($event) {\n              $event.stopPropagation();\n              _vm.handleDelete(scope.$index, scope.row)\n            }\n          }\n        }, [_vm._v(\"删除\\n            \")])]\n      }\n    }])\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"pagination\"\n  }, [_c('el-pagination', {\n    attrs: {\n      \"layout\": \"prev, pager, next\",\n      \"current-page\": _vm.cur_page,\n      \"total\": 100\n    },\n    on: {\n      \"current-change\": _vm.handleCurrentChange\n    }\n  })], 1)], 1)]), _vm._v(\" \"), _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in-linear\"\n    }\n  }, [_c('problem-edit', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.isShowEdit),\n      expression: \"isShowEdit\"\n    }],\n    ref: \"problemEdit\",\n    attrs: {\n      \"isEdit\": _vm.isEdit\n    },\n    on: {\n      \"editFinish\": _vm.hideEdit\n    }\n  })], 1)], 1)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ }),\n\n/***/ \"qkKv\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(\"FeBl\");\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n/***/ }),\n\n/***/ \"qm6i\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"FZ+f\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".manage-problem .el-dialog .block .el-date-editor[data-v-1ffcf786]{width:100%}.manage-problem .handle-box[data-v-1ffcf786]{margin-bottom:15px;width:80%}.manage-problem .handle-box .el-button-group .el-button[data-v-1ffcf786]{width:100px}.manage-problem .handle-box .search-wrapper[data-v-1ffcf786]{float:right}.pagination[data-v-1ffcf786]{margin:20px 20% 0 0;text-align:right}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/manager/manage-problems.vue\"],\"names\":[],\"mappings\":\"AACA,mEACE,UAAY,CACb,AACD,6CACE,mBAAoB,AACpB,SAAW,CACZ,AACD,yEACE,WAAa,CACd,AACD,6DACE,WAAa,CACd,AACD,6BACE,oBAAqB,AACrB,gBAAkB,CACnB\",\"file\":\"manage-problems.vue\",\"sourcesContent\":[\"\\n.manage-problem .el-dialog .block .el-date-editor[data-v-1ffcf786] {\\n  width: 100%;\\n}\\n.manage-problem .handle-box[data-v-1ffcf786] {\\n  margin-bottom: 15px;\\n  width: 80%;\\n}\\n.manage-problem .handle-box .el-button-group .el-button[data-v-1ffcf786] {\\n  width: 100px;\\n}\\n.manage-problem .handle-box .search-wrapper[data-v-1ffcf786] {\\n  float: right;\\n}\\n.pagination[data-v-1ffcf786] {\\n  margin: 20px 20% 0 0;\\n  text-align: right;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ \"sOR5\":\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n\n/***/ \"soCA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerGlobalHelper(\"fold\", \"comment\", function(mode) {\n  return mode.blockCommentStart && mode.blockCommentEnd;\n}, function(cm, start) {\n  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;\n  if (!startToken || !endToken) return;\n  var line = start.line, lineText = cm.getLine(line);\n\n  var startCh;\n  for (var at = start.ch, pass = 0;;) {\n    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);\n    if (found == -1) {\n      if (pass == 1) return;\n      pass = 1;\n      at = lineText.length;\n      continue;\n    }\n    if (pass == 1 && found < start.ch) return;\n    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&\n        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||\n         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {\n      startCh = found + startToken.length;\n      break;\n    }\n    at = found - 1;\n  }\n\n  var depth = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (pos == nextOpen) ++depth;\n      else if (!--depth) { end = i; endCh = pos; break outer; }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\n});\n\n\n/***/ }),\n\n/***/ \"tjx/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  function kill(cm, from, to, mayGrow, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (mayGrow) lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      kill(cm, cursor, findEnd(cm, cursor, by, dir), true);\n    }\n  }\n\n  function killRegion(cm) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        kill(cm, selection.anchor, selection.head);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  function setMark(cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(msg + \": <input type=\\\"text\\\" style=\\\"width: 10em\\\"/>\", f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  function quit(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  CodeMirror.emacs = {kill: kill, killRegion: killRegion, repeated: repeated};\n\n  // Actual keymap\n\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": function(cm) {kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"));},\n    \"Ctrl-K\": repeated(function(cm) {\n      var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n      var text = cm.getRange(start, end);\n      if (!/\\S/.test(text)) {\n        text += \"\\n\";\n        end = Pos(start.line + 1, 0);\n      }\n      kill(cm, start, end, true, text);\n    }),\n    \"Alt-W\": function(cm) {\n      addToRing(cm.getSelection());\n      clearMark(cm);\n    },\n    \"Ctrl-Y\": function(cm) {\n      var start = cm.getCursor();\n      cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n      cm.setSelection(start, cm.getCursor());\n    },\n    \"Alt-Y\": function(cm) {cm.replaceSelection(popFromRing(), \"around\", \"paste\");},\n\n    \"Ctrl-Space\": setMark, \"Ctrl-Shift-2\": setMark,\n\n    \"Ctrl-F\": move(byChar, 1), \"Ctrl-B\": move(byChar, -1),\n    \"Right\": move(byChar, 1), \"Left\": move(byChar, -1),\n    \"Ctrl-D\": function(cm) { killTo(cm, byChar, 1); },\n    \"Delete\": function(cm) { killRegion(cm) || killTo(cm, byChar, 1); },\n    \"Ctrl-H\": function(cm) { killTo(cm, byChar, -1); },\n    \"Backspace\": function(cm) { killRegion(cm) || killTo(cm, byChar, -1); },\n\n    \"Alt-F\": move(byWord, 1), \"Alt-B\": move(byWord, -1),\n    \"Alt-D\": function(cm) { killTo(cm, byWord, 1); },\n    \"Alt-Backspace\": function(cm) { killTo(cm, byWord, -1); },\n\n    \"Ctrl-N\": move(byLine, 1), \"Ctrl-P\": move(byLine, -1),\n    \"Down\": move(byLine, 1), \"Up\": move(byLine, -1),\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStart\",\n\n    \"Alt-V\": move(byPage, -1), \"Ctrl-V\": move(byPage, 1),\n    \"PageUp\": move(byPage, -1), \"PageDown\": move(byPage, 1),\n\n    \"Ctrl-Up\": move(byParagraph, -1), \"Ctrl-Down\": move(byParagraph, 1),\n\n    \"Alt-A\": move(bySentence, -1), \"Alt-E\": move(bySentence, 1),\n    \"Alt-K\": function(cm) { killTo(cm, bySentence, 1); },\n\n    \"Ctrl-Alt-K\": function(cm) { killTo(cm, byExpr, 1); },\n    \"Ctrl-Alt-Backspace\": function(cm) { killTo(cm, byExpr, -1); },\n    \"Ctrl-Alt-F\": move(byExpr, 1), \"Ctrl-Alt-B\": move(byExpr, -1),\n\n    \"Shift-Ctrl-Alt-2\": function(cm) {\n      var cursor = cm.getCursor();\n      cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n    },\n    \"Ctrl-Alt-T\": function(cm) {\n      var leftStart = byExpr(cm, cm.getCursor(), -1), leftEnd = byExpr(cm, leftStart, 1);\n      var rightEnd = byExpr(cm, leftEnd, 1), rightStart = byExpr(cm, rightEnd, -1);\n      cm.replaceRange(cm.getRange(rightStart, rightEnd) + cm.getRange(leftEnd, rightStart) +\n                      cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n    },\n    \"Ctrl-Alt-U\": repeated(toEnclosingExpr),\n\n    \"Alt-Space\": function(cm) {\n      var pos = cm.getCursor(), from = pos.ch, to = pos.ch, text = cm.getLine(pos.line);\n      while (from && /\\s/.test(text.charAt(from - 1))) --from;\n      while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n      cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n    },\n    \"Ctrl-O\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"start\"); }),\n    \"Ctrl-T\": repeated(function(cm) {\n      cm.execCommand(\"transposeChars\");\n    }),\n\n    \"Alt-C\": repeated(function(cm) {\n      operateOnWord(cm, function(w) {\n        var letter = w.search(/\\w/);\n        if (letter == -1) return w;\n        return w.slice(0, letter) + w.charAt(letter).toUpperCase() + w.slice(letter + 1).toLowerCase();\n      });\n    }),\n    \"Alt-U\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toUpperCase(); });\n    }),\n    \"Alt-L\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toLowerCase(); });\n    }),\n\n    \"Alt-;\": \"toggleComment\",\n\n    \"Ctrl-/\": repeated(\"undo\"), \"Shift-Ctrl--\": repeated(\"undo\"),\n    \"Ctrl-Z\": repeated(\"undo\"), \"Cmd-Z\": repeated(\"undo\"),\n    \"Shift-Alt-,\": \"goDocStart\", \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\", \"Ctrl-R\": \"findPersistentPrev\", \"Ctrl-G\": quit, \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); }),\n    \"Tab\": \"indentAuto\",\n\n    \"Alt-G G\": function(cm) {\n      var prefix = getPrefix(cm, true);\n      if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n      getInput(cm, \"Goto line\", function(str) {\n        var num;\n        if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n          cm.setCursor(num - 1);\n      });\n    },\n\n    \"Ctrl-X Tab\": function(cm) {\n      cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n    },\n    \"Ctrl-X Ctrl-X\": function(cm) {\n      cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n    },\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X U\": repeated(\"undo\"),\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X Delete\": function(cm) { kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), true); },\n    \"Ctrl-X H\": \"selectAll\",\n\n    \"Ctrl-Q Tab\": repeated(\"insertTab\"),\n    \"Ctrl-U\": addPrefixMap\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n\n\n/***/ }),\n\n/***/ \"ujcs\":\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n\n/***/ \"vq+x\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(\"8U58\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && matching[line.text.charAt(pos)]) ||\n        matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n\n\n/***/ }),\n\n/***/ \"xrTZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n */\n\n(function(global) {\n    'use strict';\n    // existing version for noConflict()\n    var _Base64 = global.Base64;\n    var version = \"2.3.2\";\n    // if node.js, we use Buffer\n    var buffer;\n    if (typeof module !== 'undefined' && module.exports) {\n        try {\n            buffer = __webpack_require__(\"EuP9\").Buffer;\n        } catch (err) {}\n    }\n    // constants\n    var b64chars\n        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var b64tab = function(bin) {\n        var t = {};\n        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n        return t;\n    }(b64chars);\n    var fromCharCode = String.fromCharCode;\n    // encoder stuff\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n                                + fromCharCode(0x80 | (cc & 0x3f)))\n                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n        } else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    var cb_encode = function(ccc) {\n        var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16\n            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n        chars = [\n            b64chars.charAt( ord >>> 18),\n            b64chars.charAt((ord >>> 12) & 63),\n            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n        ];\n        return chars.join('');\n    };\n    var btoa = global.btoa ? function(b) {\n        return global.btoa(b);\n    } : function(b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n    var _encode = buffer ?\n        buffer.from && buffer.from !== Uint8Array.from ? function (u) {\n            return (u.constructor === buffer.constructor ? u : buffer.from(u))\n                .toString('base64')\n        }\n        :  function (u) {\n            return (u.constructor === buffer.constructor ? u : new  buffer(u))\n                .toString('base64')\n        }\n        : function (u) { return btoa(utob(u)) }\n    ;\n    var encode = function(u, urisafe) {\n        return !urisafe\n            ? _encode(String(u))\n            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n                return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n    };\n    var encodeURI = function(u) { return encode(u, true) };\n    // decoder stuff\n    var re_btou = new RegExp([\n        '[\\xC0-\\xDF][\\x80-\\xBF]',\n        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n    ].join('|'), 'g');\n    var cb_btou = function(cccc) {\n        switch(cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n                |     (0x3f & cccc.charCodeAt(3)),\n            offset = cp - 0x10000;\n            return (fromCharCode((offset  >>> 10) + 0xD800)\n                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return fromCharCode(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    |  (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return  fromCharCode(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                    |  (0x3f & cccc.charCodeAt(1))\n            );\n        }\n    };\n    var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    var cb_decode = function(cccc) {\n        var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n        chars = [\n            fromCharCode( n >>> 16),\n            fromCharCode((n >>>  8) & 0xff),\n            fromCharCode( n         & 0xff)\n        ];\n        chars.length -= [0, 0, 2, 1][padlen];\n        return chars.join('');\n    };\n    var atob = global.atob ? function(a) {\n        return global.atob(a);\n    } : function(a){\n        return a.replace(/[\\s\\S]{1,4}/g, cb_decode);\n    };\n    var _decode = buffer ?\n        buffer.from && buffer.from !== Uint8Array.from ? function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : buffer.from(a, 'base64')).toString();\n        }\n        : function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : new buffer(a, 'base64')).toString();\n        }\n        : function(a) { return btou(atob(a)) };\n    var decode = function(a){\n        return _decode(\n            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n        );\n    };\n    var noConflict = function() {\n        var Base64 = global.Base64;\n        global.Base64 = _Base64;\n        return Base64;\n    };\n    // export Base64\n    global.Base64 = {\n        VERSION: version,\n        atob: atob,\n        btoa: btoa,\n        fromBase64: decode,\n        toBase64: encode,\n        utob: utob,\n        encode: encode,\n        encodeURI: encodeURI,\n        btou: btou,\n        decode: decode,\n        noConflict: noConflict\n    };\n    // if ES5 is available, make Base64.extendString() available\n    if (typeof Object.defineProperty === 'function') {\n        var noEnum = function(v){\n            return {value:v,enumerable:false,writable:true,configurable:true};\n        };\n        global.Base64.extendString = function () {\n            Object.defineProperty(\n                String.prototype, 'fromBase64', noEnum(function () {\n                    return decode(this)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64', noEnum(function (urisafe) {\n                    return encode(this, urisafe)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64URI', noEnum(function () {\n                    return encode(this, true)\n                }));\n        };\n    }\n    //\n    // export Base64 to the namespace\n    //\n    if (global['Meteor']) { // Meteor.js\n        Base64 = global.Base64;\n    }\n    // module.exports and AMD are mutually exclusive.\n    // module.exports has precedence.\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports.Base64 = global.Base64;\n    }\n    else if (true) {\t\t\n        // AMD. Register as an anonymous module.\t\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){ return global.Base64 }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // that's it!\n})(   typeof self   !== 'undefined' ? self\n    : typeof window !== 'undefined' ? window\n    : typeof global !== 'undefined' ? global\n    : this\n);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"DuR2\")))\n\n/***/ }),\n\n/***/ \"yGpH\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"RrKZ\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(\"rjj0\")(\"56e4b5b6\", content, true);\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/5.e1e540a677db9d0c2e7e.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Tag-closer extension for CodeMirror.\n *\n * This extension adds an \"autoCloseTags\" option that can be set to\n * either true to get the default behavior, or an object to further\n * configure its behavior.\n *\n * These are supported options:\n *\n * `whenClosing` (default true)\n *   Whether to autoclose when the '/' of a closing tag is typed.\n * `whenOpening` (default true)\n *   Whether to autoclose the tag when the final '>' of an opening\n *   tag is typed.\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\n *   An array of tag names that should not be autoclosed.\n * `indentTags` (default is block tags for HTML, none for XML)\n *   An array of tag names that should, when opened, cause a\n *   blank line to be added inside the tag, and the blank line and\n *   closing line to be indented.\n *\n * See demos/closetag.html for a usage example.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../fold/xml-fold\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../fold/xml-fold\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  CodeMirror.defineOption(\"autoCloseTags\", false, function(cm, val, old) {\n    if (old != CodeMirror.Init && old)\n      cm.removeKeyMap(\"autoCloseTags\");\n    if (!val) return;\n    var map = {name: \"autoCloseTags\"};\n    if (typeof val != \"object\" || val.whenClosing)\n      map[\"'/'\"] = function(cm) { return autoCloseSlash(cm); };\n    if (typeof val != \"object\" || val.whenOpening)\n      map[\"'>'\"] = function(cm) { return autoCloseGT(cm); };\n    cm.addKeyMap(map);\n  });\n\n  var htmlDontClose = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n                       \"source\", \"track\", \"wbr\"];\n  var htmlIndent = [\"applet\", \"blockquote\", \"body\", \"button\", \"div\", \"dl\", \"fieldset\", \"form\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\",\n                    \"h5\", \"h6\", \"head\", \"html\", \"iframe\", \"layer\", \"legend\", \"object\", \"ol\", \"p\", \"select\", \"table\", \"ul\"];\n\n  function autoCloseGT(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (inner.mode.name != \"xml\" || !state.tagName) return CodeMirror.Pass;\n\n      var opt = cm.getOption(\"autoCloseTags\"), html = inner.mode.configuration == \"html\";\n      var dontCloseTags = (typeof opt == \"object\" && opt.dontCloseTags) || (html && htmlDontClose);\n      var indentTags = (typeof opt == \"object\" && opt.indentTags) || (html && htmlIndent);\n\n      var tagName = state.tagName;\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n      var lowerTagName = tagName.toLowerCase();\n      // Don't process the '>' at the end of an end-tag or self-closing tag\n      if (!tagName ||\n          tok.type == \"string\" && (tok.end != pos.ch || !/[\\\"\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||\n          tok.type == \"tag\" && state.type == \"closeTag\" ||\n          tok.string.indexOf(\"/\") == (tok.string.length - 1) || // match something like <someTagName />\n          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||\n          closingTagExists(cm, tagName, pos, state, true))\n        return CodeMirror.Pass;\n\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n      replacements[i] = {indent: indent,\n                         text: \">\" + (indent ? \"\\n\\n\" : \"\") + \"</\" + tagName + \">\",\n                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};\n    }\n\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var info = replacements[i];\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, \"+insert\");\n      var sel = cm.listSelections().slice(0);\n      sel[i] = {head: info.newPos, anchor: info.newPos};\n      cm.setSelections(sel);\n      if (info.indent) {\n        cm.indentLine(info.newPos.line, null, true);\n        cm.indentLine(info.newPos.line + 1, null, true);\n      }\n    }\n  }\n\n  function autoCloseCurrent(cm, typingSlash) {\n    var ranges = cm.listSelections(), replacements = [];\n    var head = typingSlash ? \"/\" : \"</\";\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (typingSlash && (tok.type == \"string\" || tok.string.charAt(0) != \"<\" ||\n                          tok.start != pos.ch - 1))\n        return CodeMirror.Pass;\n      // Kludge to get around the fact that we are not in XML mode\n      // when completing in JS/CSS snippet in htmlmixed mode. Does not\n      // work for other XML embedded languages (there is no general\n      // way to go from a mixed mode to its current XML state).\n      var replacement;\n      if (inner.mode.name != \"xml\") {\n        if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"javascript\")\n          replacement = head + \"script\";\n        else if (cm.getMode().name == \"htmlmixed\" && inner.mode.name == \"css\")\n          replacement = head + \"style\";\n        else\n          return CodeMirror.Pass;\n      } else {\n        if (!state.context || !state.context.tagName ||\n            closingTagExists(cm, state.context.tagName, pos, state))\n          return CodeMirror.Pass;\n        replacement = head + state.context.tagName;\n      }\n      if (cm.getLine(pos.line).charAt(tok.end) != \">\") replacement += \">\";\n      replacements[i] = replacement;\n    }\n    cm.replaceSelections(replacements);\n    ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\n        cm.indentLine(ranges[i].head.line);\n  }\n\n  function autoCloseSlash(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    return autoCloseCurrent(cm, true);\n  }\n\n  CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  // If xml-fold is loaded, we use its functionality to try and verify\n  // whether a given tag is actually unclosed.\n  function closingTagExists(cm, tagName, pos, state, newTag) {\n    if (!CodeMirror.scanForClosingTag) return false;\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n    if (!nextClose || nextClose.tag != tagName) return false;\n    var cx = state.context;\n    // If the immediate wrapping context contains onCx instances of\n    // the same tag, a closing tag only exists if there are at least\n    // that many closing tags of that type following.\n    for (var onCx = newTag ? 1 : 0; cx && cx.tagName == tagName; cx = cx.prev) ++onCx;\n    pos = nextClose.to;\n    for (var i = 1; i < onCx; i++) {\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n      if (!next || next.tag != tagName) return false;\n      pos = next.to;\n    }\n    return true;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/edit/closetag.js\n// module id = +/ra\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../scroll/annotatescrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/matchesonscrollbar.js\n// module id = /A6h\n// module chunks = 4 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('el-dropdown', {\n    on: {\n      \"command\": _vm.handleCommandDropdown\n    }\n  }, [_c('el-input', {\n    staticClass: \"search-input\",\n    attrs: {\n      \"placeholder\": \"请输入要搜索的题目\",\n      \"icon\": \"search\",\n      \"spellcheck\": \"false\",\n      \"on-icon-click\": _vm._onSearch\n    },\n    on: {\n      \"change\": _vm._onSearch,\n      \"focus\": _vm._onSearch\n    },\n    model: {\n      value: (_vm.mysearch),\n      callback: function($$v) {\n        _vm.mysearch = (typeof $$v === 'string' ? $$v.trim() : $$v)\n      },\n      expression: \"mysearch\"\n    }\n  }), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, [_c('el-dropdown-item', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.dropdownLoading),\n      expression: \"dropdownLoading\"\n    }]\n  }, [_vm._v(\"拼命加载中...\")]), _vm._v(\" \"), _vm._l((_vm.searchResult), function(item, index) {\n    return _c('el-dropdown-item', {\n      directives: [{\n        name: \"show\",\n        rawName: \"v-show\",\n        value: (index <= 10 && !_vm.dropdownLoading),\n        expression: \"index <= 10 && !dropdownLoading\"\n      }],\n      key: index,\n      attrs: {\n        \"command\": item.id\n      }\n    }, [_c('span', {\n      staticClass: \"problem-item-title\"\n    }, [_vm._v(_vm._s(item.title))]), _vm._v(\" \"), _c('img', {\n      staticClass: \"problem-item-img\",\n      attrs: {\n        \"width\": \"16\",\n        \"height\": \"16 \",\n        \"src\": \"static/problem.png\"\n      }\n    })])\n  })], 2)], 1)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-2d96e4b2\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/search/search.vue\n// module id = 0tR3\n// module chunks = 2 5","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".el-dialog .el-dialog__body[data-v-48f25eaf]{padding:10px 20px}.el-dialog .el-dialog__body .text[data-v-48f25eaf]{font-size:18px;font-weight:400}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/base/confirm/confirm.vue\"],\"names\":[],\"mappings\":\"AACA,6CACE,iBAAmB,CACpB,AACD,mDACE,eAAgB,AAChB,eAAiB,CAClB\",\"file\":\"confirm.vue\",\"sourcesContent\":[\"\\n.el-dialog .el-dialog__body[data-v-48f25eaf] {\\n  padding: 10px 20px;\\n}\\n.el-dialog .el-dialog__body .text[data-v-48f25eaf] {\\n  font-size: 18px;\\n  font-weight: 400;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-48f25eaf\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/base/confirm/confirm.vue\n// module id = 2EAN\n// module chunks = 0 1 5","<template>\n  <el-dialog\n    title=\"提示\"\n    :visible.sync=\"visible\">\n    <span class=\"text\">{{text}}</span>\n    <span slot=\"footer\" class=\"dialog-footer\">\n    <el-button @click=\"cancel\">{{cancelBtnText}}</el-button>\n    <el-button type=\"primary\" @click=\"confirm\">{{confirmBtnText}}</el-button>\n  </span>\n  </el-dialog>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  export default{\n    props: {\n      text: {\n        type: String,\n        default: ''\n      },\n      confirmBtnText: {\n        type: String,\n        default: '确 定'\n      },\n      cancelBtnText: {\n        type: String,\n        default: '取 消'\n      }\n    },\n    data(){\n      return {\n        visible: false\n      }\n    },\n    methods: {\n      show(){\n        this.visible = true\n      },\n      hide(){\n        this.visible = false\n      },\n      confirm(){\n        this.hide()\n        this.$emit('confirm')\n      },\n      cancel(){\n        this.hide()\n        this.$emit('cancel')\n      }\n    }\n  }\n</script>\n\n<style lang=\"stylus\" scoped rel=\"stylesheet/stylus\">\n  .el-dialog\n    .el-dialog__body\n      padding 10px 20px\n      .text\n        font-size 18px\n        font-weight 400\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/base/confirm/confirm.vue?3ae7d549","/**\n * Created by qinzhen on 2017/9/17.\n */\nexport default class Problem {\n  constructor ({id, title, tag, level, description, accepted, submitted, like_nums, hate_nums}) {\n    this.id = id\n    this.title = title\n    this.tag = tag\n    this.level = level\n    this.description = description\n    this.accepted = accepted\n    this.submitted = submitted\n    this.like_nums = like_nums\n    this.hate_nums = hate_nums\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/js/problem.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var map = CodeMirror.keyMap.sublime = {fallthrough: \"default\"};\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  var mac = CodeMirror.keyMap[\"default\"] == CodeMirror.keyMap.macDefault;\n  var ctrl = mac ? \"Cmd-\" : \"Ctrl-\";\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  var goSubwordCombo = mac ? \"Ctrl-\" : \"Alt-\";\n\n  cmds[map[goSubwordCombo + \"Left\"] = \"goSubwordLeft\"] = function(cm) { moveSubword(cm, -1); };\n  cmds[map[goSubwordCombo + \"Right\"] = \"goSubwordRight\"] = function(cm) { moveSubword(cm, 1); };\n\n  if (mac) map[\"Cmd-Left\"] = \"goLineStartSmart\";\n\n  var scrollLineCombo = mac ? \"Ctrl-Alt-\" : \"Ctrl-\";\n\n  cmds[map[scrollLineCombo + \"Up\"] = \"scrollLineUp\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds[map[scrollLineCombo + \"Down\"] = \"scrollLineDown\"] = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"L\"] = \"splitSelectionByLine\"] = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  map[\"Shift-Tab\"] = \"indentLess\";\n\n  cmds[map[\"Esc\"] = \"singleSelectionTop\"] = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds[map[ctrl + \"L\"] = \"selectLine\"] = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  map[\"Shift-Ctrl-K\"] = \"deleteLine\";\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds[map[ctrl + \"Enter\"] = \"insertLineAfter\"] = function(cm) { return insertLine(cm, false); };\n\n  cmds[map[\"Shift-\" + ctrl + \"Enter\"] = \"insertLineBefore\"] = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds[map[ctrl + \"D\"] = \"selectNextOccurrence\"] = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))\n        return CodeMirror.Pass\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(range.anchor, dir, \"line\");\n      var newHead = cm.findPosV(range.head, dir, \"line\");\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n\n  var addCursorToLineCombo = mac ? \"Shift-Cmd\" : 'Alt-Ctrl';\n  cmds[map[addCursorToLineCombo + \"Up\"] = \"addCursorToPrevLine\"] = function(cm) { addCursorToSelection(cm, -1); };\n  cmds[map[addCursorToLineCombo + \"Down\"] = \"addCursorToNextLine\"] = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (ranges[i].from() == from && ranges[i].to() == to) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          newRanges.push({anchor: Pos(opening.pos.line, opening.pos.ch + 1),\n                          head: closing.pos});\n          break;\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds[map[\"Shift-\" + ctrl + \"Space\"] = \"selectScope\"] = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds[map[\"Shift-\" + ctrl + \"M\"] = \"selectBetweenBrackets\"] = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds[map[ctrl + \"M\"] = \"goToBracket\"] = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  var swapLineCombo = mac ? \"Cmd-Ctrl-\" : \"Shift-Ctrl-\";\n\n  cmds[map[swapLineCombo + \"Up\"] = \"swapLineUp\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[swapLineCombo + \"Down\"] = \"swapLineDown\"] = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[ctrl + \"/\"] = \"toggleCommentIndented\"] = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds[map[ctrl + \"J\"] = \"joinLines\"] = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"D\"] = \"duplicateLine\"] = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  if (!mac) map[ctrl + \"T\"] = \"transposeChars\";\n\n  function sortLines(cm, caseSensitive) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds[map[\"F9\"] = \"sortLines\"] = function(cm) { sortLines(cm, true); };\n  cmds[map[ctrl + \"F9\"] = \"sortLinesInsensitive\"] = function(cm) { sortLines(cm, false); };\n\n  cmds[map[\"F2\"] = \"nextBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds[map[\"Shift-F2\"] = \"prevBookmark\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds[map[ctrl + \"F2\"] = \"toggleBookmark\"] = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds[map[\"Shift-\" + ctrl + \"F2\"] = \"clearBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds[map[\"Alt-F2\"] = \"selectBookmarks\"] = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  map[\"Alt-Q\"] = \"wrapLines\";\n\n  var cK = ctrl + \"K \";\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  map[cK + ctrl + \"Backspace\"] = \"delLineLeft\";\n\n  cmds[map[\"Backspace\"] = \"smartBackspace\"] = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds[map[cK + ctrl + \"K\"] = \"delLineRight\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds[map[cK + ctrl + \"U\"] = \"upcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds[map[cK + ctrl + \"L\"] = \"downcaseAtCursor\"] = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds[map[cK + ctrl + \"Space\"] = \"setSublimeMark\"] = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds[map[cK + ctrl + \"A\"] = \"selectToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds[map[cK + ctrl + \"W\"] = \"deleteToSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds[map[cK + ctrl + \"X\"] = \"swapWithSublimeMark\"] = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds[map[cK + ctrl + \"Y\"] = \"sublimeYank\"] = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  map[cK + ctrl + \"G\"] = \"clearBookmarks\";\n  cmds[map[cK + ctrl + \"C\"] = \"showInCenter\"] = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  var selectLinesCombo = mac ? \"Ctrl-Shift-\" : \"Ctrl-Alt-\";\n  cmds[map[selectLinesCombo + \"Up\"] = \"selectLinesUpward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line > cm.firstLine())\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\n      }\n    });\n  };\n  cmds[map[selectLinesCombo + \"Down\"] = \"selectLinesDownward\"] = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head.line < cm.lastLine())\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\n      }\n    });\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds[map[ctrl + \"F3\"] = \"findUnder\"] = function(cm) { findAndGoTo(cm, true); };\n  cmds[map[\"Shift-\" + ctrl + \"F3\"] = \"findUnderPrevious\"] = function(cm) { findAndGoTo(cm,false); };\n  cmds[map[\"Alt-F3\"] = \"findAllUnder\"] = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n  map[\"Shift-\" + ctrl + \"[\"] = \"fold\";\n  map[\"Shift-\" + ctrl + \"]\"] = \"unfold\";\n  map[cK + ctrl + \"0\"] = map[cK + ctrl + \"J\"] = \"unfoldAll\";\n\n  map[ctrl + \"I\"] = \"findIncremental\";\n  map[\"Shift-\" + ctrl + \"I\"] = \"findIncrementalReverse\";\n  map[ctrl + \"H\"] = \"replace\";\n  map[\"F3\"] = \"findNext\";\n  map[\"Shift-F3\"] = \"findPrev\";\n\n  CodeMirror.normalizeKeyMap(map);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/keymap/sublime.js\n// module id = 7Xsf\n// module chunks = 4 5","<template>\n  <el-dropdown @command=\"handleCommandDropdown\">\n    <el-input\n      class=\"search-input\"\n      placeholder=\"请输入要搜索的题目\"\n      icon=\"search\"\n      v-model.trim=\"mysearch\"\n      spellcheck=\"false\"\n      :on-icon-click=\"_onSearch\"\n      @change=\"_onSearch\"\n      @focus=\"_onSearch\">\n    </el-input>\n    <el-dropdown-menu slot=\"dropdown\">\n      <el-dropdown-item v-show=\"dropdownLoading\">拼命加载中...</el-dropdown-item>\n      <el-dropdown-item v-for=\"(item,index) in searchResult\" v-show=\"index <= 10 && !dropdownLoading\"\n                        :key=\"index\" :command=\"item.id\">\n        <span class=\"problem-item-title\">{{item.title}}</span>\n        <img width=\"16\" height=\"16 \" src=\"static/problem.png\" class=\"problem-item-img\">\n      </el-dropdown-item>\n    </el-dropdown-menu>\n  </el-dropdown>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import Problem from 'common/js/problem'\n  import axios from 'axios'\n  import { baseUrl } from 'common/js/data'\n  import { mapMutations } from 'vuex'\n\n  export default{\n    data() {\n      return {\n        mysearch: '',\n        dropdownLoading: false,\n        searchResult: []\n      }\n    },\n    methods: {\n      _onSearch() {\n        if (this.mysearch === '') {\n          this.searchResult = []\n          return\n        }\n        this.dropdownLoading = true\n        console.log('SearchClick')\n        let url = `${baseUrl}/search`\n        // 清空之前的结果\n        this.searchResult = []\n        axios.post(url, {\n          'target': 'Problem',\n          'content': this.mysearch,\n          'type': 'title'\n        }).then(response => {\n          if (response.data.result.length === 0) {\n            this.searchResult = [{title: `无法查询到含有关键字:${this.mysearch}的题目`}]\n          } else {\n            this.searchResult = response.data.result\n          }\n          this.dropdownLoading = false\n        }, response => {\n          console.log(response)\n          this._onSearch()\n        })\n      },\n      handleCommandDropdown(command) {\n        this.setProblem(new Problem({\n          id: command\n        }))\n        this.$router.push('/home/problem')\n      },\n      ...mapMutations({\n        setProblem: 'SET_PROBLEM'\n      })\n    }\n  }\n</script>\n\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n  .el-dropdown\n    .el-input\n      width 500px\n\n  .el-dropdown-menu__item\n    width auto\n    .problem-item-title\n      display inline-block\n    .problem-item-img\n      float right\n      margin-top 10px\n\n  .el-dropdown-menu\n    width 500px\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/search/search.vue?8e92a760","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-1ffcf786\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./manage-problems.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./manage-problems.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-1ffcf786\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./manage-problems.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-1ffcf786\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/manager/manage-problems.vue\n// module id = BUZr\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../dialog/dialog\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../dialog/dialog\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function searchOverlay(query, caseInsensitive) {\n    if (typeof query == \"string\")\n      query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\"), caseInsensitive ? \"gi\" : \"g\");\n    else if (!query.global)\n      query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\n\n    return {token: function(stream) {\n      query.lastIndex = stream.pos;\n      var match = query.exec(stream.string);\n      if (match && match.index == stream.pos) {\n        stream.pos += match[0].length || 1;\n        return \"searching\";\n      } else if (match) {\n        stream.pos = match.index;\n      } else {\n        stream.skipToEnd();\n      }\n    }};\n  }\n\n  function SearchState() {\n    this.posFrom = this.posTo = this.lastQuery = this.query = null;\n    this.overlay = null;\n  }\n\n  function getSearchState(cm) {\n    return cm.state.search || (cm.state.search = new SearchState());\n  }\n\n  function queryCaseInsensitive(query) {\n    return typeof query == \"string\" && query == query.toLowerCase();\n  }\n\n  function getSearchCursor(cm, query, pos) {\n    // Heuristic: if the query string is all lowercase, do a case insensitive search.\n    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});\n  }\n\n  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {\n    cm.openDialog(text, onEnter, {\n      value: deflt,\n      selectValueOnOpen: true,\n      closeOnEnter: false,\n      onClose: function() { clearSearch(cm); },\n      onKeyDown: onKeyDown\n    });\n  }\n\n  function dialog(cm, text, shortText, deflt, f) {\n    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});\n    else f(prompt(shortText, deflt));\n  }\n\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n\n  function parseString(string) {\n    return string.replace(/\\\\(.)/g, function(_, ch) {\n      if (ch == \"n\") return \"\\n\"\n      if (ch == \"r\") return \"\\r\"\n      return ch\n    })\n  }\n\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\n    if (isRE) {\n      try { query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\"); }\n      catch(e) {} // Not a regular expression after all, do a string search\n    } else {\n      query = parseString(query)\n    }\n    if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\n      query = /x^/;\n    return query;\n  }\n\n  var queryDialog =\n    '<span class=\"CodeMirror-search-label\">Search:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n\n  function startSearch(cm, state, query) {\n    state.queryText = query;\n    state.query = parseQuery(query);\n    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\n    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\n    cm.addOverlay(state.overlay);\n    if (cm.showMatchesOnScrollbar) {\n      if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\n    }\n  }\n\n  function doSearch(cm, rev, persistent, immediate) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    var q = cm.getSelection() || state.lastQuery;\n    if (persistent && cm.openDialog) {\n      var hiding = null\n      var searchNext = function(query, event) {\n        CodeMirror.e_stop(event);\n        if (!query) return;\n        if (query != state.queryText) {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n        }\n        if (hiding) hiding.style.opacity = 1\n        findNext(cm, event.shiftKey, function(_, to) {\n          var dialog\n          if (to.line < 3 && document.querySelector &&\n              (dialog = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) &&\n              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, \"window\").top)\n            (hiding = dialog).style.opacity = .4\n        })\n      };\n      persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {\n        var keyName = CodeMirror.keyName(event)\n        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName]\n        if (cmd == \"findNext\" || cmd == \"findPrev\" ||\n          cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\n          CodeMirror.e_stop(event);\n          startSearch(cm, getSearchState(cm), query);\n          cm.execCommand(cmd);\n        } else if (cmd == \"find\" || cmd == \"findPersistent\") {\n          CodeMirror.e_stop(event);\n          searchNext(query, event);\n        }\n      });\n      if (immediate && q) {\n        startSearch(cm, state, q);\n        findNext(cm, rev);\n      }\n    } else {\n      dialog(cm, queryDialog, \"Search for:\", q, function(query) {\n        if (query && !state.query) cm.operation(function() {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n          findNext(cm, rev);\n        });\n      });\n    }\n  }\n\n  function findNext(cm, rev, callback) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n    if (callback) callback(cursor.from(), cursor.to())\n  });}\n\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    state.lastQuery = state.query;\n    if (!state.query) return;\n    state.query = state.queryText = null;\n    cm.removeOverlay(state.overlay);\n    if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n  });}\n\n  var replaceQueryDialog =\n    ' <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">(Use /re/ syntax for regexp search)</span>';\n  var replacementQueryDialog = '<span class=\"CodeMirror-search-label\">With:</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/>';\n  var doReplaceConfirm = '<span class=\"CodeMirror-search-label\">Replace?</span> <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>';\n\n  function replaceAll(cm, query, text) {\n    cm.operation(function() {\n      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {\n        if (typeof query != \"string\") {\n          var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n          cursor.replace(text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n        } else cursor.replace(text);\n      }\n    });\n  }\n\n  function replace(cm, all) {\n    if (cm.getOption(\"readOnly\")) return;\n    var query = cm.getSelection() || getSearchState(cm).lastQuery;\n    var dialogText = '<span class=\"CodeMirror-search-label\">' + (all ? 'Replace all:' : 'Replace:') + '</span>';\n    dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, replacementQueryDialog, \"Replace with:\", \"\", function(text) {\n        text = parseString(text)\n        if (all) {\n          replaceAll(cm, query, text)\n        } else {\n          clearSearch(cm);\n          var cursor = getSearchCursor(cm, query, cm.getCursor(\"from\"));\n          var advance = function() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = getSearchCursor(cm, query);\n              if (!(match = cursor.findNext()) ||\n                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});\n            confirmDialog(cm, doReplaceConfirm, \"Replace?\",\n                          [function() {doReplace(match);}, advance,\n                           function() {replaceAll(cm, query, text)}]);\n          };\n          var doReplace = function(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n            advance();\n          };\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};\n  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};\n  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/search.js\n// module id = CK2l\n// module chunks = 4 5","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = EKta\n// module chunks = 5","<template>\n  <div class=\"problem-edit\">\n    <div class=\"panel\">\n      <div class=\"panel-heading\">\n        <i class=\"el-icon-arrow-left\" @click.stop=\"quit\"></i>\n        <h3 class=\"panel-title\" v-show=\"!isEdit\">创建题目</h3>\n        <h3 class=\"panel-title\" v-show=\"isEdit\">修改题目(ID:{{problem.id}})</h3>\n        <el-tag class=\"quit-tag\" type=\"danger\" @click.native.stop=\"quit\">退出</el-tag>\n      </div>\n      <div class=\"panel-body\">\n        <el-form ref=\"form\" :model=\"form\" label-width=\"80px\">\n          <el-form-item label=\"题目标题\">\n            <el-input class=\"short-input\" v-model=\"form.title\" spellcheck=\"false\" size=\"small\"></el-input>\n          </el-form-item>\n          <el-form-item label=\"题目标签\">\n            <el-input class=\"short-input\" v-model=\"form.tag\" spellcheck=\"false\" size=\"small\"></el-input>\n          </el-form-item>\n          <el-form-item label=\"题目难度\">\n            <el-radio-group v-model=\"form.level\">\n              <el-radio :label=\"1\">1</el-radio>\n              <el-radio :label=\"2\">2</el-radio>\n              <el-radio :label=\"3\">3</el-radio>\n              <el-radio :label=\"4\">4</el-radio>\n              <el-radio :label=\"5\">5</el-radio>\n            </el-radio-group>\n          </el-form-item>\n          <el-form-item label=\"题目描述\">\n            <mavon-editor v-model=\"form.description\" default_open=\"edit\" :toolbars=\"toolbars\">\n            </mavon-editor>\n          </el-form-item>\n          <el-form-item label=\"官方程序代码\">\n            <div class=\"program-edit\">\n              <codemirror\n                class=\"program-edit-inner\"\n                v-model=\"form.program\"\n                :options=\"editorOptions1\">\n              </codemirror>\n            </div>\n          </el-form-item>\n          <el-form-item label=\"输入样例\">\n            <el-input v-model=\"form.input\" spellcheck=\"false\"\n                      type=\"textarea\" :rows=\"5\" placeholder=\"Enter a sample input testcase\"></el-input>\n          </el-form-item>\n          <el-form-item label=\"输出样例\">\n            <el-input v-model=\"form.output\" spellcheck=\"false\"\n                      type=\"textarea\" :rows=\"5\" placeholder=\"Enter a sample output testcase\"></el-input>\n          </el-form-item>\n          <el-form-item label=\"模板选择\">\n            <el-checkbox-group v-model=\"form.checkLanguageList\">\n              <el-checkbox v-for=\"(item,index) in Languages\" :key=\"index\" :label=\"item\"></el-checkbox>\n            </el-checkbox-group>\n          </el-form-item>\n          <div class=\"editor-wrapper\">\n            <div class=\"dropdown-wrapper\">\n              <el-dropdown class=\"language-dropdown\" trigger=\"click\" @command=\"handleCommandLangage\"\n                           @visible-change=\"dropdownChange\"\n                           menu-align=\"start\">\n                <el-button type=\"primary\" size=\"small\">{{selectLanguage}}<i\n                  class=\"el-icon-caret-bottom el-icon--right\"></i>\n                </el-button>\n                <el-dropdown-menu slot=\"dropdown\">\n                  <el-dropdown-item v-for=\"(item , index) in Languages\" :key=\"index\" :command=\"index\">{{item}}\n                  </el-dropdown-item>\n                </el-dropdown-menu>\n              </el-dropdown>\n\n              <el-dropdown menu-align=\"start\" trigger=\"click\" class=\"el-dropdown-theme\" @command=\"handleCommandTheme\">\n                <el-button type=\"success\" size=\"small\">\n                  {{selectTheme}}<i class=\"el-icon-caret-bottom el-icon--right\"></i>\n                </el-button>\n                <el-dropdown-menu slot=\"dropdown\">\n                  <el-dropdown-item v-for=\"(item,index) in editorThemes\" :key=\"index\" :command=\"item\">{{item}}\n                  </el-dropdown-item>\n                </el-dropdown-menu>\n              </el-dropdown>\n            </div>\n            <div class=\"editor\">\n              <codemirror\n                ref=\"myEditor\"\n                v-model=\"code\"\n                :options=\"editorOptions2\">\n              </codemirror>\n            </div>\n            <el-button class=\"setup-btn\" @click=\"clickBtn\"\n                       type=\"success\" v-text=\"calcBtnText()\">\n            </el-button>\n          </div>\n        </el-form>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  // require active-line.js\n  require('codemirror/addon/selection/active-line.js')\n\n  // closebrackets\n  require('codemirror/addon/edit/closebrackets.js')\n\n  // styleSelectedText\n  require('codemirror/addon/selection/mark-selection.js')\n  require('codemirror/addon/search/searchcursor.js')\n\n  // hint\n  require('codemirror/addon/hint/show-hint.js')\n  require('codemirror/addon/hint/javascript-hint.js')\n  require('codemirror/addon/selection/active-line.js')\n\n  // highlightSelectionMatches\n  require('codemirror/addon/scroll/annotatescrollbar.js')\n  require('codemirror/addon/search/matchesonscrollbar.js')\n  require('codemirror/addon/search/searchcursor.js')\n  require('codemirror/addon/search/match-highlighter.js')\n\n  // keyMap\n  require('codemirror/mode/clike/clike.js')\n  require('codemirror/addon/edit/matchbrackets.js')\n  require('codemirror/addon/comment/comment.js')\n  require('codemirror/addon/dialog/dialog.js')\n  require('codemirror/addon/dialog/dialog.css')\n  require('codemirror/addon/search/searchcursor.js')\n  require('codemirror/addon/search/search.js')\n  require('codemirror/keymap/sublime.js')\n  require('codemirror/keymap/emacs.js')\n  require('codemirror/keymap/vim.js')\n\n  // foldGutter\n  require('codemirror/addon/fold/foldgutter.css')\n  require('codemirror/addon/fold/brace-fold.js')\n  require('codemirror/addon/fold/comment-fold.js')\n  require('codemirror/addon/fold/foldcode.js')\n  require('codemirror/addon/fold/foldgutter.js')\n  require('codemirror/addon/fold/indent-fold.js')\n  require('codemirror/addon/fold/markdown-fold.js')\n  require('codemirror/addon/fold/xml-fold.js')\n\n  // autoCloseTags\n  require('codemirror/addon/edit/closetag.js')\n\n  // 语法高亮，自行替换为你需要的语言\n  import 'codemirror/mode/javascript/javascript'\n  import 'codemirror/mode/go/go'\n  import 'codemirror/mode/python/python'\n  import 'codemirror/mode/ruby/ruby'\n  import 'codemirror/mode/clike/clike'\n\n  // Theme\n  import 'codemirror/theme/ambiance.css'\n  import 'codemirror/theme/base16-dark.css'\n  import 'codemirror/theme/cobalt.css'\n  import 'codemirror/theme/paraiso-light.css'\n  import 'codemirror/theme/paraiso-dark.css'\n  import 'codemirror/theme/rubyblue.css'\n  import 'codemirror/theme/solarized.css'\n  import 'codemirror/theme/mbo.css'\n\n  import { mapGetters, mapMutations } from 'vuex'\n  import { languages, editorThemes, editorModes, baseUrl, MSG_OK, MSG_NO } from 'common/js/data'\n  import axios from 'axios'\n\n  export default{\n    props: {\n      isEdit: {\n        type: Boolean,\n        default: false\n      }\n    },\n    data(){\n      return {\n        form: {\n          title: '',\n          description: '',\n          level: 1,\n          tag: '',\n          program: '',\n          input: '',\n          output: '',\n          checkLanguageList: ['C']\n        },\n        toolbars: {\n          bold: true, // 粗体\n          italic: true, // 斜体\n          header: true, // 标题\n          underline: true, // 下划线\n          strikethrough: true, // 中划线\n          mark: true, // 标记\n          quote: true, // 引用\n          ol: true, // 有序列表\n          ul: true, // 无序列表\n          link: true, // 链接\n          code: true, // code\n          table: true, // 表格\n          undo: true, // 上一步\n          redo: true, // 下一步\n          trash: true, // 清空\n          alignleft: true, // 左对齐\n          aligncenter: true, // 居中\n          alignright: true, // 右对齐\n          preview: true// 预览\n        },\n        editorOptions1: {\n          tabSize: 4,\n          mode: 'text/x-csrc',\n          theme: 'default',\n          lineNumbers: true,\n          line: true,\n          keyMap: 'sublime',\n          foldGutter: true,\n          gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n          // 选中文本自动高亮，及高亮方式\n          styleSelectedText: true,\n          highlightSelectionMatches: {showToken: /\\w/, annotateScrollbar: true}\n          // 如果有hint方面的配置，也应该出现在这里\n        },\n        editorOptions2: {\n          tabSize: 4,\n          mode: 'text/x-csrc',\n          theme: 'default',\n          lineNumbers: true,\n          line: true,\n          keyMap: 'sublime',\n          foldGutter: true,\n          gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n          // 选中文本自动高亮，及高亮方式\n          styleSelectedText: true,\n          highlightSelectionMatches: {showToken: /\\w/, annotateScrollbar: true}\n          // 如果有hint方面的配置，也应该出现在这里\n        },\n        editorThemes: editorThemes,\n        selectTheme: editorThemes[0],\n        Languages: languages,\n        selectLanguage: languages[0],\n        editorModes: editorModes,\n        code: '',\n        templetC: {value: 'c', text: 'C', defaultCode: ''},\n        templetCpp: {value: 'cpp', text: 'C++', defaultCode: ''},\n        templetCsharp: {value: 'csharp', text: 'C#', defaultCode: ''},\n        templetJava: {value: 'java', text: 'Java', defaultCode: ''},\n        templetPython: {value: 'python3', text: 'Python3', defaultCode: ''},\n        templetJs: {value: 'javascript', text: 'JavaScript', defaultCode: ''},\n        templetRuby: {value: 'ruby', text: 'Ruby', defaultCode: ''},\n        templetGolang: {value: 'golang', text: 'Go', defaultCode: ''},\n        newTitle: ''\n      }\n    },\n    methods: {\n      quit(){\n        this._clearAllData()\n        this.$emit('editFinish')\n      },\n      clickBtn(){\n        let Base64 = require('js-base64').Base64\n        //把最后一次模板templet加上\n        this._addTemplet()\n        let array = this._pushALLTemplets()\n        console.log(array)\n        let resultTemplets = []\n        for (let i = 0; i < this.form.checkLanguageList.length; i++) {\n          resultTemplets.push(array.find((item) => item.text === this.form.checkLanguageList[i]))\n        }\n        //console.log(resultTemplets)\n        console.log(this.isEdit)\n\n        if (this.isEdit) {\n          //修改题目\n          console.log('修改题目')\n          this.reviseProblem(Base64, resultTemplets)\n        } else {\n          //创建题目\n          this.setupProblem(Base64, resultTemplets)\n        }\n      },\n      setupProblem(Base64, resultTemplets){\n        let url = `${baseUrl}/problems`\n        axios.post(url, {\n          title: this.form.title,\n          description: this.form.description,\n          level: this.form.level + '',\n          tag: this.form.tag,\n          program: Base64.encode(this.form.program),\n          code: JSON.stringify(resultTemplets),\n          input: Base64.encode(this.form.input),\n          output: Base64.encode(this.form.output)\n        }).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.$notify({\n              title: '成功',\n              message: `成功创建题目:${response.data.result[0].title}`,\n              type: 'success'\n            })\n            //成功后清除数据\n            this._clearAllData()\n            this.$emit('editFinish')\n          } else if (response.data.msg === MSG_NO) {\n            this.$notify({\n              title: '创建失败',\n              message: `${response.data.error}`,\n              type: 'error'\n            })\n          }\n        }, response => {})\n      },\n      reviseProblem(Base64, resultTemplets){\n        let url = `${baseUrl}/problems/${this.problem.id}`\n        let resultTitle = this.form.title === this.newTitle ? null : this.form.title\n        if (resultTitle) {\n          this.reviseProblemWithTitle(url, Base64, resultTemplets)\n        } else {\n          this.reviseProblemWithoutTitle(url, Base64, resultTemplets)\n        }\n      },\n      reviseProblemWithTitle(url, Base64, resultTemplets){\n        axios.put(url, {\n          title: this.form.title,\n          description: this.form.description,\n          level: this.form.level + '',\n          tag: this.form.tag,\n          program: Base64.encode(this.form.program),\n          code: JSON.stringify(resultTemplets),\n          input: Base64.encode(this.form.input),\n          output: Base64.encode(this.form.output)\n        }).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.$notify({\n              title: '成功',\n              message: '修改题目成功',\n              type: 'success'\n            })\n            //成功后清除数据\n            this._clearAllData()\n            this.$emit('editFinish')\n          } else if (response.data.msg === MSG_NO) {\n            this.$notify({\n              title: '修改失败',\n              message: `${response.data.error}`,\n              type: 'error'\n            })\n          }\n        }, response => {})\n      },\n      reviseProblemWithoutTitle(url, Base64, resultTemplets){\n        axios.put(url, {\n          description: this.form.description,\n          level: this.form.level + '',\n          tag: this.form.tag,\n          program: Base64.encode(this.form.program),\n          code: JSON.stringify(resultTemplets),\n          input: Base64.encode(this.form.input),\n          output: Base64.encode(this.form.output)\n        }).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.$notify({\n              title: '成功',\n              message: '修改题目成功',\n              type: 'success'\n            })\n            //成功后清除数据\n            this._clearAllData()\n            this.$emit('editFinish')\n          } else if (response.data.msg === MSG_NO) {\n            this.$notify({\n              title: '修改失败',\n              message: `${response.data.error}`,\n              type: 'error'\n            })\n          }\n        }, response => {})\n      },\n      _clearAllData(){\n        //清除所有数据 回到默认状态\n        this.form.title = ''\n        this.form.description = ''\n        this.form.level = 1\n        this.form.tag = ''\n        this.form.program = ''\n        this.form.input = ''\n        this.form.output = ''\n        this.form.checkLanguageList = ['C']\n        this.code = ''\n        this.selectTheme = editorThemes[0]\n        this.selectLanguage = languages[0]\n        this.editorOptions2.mode = this.editorModes[0]\n        this.editorOptions2.theme = this.selectTheme\n        this.templetC = {value: 'c', text: 'C', defaultCode: ''}\n        this.templetCpp = {value: 'cpp', text: 'C++', defaultCode: ''}\n        this.templetCsharp = {value: 'csharp', text: 'C#', defaultCode: ''}\n        this.templetJava = {value: 'java', text: 'Java', defaultCode: ''}\n        this.templetPython = {value: 'python3', text: 'Python3', defaultCode: ''}\n        this.templetJs = {value: 'javascript', text: 'JavaScript', defaultCode: ''}\n        this.templetRuby = {value: 'ruby', text: 'Ruby', defaultCode: ''}\n        this.templetGolang = {value: 'golang', text: 'Go', defaultCode: ''}\n        //最后清空vuex中的Templets\n        this.setTemplets([])\n      },\n      handleCommandLangage(index) {\n        //切换语言\n        console.log('xuan ' + index)\n        this.editorOptions2.mode = this.editorModes[index]\n        this.selectLanguage = this.Languages[index]\n        //如果之前(一次编辑中)写过code   那么code=之前的对应的templet的defaultCode\n        let result = this.templets.find((item) => item && item.text === this.selectLanguage)\n        if (result) {\n          this.code = result.defaultCode\n        } else {\n          this.code = ''\n        }\n      },\n      dropdownChange(isShow) {\n        //当语言下拉菜单状态改变\n        if (isShow) {\n          //当语言下拉菜单展开\n          this._addTemplet()\n          let res = this._pushALLTemplets()\n          //  这里有bug (showPromblemInfo获取了setTemplets 这里又修改了Templets )\n          //   解决：在此之前 每个对应模板加入相应的的数据\n          this.setTemplets(res)\n        }\n      },\n      _pushALLTemplets(){\n        //把所有模板集合成一个数组返回\n        let result = []\n        result.push(this.templetC)\n        result.push(this.templetCpp)\n        result.push(this.templetCsharp)\n        result.push(this.templetJava)\n        result.push(this.templetPython)\n        result.push(this.templetJs)\n        result.push(this.templetRuby)\n        result.push(this.templetGolang)\n        return result\n      },\n      _addTemplet(){\n        //把code加入到当前选中的语言的 对应的语言模板的defaultCode中\n        if (this.selectLanguage === 'C') {\n          this.templetC.defaultCode = this.code\n        } else if (this.selectLanguage === 'C++') {\n          this.templetCpp.defaultCode = this.code\n        } else if (this.selectLanguage === 'C#') {\n          this.templetCsharp.defaultCode = this.code\n        } else if (this.selectLanguage === 'Java') {\n          this.templetJava.defaultCode = this.code\n        } else if (this.selectLanguage === 'Python3') {\n          this.templetPython.defaultCode = this.code\n        } else if (this.selectLanguage === 'JavaScript') {\n          this.templetJs.defaultCode = this.code\n        } else if (this.selectLanguage === 'Ruby') {\n          this.templetRuby.defaultCode = this.code\n        } else if (this.selectLanguage === 'Go') {\n          this.templetGolang.defaultCode = this.code\n        }\n      },\n      showPromblemInfo(){\n        this._clearAllData()\n        //处于编辑题目模式 先展示出题目信息\n        let url1 = `${baseUrl}/problems/${this.problem.id}`\n        axios.get(url1).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.form.title = response.data.result[0].title\n            this.newTitle = response.data.result[0].title\n            this.form.description = response.data.result[0].description\n            this.form.level = response.data.result[0].level\n            this.form.tag = response.data.result[0].tag\n          }\n        }, response => {})\n        let url2 = `${baseUrl}/problems/${this.problem.id}/codes`\n        axios.get(url2).then(response => {\n          if (response.data.msg === MSG_OK) {\n            console.log(JSON.parse(response.data.result[0].code))\n            this.setTemplets(JSON.parse(response.data.result[0].code))\n            //templetC templetCpp templetCsharp... 加入对应的数据 明天写。\n            this.changeTemplets()\n          }\n        }, response => {})\n        this.getProblemStd()\n      },\n      getProblemStd(){\n        let Base64 = require('js-base64').Base64\n        let url = `${baseUrl}/problems/${this.problem.id}/std`\n        axios.get(url).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.form.input = Base64.decode(response.data.result[0].input)\n            this.form.output = Base64.decode(response.data.result[0].output)\n            this.form.program = Base64.decode(response.data.result[0].program)\n            console.log(response.data.result[0])\n          }\n        }, response => {})\n      },\n      changeTemplets(){\n        this.form.checkLanguageList = []\n        let tempC = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'C'\n          }\n        })\n        if (tempC) {\n          this.templetC = tempC\n          this.form.checkLanguageList.push(this.templetC.text)\n        }\n\n        let tempCpp = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'C++'\n          }\n        })\n        if (tempCpp) {\n          this.templetCpp = tempCpp\n          this.form.checkLanguageList.push(this.templetCpp.text)\n        }\n\n        let tempCsharp = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'C#'\n          }\n        })\n        if (tempCsharp) {\n          this.templetCsharp = tempCsharp\n          this.form.checkLanguageList.push(this.templetCsharp.text)\n        }\n\n        let tempJava = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'Java'\n          }\n        })\n        if (tempJava) {\n          this.templetJava = tempJava\n          this.form.checkLanguageList.push(this.templetJava.text)\n        }\n        let tempPython = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'Python3'\n          }\n        })\n        if (tempPython) {\n          this.templetPython = tempPython\n          this.form.checkLanguageList.push(this.templetPython.text)\n        }\n\n        let tempJs = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'JavaScript'\n          }\n        })\n        if (tempJs) {\n          this.templetJs = tempJs\n          this.form.checkLanguageList.push(this.templetJs.text)\n        }\n\n        let tempRuby = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'Ruby'\n          }\n        })\n        if (tempRuby) {\n          this.templetRuby = tempRuby\n          this.form.checkLanguageList.push(this.templetRuby.text)\n        }\n\n        let tempGo = this.templets.find((item) => {\n          if (item) {\n            return item.text === 'Go'\n          }\n        })\n        if (tempGo) {\n          this.templetGolang = tempGo\n          this.form.checkLanguageList.push(this.templetGolang.text)\n        }\n\n        this.code = this.templets.find((item) => item && item.text === this.selectLanguage).defaultCode || ''\n      },\n      calcBtnText(){\n        //计算btn的文字\n        if (this.isEdit) {\n          return '修改题目'\n        } else {\n          return '创建题目'\n        }\n      },\n      handleCommandTheme(command){\n        //修改主题\n        this.editorOptions2.theme = command\n        this.selectTheme = command\n      },\n      ...mapMutations({\n        setTemplets: 'SET_TEMPLETS'\n      })\n    },\n    computed: {\n      ...mapGetters([\n        'problem',\n        'templets'\n      ])\n    }\n  }\n</script>\n\n<style lang=\"stylus\" scoped rel=\"stylesheet/stylus\">\n\n  .problem-edit\n    .panel\n      border-radius: 5px;\n      margin-bottom: 20px;\n      background-color: #fff;\n      border: 1px solid #ddd;\n      -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, .05);\n      box-shadow: 0 1px 1px rgba(0, 0, 0, .05);\n      .panel-heading\n        padding: 10px 15px;\n        color: #333;\n        background-color: #f5f5f5;\n        border-color: #ddd;\n        border-top-left-radius: 5px;\n        border-top-right-radius: 5px;\n        border-bottom: 1px solid transparent;\n        .el-icon-arrow-left\n          color: lightsteelblue\n          &:hover\n            cursor pointer\n        .panel-title\n          display inline-block\n          margin-left 5px\n          margin-top 0\n          margin-bottom 0\n          font-size: 18px;\n          color: inherit;\n          font-weight: 500;\n          line-height: 1.1;\n        .quit-tag\n          float right\n          &:hover\n            cursor pointer\n      .panel-body\n        padding: 15px 45px;\n        .el-form\n          .el-form-item\n            margin-right 10%\n            .program-edit\n              display inline-block\n              width 83%\n              border 1px solid #ddd\n            .short-input\n              width 50%\n          .editor-wrapper\n            position relative\n            .dropdown-wrapper\n              position absolute\n              top: 0\n              left 0\n              display inline-block\n              .language-dropdown\n                margin-right 5px\n            .editor\n              margin-left 205px\n              display inline-block\n              width 70%\n              border 1px solid #ddd\n              .CodeMirror\n                height 330px\n            .setup-btn\n              position relative\n              left 10px\n              bottom 10px\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/manager/manage-problem-edit.vue?b5327fc8","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = EuP9\n// module chunks = 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-49e52881\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./manage-problem-edit.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./manage-problem-edit.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-49e52881\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./manage-problem-edit.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-49e52881\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/manager/manage-problem-edit.vue\n// module id = HbqP\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; };\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '['};\n        var selfPaired = {'\\'': true, '\"': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /-?\\d+/g;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        var token;\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0];\n          start = match.index;\n          end = start + token.length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1;\n          var number = parseInt(token) + (increment * actionArgs.repeat);\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          numberStr = number.toString();\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /**\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      var slashes = findUnescapedSlashes(argString) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSlashes(str) {\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySlash(argString) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); };\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n             i++;\n          } else {\n             i+= selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      };\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n            } else {\n                lastChange.changes.push(text);\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    };\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/keymap/vim.js\n// module id = Hyg2\n// module chunks = 4 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('el-dialog', {\n    attrs: {\n      \"title\": \"提示\",\n      \"visible\": _vm.visible\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.visible = $event\n      }\n    }\n  }, [_c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(_vm._s(_vm.text))]), _vm._v(\" \"), _c('span', {\n    staticClass: \"dialog-footer\",\n    slot: \"footer\"\n  }, [_c('el-button', {\n    on: {\n      \"click\": _vm.cancel\n    }\n  }, [_vm._v(_vm._s(_vm.cancelBtnText))]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": _vm.confirm\n    }\n  }, [_vm._v(_vm._s(_vm.confirmBtnText))])], 1)])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-48f25eaf\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/base/confirm/confirm.vue\n// module id = IruO\n// module chunks = 0 1 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-48f25eaf\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./confirm.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"013a4c5f\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-48f25eaf\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/base/confirm/confirm.vue\n// module id = JM2O\n// module chunks = 0 1 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/foldgutter.js\n// module id = Kk9m\n// module chunks = 4 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/index.js??ref--6-2!./dialog.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../vue-style-loader/lib/addStylesClient.js\")(\"e2c66042\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/dialog/dialog.css\n// module id = LxZp\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch continue debugger default delete do else false finally for function \" +\n                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/hint/javascript-hint.js\n// module id = Mixr\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./matchesonscrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query + \"\\\\b\") : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/match-highlighter.js\n// module id = OkRY\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"annotateScrollbar\", function(options) {\n    if (typeof options == \"string\") options = {className: options};\n    return new Annotation(this, options);\n  });\n\n  CodeMirror.defineOption(\"scrollButtonHeight\", 0);\n\n  function Annotation(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.buttonHeight = options.scrollButtonHeight || cm.getOption(\"scrollButtonHeight\");\n    this.annotations = [];\n    this.doRedraw = this.doUpdate = null;\n    this.div = cm.getWrapperElement().appendChild(document.createElement(\"div\"));\n    this.div.style.cssText = \"position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none\";\n    this.computeScale();\n\n    function scheduleRedraw(delay) {\n      clearTimeout(self.doRedraw);\n      self.doRedraw = setTimeout(function() { self.redraw(); }, delay);\n    }\n\n    var self = this;\n    cm.on(\"refresh\", this.resizeHandler = function() {\n      clearTimeout(self.doUpdate);\n      self.doUpdate = setTimeout(function() {\n        if (self.computeScale()) scheduleRedraw(20);\n      }, 100);\n    });\n    cm.on(\"markerAdded\", this.resizeHandler);\n    cm.on(\"markerCleared\", this.resizeHandler);\n    if (options.listenForChanges !== false)\n      cm.on(\"change\", this.changeHandler = function() {\n        scheduleRedraw(250);\n      });\n  }\n\n  Annotation.prototype.computeScale = function() {\n    var cm = this.cm;\n    var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) /\n      cm.getScrollerElement().scrollHeight\n    if (hScale != this.hScale) {\n      this.hScale = hScale;\n      return true;\n    }\n  };\n\n  Annotation.prototype.update = function(annotations) {\n    this.annotations = annotations;\n    this.redraw();\n  };\n\n  Annotation.prototype.redraw = function(compute) {\n    if (compute !== false) this.computeScale();\n    var cm = this.cm, hScale = this.hScale;\n\n    var frag = document.createDocumentFragment(), anns = this.annotations;\n\n    var wrapping = cm.getOption(\"lineWrapping\");\n    var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;\n    var curLine = null, curLineObj = null;\n    function getY(pos, top) {\n      if (curLine != pos.line) {\n        curLine = pos.line;\n        curLineObj = cm.getLineHandle(curLine);\n      }\n      if ((curLineObj.widgets && curLineObj.widgets.length) ||\n          (wrapping && curLineObj.height > singleLineH))\n        return cm.charCoords(pos, \"local\")[top ? \"top\" : \"bottom\"];\n      var topY = cm.heightAtLine(curLineObj, \"local\");\n      return topY + (top ? 0 : curLineObj.height);\n    }\n\n    var lastLine = cm.lastLine()\n    if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {\n      var ann = anns[i];\n      if (ann.to.line > lastLine) continue;\n      var top = nextTop || getY(ann.from, true) * hScale;\n      var bottom = getY(ann.to, false) * hScale;\n      while (i < anns.length - 1) {\n        if (anns[i + 1].to.line > lastLine) break;\n        nextTop = getY(anns[i + 1].from, true) * hScale;\n        if (nextTop > bottom + .9) break;\n        ann = anns[++i];\n        bottom = getY(ann.to, false) * hScale;\n      }\n      if (bottom == top) continue;\n      var height = Math.max(bottom - top, 3);\n\n      var elt = frag.appendChild(document.createElement(\"div\"));\n      elt.style.cssText = \"position: absolute; right: 0px; width: \" + Math.max(cm.display.barWidth - 1, 2) + \"px; top: \"\n        + (top + this.buttonHeight) + \"px; height: \" + height + \"px\";\n      elt.className = this.options.className;\n      if (ann.id) {\n        elt.setAttribute(\"annotation-id\", ann.id);\n      }\n    }\n    this.div.textContent = \"\";\n    this.div.appendChild(frag);\n  };\n\n  Annotation.prototype.clear = function() {\n    this.cm.off(\"refresh\", this.resizeHandler);\n    this.cm.off(\"markerAdded\", this.resizeHandler);\n    this.cm.off(\"markerCleared\", this.resizeHandler);\n    if (this.changeHandler) this.cm.off(\"change\", this.changeHandler);\n    this.div.parentNode.removeChild(this.div);\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/scroll/annotatescrollbar.js\n// module id = QSKu\n// module chunks = 4 5","exports = module.exports = require(\"../../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror-dialog{position:absolute;left:0;right:0;background:inherit;z-index:15;padding:.1em .8em;overflow:hidden;color:inherit}.CodeMirror-dialog-top{border-bottom:1px solid #eee;top:0}.CodeMirror-dialog-bottom{border-top:1px solid #eee;bottom:0}.CodeMirror-dialog input{border:none;outline:none;background:transparent;width:20em;color:inherit;font-family:monospace}.CodeMirror-dialog button{font-size:70%}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/dialog/dialog.css\"],\"names\":[],\"mappings\":\"AAAA,mBACE,kBAAmB,AACnB,OAAQ,AAAC,QAAS,AAClB,mBAAoB,AACpB,WAAY,AACZ,kBAAmB,AACnB,gBAAiB,AACjB,aAAe,CAChB,AAED,uBACE,6BAA8B,AAC9B,KAAO,CACR,AAED,0BACE,0BAA2B,AAC3B,QAAU,CACX,AAED,yBACE,YAAa,AACb,aAAc,AACd,uBAAwB,AACxB,WAAY,AACZ,cAAe,AACf,qBAAuB,CACxB,AAED,0BACE,aAAe,CAChB\",\"file\":\"dialog.css\",\"sourcesContent\":[\".CodeMirror-dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n\\n.CodeMirror-dialog-top {\\n  border-bottom: 1px solid #eee;\\n  top: 0;\\n}\\n\\n.CodeMirror-dialog-bottom {\\n  border-top: 1px solid #eee;\\n  bottom: 0;\\n}\\n\\n.CodeMirror-dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\\n\\n.CodeMirror-dialog button {\\n  font-size: 70%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/codemirror/addon/dialog/dialog.css\n// module id = RkAk\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/dialog/dialog.js\n// module id = RkhK\n// module chunks = 4 5","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".el-dropdown .el-input[data-v-2d96e4b2]{width:500px}.el-dropdown-menu__item[data-v-2d96e4b2]{width:auto}.el-dropdown-menu__item .problem-item-title[data-v-2d96e4b2]{display:inline-block}.el-dropdown-menu__item .problem-item-img[data-v-2d96e4b2]{float:right;margin-top:10px}.el-dropdown-menu[data-v-2d96e4b2]{width:500px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/search/search.vue\"],\"names\":[],\"mappings\":\"AACA,wCACE,WAAa,CACd,AACD,yCACE,UAAY,CACb,AACD,6DACE,oBAAsB,CACvB,AACD,2DACE,YAAa,AACb,eAAiB,CAClB,AACD,mCACE,WAAa,CACd\",\"file\":\"search.vue\",\"sourcesContent\":[\"\\n.el-dropdown .el-input[data-v-2d96e4b2] {\\n  width: 500px;\\n}\\n.el-dropdown-menu__item[data-v-2d96e4b2] {\\n  width: auto;\\n}\\n.el-dropdown-menu__item .problem-item-title[data-v-2d96e4b2] {\\n  display: inline-block;\\n}\\n.el-dropdown-menu__item .problem-item-img[data-v-2d96e4b2] {\\n  float: right;\\n  margin-top: 10px;\\n}\\n.el-dropdown-menu[data-v-2d96e4b2] {\\n  width: 500px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-2d96e4b2\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/search/search.vue\n// module id = RrKZ\n// module chunks = 2 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-1ffcf786\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./manage-problems.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"a0ec5c32\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-1ffcf786\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/manager/manage-problems.vue\n// module id = S1i8\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/foldcode.js\n// module id = THjC\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter), end;\n      if (!openTag || iter.line != start.line || !(end = toTagEnd(iter))) return;\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && {from: startPos, to: endPos.from};\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/xml-fold.js\n// module id = TQy8\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction lineIndent(cm, lineNo) {\n  var text = cm.getLine(lineNo)\n  var spaceTo = text.search(/\\S/)\n  if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))\n    return -1\n  return CodeMirror.countColumn(text, null, cm.getOption(\"tabSize\"))\n}\n\nCodeMirror.registerHelper(\"fold\", \"indent\", function(cm, start) {\n  var myIndent = lineIndent(cm, start.line)\n  if (myIndent < 0) return\n  var lastLineInFold = null\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    var indent = lineIndent(cm, i)\n    if (indent == -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) return {\n    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n  };\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/indent-fold.js\n// module id = U3HU\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    if (cm.state.markedSelection)\n      cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/selection/mark-selection.js\n// module id = U80t\n// module chunks = 4 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-48f25eaf\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./confirm.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./confirm.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-48f25eaf\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./confirm.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-48f25eaf\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/base/confirm/confirm.vue\n// module id = XEAW\n// module chunks = 0 1 5","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-2d96e4b2\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!stylus-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./search.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./search.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-2d96e4b2\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./search.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-2d96e4b2\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/search/search.vue\n// module id = YOyO\n// module chunks = 2 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/index.js??ref--6-2!./foldgutter.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../vue-style-loader/lib/addStylesClient.js\")(\"da13b76a\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/foldgutter.css\n// module id = Yokd\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  // Rough heuristic to try and detect lines that are part of multi-line string\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode()\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\n    if (open == -1) return false\n    var endLine = end == start ? startLine : self.getLine(end)\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    if (close == -1 && start != end) {\n      endLine = self.getLine(--end);\n      close = endLine.indexOf(endString);\n    }\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\n    if (close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/comment/comment.js\n// module id = Z6qg\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var WRAP_CLASS = \"CodeMirror-activeline\";\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\n  var GUTT_CLASS = \"CodeMirror-activeline-gutter\";\n\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n    var prev = old == CodeMirror.Init ? false : old;\n    if (val == prev) return\n    if (prev) {\n      cm.off(\"beforeSelectionChange\", selectionChange);\n      clearActiveLines(cm);\n      delete cm.state.activeLines;\n    }\n    if (val) {\n      cm.state.activeLines = [];\n      updateActiveLines(cm, cm.listSelections());\n      cm.on(\"beforeSelectionChange\", selectionChange);\n    }\n  });\n\n  function clearActiveLines(cm) {\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\n      cm.removeLineClass(cm.state.activeLines[i], \"wrap\", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"background\", BACK_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"gutter\", GUTT_CLASS);\n    }\n  }\n\n  function sameArray(a, b) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++)\n      if (a[i] != b[i]) return false;\n    return true;\n  }\n\n  function updateActiveLines(cm, ranges) {\n    var active = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var option = cm.getOption(\"styleActiveLine\");\n      if (typeof option == \"object\" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n        continue\n      var line = cm.getLineHandleVisualStart(range.head.line);\n      if (active[active.length - 1] != line) active.push(line);\n    }\n    if (sameArray(cm.state.activeLines, active)) return;\n    cm.operation(function() {\n      clearActiveLines(cm);\n      for (var i = 0; i < active.length; i++) {\n        cm.addLineClass(active[i], \"wrap\", WRAP_CLASS);\n        cm.addLineClass(active[i], \"background\", BACK_CLASS);\n        cm.addLineClass(active[i], \"gutter\", GUTT_CLASS);\n      }\n      cm.state.activeLines = active;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLines(cm, sel.ranges);\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/selection/active-line.js\n// module id = aGTD\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var defaults = {\n    pairs: \"()[]{}''\\\"\\\"\",\n    triples: \"\",\n    explode: \"[]{}\"\n  };\n\n  var Pos = CodeMirror.Pos;\n\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.removeKeyMap(keyMap);\n      cm.state.closeBrackets = null;\n    }\n    if (val) {\n      cm.state.closeBrackets = val;\n      cm.addKeyMap(keyMap);\n    }\n  });\n\n  function getOption(conf, name) {\n    if (name == \"pairs\" && typeof conf == \"string\") return conf;\n    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\n    return defaults[name];\n  }\n\n  var bind = defaults.pairs + \"`\";\n  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n  for (var i = 0; i < bind.length; i++)\n    keyMap[\"'\" + bind.charAt(i) + \"'\"] = handler(bind.charAt(i));\n\n  function handler(ch) {\n    return function(cm) { return handleChar(cm, ch); };\n  }\n\n  function getConfig(cm) {\n    var deflt = cm.state.closeBrackets;\n    if (!deflt || deflt.override) return deflt;\n    var mode = cm.getModeAt(cm.getCursor());\n    return mode.closeBrackets || deflt;\n  }\n\n  function handleBackspace(cm) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var cur = ranges[i].head;\n      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), \"+delete\");\n    }\n  }\n\n  function handleEnter(cm) {\n    var conf = getConfig(cm);\n    var explode = conf && getOption(conf, \"explode\");\n    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    cm.operation(function() {\n      cm.replaceSelection(\"\\n\\n\", null);\n      cm.execCommand(\"goCharLeft\");\n      ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var line = ranges[i].head.line;\n        cm.indentLine(line, null, true);\n        cm.indentLine(line + 1, null, true);\n      }\n    });\n  }\n\n  function contractSelection(sel) {\n    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n  }\n\n  function handleChar(cm, ch) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var pos = pairs.indexOf(ch);\n    if (pos == -1) return CodeMirror.Pass;\n    var triples = getOption(conf, \"triples\");\n\n    var identical = pairs.charAt(pos + 1) == ch;\n    var ranges = cm.listSelections();\n    var opening = pos % 2 == 0;\n\n    var type;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], cur = range.head, curType;\n      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n      if (opening && !range.empty()) {\n        curType = \"surround\";\n      } else if ((identical || !opening) && next == ch) {\n        if (identical && stringStartsAfter(cm, cur))\n          curType = \"both\";\n        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n          curType = \"skipThree\";\n        else\n          curType = \"skip\";\n      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch &&\n                 (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != ch)) {\n        curType = \"addFour\";\n      } else if (identical) {\n        if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, ch)) curType = \"both\";\n        else return CodeMirror.Pass;\n      } else if (opening && (cm.getLine(cur.line).length == cur.ch ||\n                             isClosingBracket(next, pairs) ||\n                             /\\s/.test(next))) {\n        curType = \"both\";\n      } else {\n        return CodeMirror.Pass;\n      }\n      if (!type) type = curType;\n      else if (type != curType) return CodeMirror.Pass;\n    }\n\n    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n    cm.operation(function() {\n      if (type == \"skip\") {\n        cm.execCommand(\"goCharRight\");\n      } else if (type == \"skipThree\") {\n        for (var i = 0; i < 3; i++)\n          cm.execCommand(\"goCharRight\");\n      } else if (type == \"surround\") {\n        var sels = cm.getSelections();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = left + sels[i] + right;\n        cm.replaceSelections(sels, \"around\");\n        sels = cm.listSelections().slice();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = contractSelection(sels[i]);\n        cm.setSelections(sels);\n      } else if (type == \"both\") {\n        cm.replaceSelection(left + right, null);\n        cm.triggerElectric(left + right);\n        cm.execCommand(\"goCharLeft\");\n      } else if (type == \"addFour\") {\n        cm.replaceSelection(left + left + left + left, \"before\");\n        cm.execCommand(\"goCharRight\");\n      }\n    });\n  }\n\n  function isClosingBracket(ch, pairs) {\n    var pos = pairs.lastIndexOf(ch);\n    return pos > -1 && pos % 2 == 1;\n  }\n\n  function charsAround(cm, pos) {\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n                          Pos(pos.line, pos.ch + 1));\n    return str.length == 2 ? str : null;\n  }\n\n  // Project the token type that will exists after the given char is\n  // typed, and use it to determine whether it would cause the start\n  // of a string token.\n  function enteringString(cm, pos, ch) {\n    var line = cm.getLine(pos.line);\n    var token = cm.getTokenAt(pos);\n    if (/\\bstring2?\\b/.test(token.type) || stringStartsAfter(cm, pos)) return false;\n    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\n    stream.pos = stream.start = token.start;\n    for (;;) {\n      var type1 = cm.getMode().token(stream, token.state);\n      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\n      stream.start = stream.pos;\n    }\n  }\n\n  function stringStartsAfter(cm, pos) {\n    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))\n    return /\\bstring/.test(token.type) && token.start == pos.ch\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/edit/closebrackets.js\n// module id = aX1R\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureGlobal(regexp) {\n    return regexp.global ? regexp : new RegExp(regexp.source, regexpFlags(regexp) + \"g\")\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureGlobal(regexp)\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (end.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureGlobal(query)\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/search/searchcursor.js\n// module id = c+I8\n// module chunks = 4 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"problem-edit\"\n  }, [_c('div', {\n    staticClass: \"panel\"\n  }, [_c('div', {\n    staticClass: \"panel-heading\"\n  }, [_c('i', {\n    staticClass: \"el-icon-arrow-left\",\n    on: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.quit($event)\n      }\n    }\n  }), _vm._v(\" \"), _c('h3', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.isEdit),\n      expression: \"!isEdit\"\n    }],\n    staticClass: \"panel-title\"\n  }, [_vm._v(\"创建题目\")]), _vm._v(\" \"), _c('h3', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.isEdit),\n      expression: \"isEdit\"\n    }],\n    staticClass: \"panel-title\"\n  }, [_vm._v(\"修改题目(ID:\" + _vm._s(_vm.problem.id) + \")\")]), _vm._v(\" \"), _c('el-tag', {\n    staticClass: \"quit-tag\",\n    attrs: {\n      \"type\": \"danger\"\n    },\n    nativeOn: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.quit($event)\n      }\n    }\n  }, [_vm._v(\"退出\")])], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"panel-body\"\n  }, [_c('el-form', {\n    ref: \"form\",\n    attrs: {\n      \"model\": _vm.form,\n      \"label-width\": \"80px\"\n    }\n  }, [_c('el-form-item', {\n    attrs: {\n      \"label\": \"题目标题\"\n    }\n  }, [_c('el-input', {\n    staticClass: \"short-input\",\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"size\": \"small\"\n    },\n    model: {\n      value: (_vm.form.title),\n      callback: function($$v) {\n        _vm.form.title = $$v\n      },\n      expression: \"form.title\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"题目标签\"\n    }\n  }, [_c('el-input', {\n    staticClass: \"short-input\",\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"size\": \"small\"\n    },\n    model: {\n      value: (_vm.form.tag),\n      callback: function($$v) {\n        _vm.form.tag = $$v\n      },\n      expression: \"form.tag\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"题目难度\"\n    }\n  }, [_c('el-radio-group', {\n    model: {\n      value: (_vm.form.level),\n      callback: function($$v) {\n        _vm.form.level = $$v\n      },\n      expression: \"form.level\"\n    }\n  }, [_c('el-radio', {\n    attrs: {\n      \"label\": 1\n    }\n  }, [_vm._v(\"1\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 2\n    }\n  }, [_vm._v(\"2\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 3\n    }\n  }, [_vm._v(\"3\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 4\n    }\n  }, [_vm._v(\"4\")]), _vm._v(\" \"), _c('el-radio', {\n    attrs: {\n      \"label\": 5\n    }\n  }, [_vm._v(\"5\")])], 1)], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"题目描述\"\n    }\n  }, [_c('mavon-editor', {\n    attrs: {\n      \"default_open\": \"edit\",\n      \"toolbars\": _vm.toolbars\n    },\n    model: {\n      value: (_vm.form.description),\n      callback: function($$v) {\n        _vm.form.description = $$v\n      },\n      expression: \"form.description\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"官方程序代码\"\n    }\n  }, [_c('div', {\n    staticClass: \"program-edit\"\n  }, [_c('codemirror', {\n    staticClass: \"program-edit-inner\",\n    attrs: {\n      \"options\": _vm.editorOptions1\n    },\n    model: {\n      value: (_vm.form.program),\n      callback: function($$v) {\n        _vm.form.program = $$v\n      },\n      expression: \"form.program\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"输入样例\"\n    }\n  }, [_c('el-input', {\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"type\": \"textarea\",\n      \"rows\": 5,\n      \"placeholder\": \"Enter a sample input testcase\"\n    },\n    model: {\n      value: (_vm.form.input),\n      callback: function($$v) {\n        _vm.form.input = $$v\n      },\n      expression: \"form.input\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"输出样例\"\n    }\n  }, [_c('el-input', {\n    attrs: {\n      \"spellcheck\": \"false\",\n      \"type\": \"textarea\",\n      \"rows\": 5,\n      \"placeholder\": \"Enter a sample output testcase\"\n    },\n    model: {\n      value: (_vm.form.output),\n      callback: function($$v) {\n        _vm.form.output = $$v\n      },\n      expression: \"form.output\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-form-item', {\n    attrs: {\n      \"label\": \"模板选择\"\n    }\n  }, [_c('el-checkbox-group', {\n    model: {\n      value: (_vm.form.checkLanguageList),\n      callback: function($$v) {\n        _vm.form.checkLanguageList = $$v\n      },\n      expression: \"form.checkLanguageList\"\n    }\n  }, _vm._l((_vm.Languages), function(item, index) {\n    return _c('el-checkbox', {\n      key: index,\n      attrs: {\n        \"label\": item\n      }\n    })\n  }))], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"editor-wrapper\"\n  }, [_c('div', {\n    staticClass: \"dropdown-wrapper\"\n  }, [_c('el-dropdown', {\n    staticClass: \"language-dropdown\",\n    attrs: {\n      \"trigger\": \"click\",\n      \"menu-align\": \"start\"\n    },\n    on: {\n      \"command\": _vm.handleCommandLangage,\n      \"visible-change\": _vm.dropdownChange\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\",\n      \"size\": \"small\"\n    }\n  }, [_vm._v(_vm._s(_vm.selectLanguage)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.Languages), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": index\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n                \")])\n  }))], 1), _vm._v(\" \"), _c('el-dropdown', {\n    staticClass: \"el-dropdown-theme\",\n    attrs: {\n      \"menu-align\": \"start\",\n      \"trigger\": \"click\"\n    },\n    on: {\n      \"command\": _vm.handleCommandTheme\n    }\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"success\",\n      \"size\": \"small\"\n    }\n  }, [_vm._v(\"\\n                \" + _vm._s(_vm.selectTheme)), _c('i', {\n    staticClass: \"el-icon-caret-bottom el-icon--right\"\n  })]), _vm._v(\" \"), _c('el-dropdown-menu', {\n    slot: \"dropdown\"\n  }, _vm._l((_vm.editorThemes), function(item, index) {\n    return _c('el-dropdown-item', {\n      key: index,\n      attrs: {\n        \"command\": item\n      }\n    }, [_vm._v(_vm._s(item) + \"\\n                \")])\n  }))], 1)], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"editor\"\n  }, [_c('codemirror', {\n    ref: \"myEditor\",\n    attrs: {\n      \"options\": _vm.editorOptions2\n    },\n    model: {\n      value: (_vm.code),\n      callback: function($$v) {\n        _vm.code = $$v\n      },\n      expression: \"code\"\n    }\n  })], 1), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"setup-btn\",\n    attrs: {\n      \"type\": \"success\"\n    },\n    domProps: {\n      \"textContent\": _vm._s(_vm.calcBtnText())\n    },\n    on: {\n      \"click\": _vm.clickBtn\n    }\n  })], 1)], 1)], 1)])])\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-49e52881\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/manager/manage-problem-edit.vue\n// module id = c2Vz\n// module chunks = 5","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".problem-edit .panel[data-v-49e52881]{border-radius:5px;margin-bottom:20px;background-color:#fff;border:1px solid #ddd;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.problem-edit .panel .panel-heading[data-v-49e52881]{padding:10px 15px;color:#333;background-color:#f5f5f5;border-color:#ddd;border-top-left-radius:5px;border-top-right-radius:5px;border-bottom:1px solid transparent}.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881]{color:#b0c4de}.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881]:hover{cursor:pointer}.problem-edit .panel .panel-heading .panel-title[data-v-49e52881]{display:inline-block;margin-left:5px;margin-top:0;margin-bottom:0;font-size:18px;color:inherit;font-weight:500;line-height:1.1}.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881]{float:right}.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881]:hover{cursor:pointer}.problem-edit .panel .panel-body[data-v-49e52881]{padding:15px 45px}.problem-edit .panel .panel-body .el-form .el-form-item[data-v-49e52881]{margin-right:10%}.problem-edit .panel .panel-body .el-form .el-form-item .program-edit[data-v-49e52881]{display:inline-block;width:83%;border:1px solid #ddd}.problem-edit .panel .panel-body .el-form .el-form-item .short-input[data-v-49e52881]{width:50%}.problem-edit .panel .panel-body .el-form .editor-wrapper[data-v-49e52881]{position:relative}.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper[data-v-49e52881]{position:absolute;top:0;left:0;display:inline-block}.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper .language-dropdown[data-v-49e52881]{margin-right:5px}.problem-edit .panel .panel-body .el-form .editor-wrapper .editor[data-v-49e52881]{margin-left:205px;display:inline-block;width:70%;border:1px solid #ddd}.problem-edit .panel .panel-body .el-form .editor-wrapper .editor .CodeMirror[data-v-49e52881]{height:330px}.problem-edit .panel .panel-body .el-form .editor-wrapper .setup-btn[data-v-49e52881]{position:relative;left:10px;bottom:10px}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/manager/manage-problem-edit.vue\"],\"names\":[],\"mappings\":\"AACA,sCACE,kBAAmB,AACnB,mBAAoB,AACpB,sBAAuB,AACvB,sBAAuB,AACvB,6CAA+C,AAC/C,oCAAuC,CACxC,AACD,qDACE,kBAAmB,AACnB,WAAY,AACZ,yBAA0B,AAC1B,kBAAmB,AACnB,2BAA4B,AAC5B,4BAA6B,AAC7B,mCAAqC,CACtC,AACD,yEACE,aAAe,CAChB,AACD,+EACE,cAAgB,CACjB,AACD,kEACE,qBAAsB,AACtB,gBAAiB,AACjB,aAAc,AACd,gBAAiB,AACjB,eAAgB,AAChB,cAAe,AACf,gBAAiB,AACjB,eAAiB,CAClB,AACD,+DACE,WAAa,CACd,AACD,qEACE,cAAgB,CACjB,AACD,kDACE,iBAAmB,CACpB,AACD,yEACE,gBAAkB,CACnB,AACD,uFACE,qBAAsB,AACtB,UAAW,AACX,qBAAuB,CACxB,AACD,sFACE,SAAW,CACZ,AACD,2EACE,iBAAmB,CACpB,AACD,6FACE,kBAAmB,AACnB,MAAO,AACP,OAAQ,AACR,oBAAsB,CACvB,AACD,gHACE,gBAAkB,CACnB,AACD,mFACE,kBAAmB,AACnB,qBAAsB,AACtB,UAAW,AACX,qBAAuB,CACxB,AACD,+FACE,YAAc,CACf,AACD,sFACE,kBAAmB,AACnB,UAAW,AACX,WAAa,CACd\",\"file\":\"manage-problem-edit.vue\",\"sourcesContent\":[\"\\n.problem-edit .panel[data-v-49e52881] {\\n  border-radius: 5px;\\n  margin-bottom: 20px;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n  -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.05);\\n  box-shadow: 0 1px 1px rgba(0,0,0,0.05);\\n}\\n.problem-edit .panel .panel-heading[data-v-49e52881] {\\n  padding: 10px 15px;\\n  color: #333;\\n  background-color: #f5f5f5;\\n  border-color: #ddd;\\n  border-top-left-radius: 5px;\\n  border-top-right-radius: 5px;\\n  border-bottom: 1px solid transparent;\\n}\\n.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881] {\\n  color: #b0c4de;\\n}\\n.problem-edit .panel .panel-heading .el-icon-arrow-left[data-v-49e52881]:hover {\\n  cursor: pointer;\\n}\\n.problem-edit .panel .panel-heading .panel-title[data-v-49e52881] {\\n  display: inline-block;\\n  margin-left: 5px;\\n  margin-top: 0;\\n  margin-bottom: 0;\\n  font-size: 18px;\\n  color: inherit;\\n  font-weight: 500;\\n  line-height: 1.1;\\n}\\n.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881] {\\n  float: right;\\n}\\n.problem-edit .panel .panel-heading .quit-tag[data-v-49e52881]:hover {\\n  cursor: pointer;\\n}\\n.problem-edit .panel .panel-body[data-v-49e52881] {\\n  padding: 15px 45px;\\n}\\n.problem-edit .panel .panel-body .el-form .el-form-item[data-v-49e52881] {\\n  margin-right: 10%;\\n}\\n.problem-edit .panel .panel-body .el-form .el-form-item .program-edit[data-v-49e52881] {\\n  display: inline-block;\\n  width: 83%;\\n  border: 1px solid #ddd;\\n}\\n.problem-edit .panel .panel-body .el-form .el-form-item .short-input[data-v-49e52881] {\\n  width: 50%;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper[data-v-49e52881] {\\n  position: relative;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper[data-v-49e52881] {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  display: inline-block;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .dropdown-wrapper .language-dropdown[data-v-49e52881] {\\n  margin-right: 5px;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .editor[data-v-49e52881] {\\n  margin-left: 205px;\\n  display: inline-block;\\n  width: 70%;\\n  border: 1px solid #ddd;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .editor .CodeMirror[data-v-49e52881] {\\n  height: 330px;\\n}\\n.problem-edit .panel .panel-body .el-form .editor-wrapper .setup-btn[data-v-49e52881] {\\n  position: relative;\\n  left: 10px;\\n  bottom: 10px;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-49e52881\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/manager/manage-problem-edit.vue\n// module id = drNd\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"markdown\", function(cm, start) {\n  var maxDepth = 100;\n\n  function isHeader(lineNo) {\n    var tokentype = cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0));\n    return tokentype && /\\bheader\\b/.test(tokentype);\n  }\n\n  function headerLevel(lineNo, line, nextLine) {\n    var match = line && line.match(/^#+/);\n    if (match && isHeader(lineNo)) return match[0].length;\n    match = nextLine && nextLine.match(/^[=\\-]+\\s*$/);\n    if (match && isHeader(lineNo + 1)) return nextLine[0] == \"=\" ? 1 : 2;\n    return maxDepth;\n  }\n\n  var firstLine = cm.getLine(start.line), nextLine = cm.getLine(start.line + 1);\n  var level = headerLevel(start.line, firstLine, nextLine);\n  if (level === maxDepth) return undefined;\n\n  var lastLineNo = cm.lastLine();\n  var end = start.line, nextNextLine = cm.getLine(end + 2);\n  while (end < lastLineNo) {\n    if (headerLevel(end + 1, nextLine, nextNextLine) <= level) break;\n    ++end;\n    nextLine = nextNextLine;\n    nextNextLine = cm.getLine(end + 2);\n  }\n\n  return {\n    from: CodeMirror.Pos(start.line, firstLine.length),\n    to: CodeMirror.Pos(end, cm.getLine(end).length)\n  };\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/markdown-fold.js\n// module id = dxBS\n// module chunks = 4 5","exports = module.exports = require(\"../../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".CodeMirror-foldmarker{color:blue;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\\\"\\\\25BE\\\"}.CodeMirror-foldgutter-folded:after{content:\\\"\\\\25B8\\\"}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/node_modules/codemirror/addon/fold/foldgutter.css\"],\"names\":[],\"mappings\":\"AAAA,uBACE,WAAY,AACZ,oFAAwF,AACxF,kBAAmB,AACnB,eAAgB,AAChB,cAAgB,CACjB,AACD,uBACE,UAAY,CACb,AACD,0DAEE,cAAgB,CACjB,AACD,kCACE,eAAiB,CAClB,AACD,oCACE,eAAiB,CAClB\",\"file\":\"foldgutter.css\",\"sourcesContent\":[\".CodeMirror-foldmarker {\\n  color: blue;\\n  text-shadow: #b9f 1px 1px 2px, #b9f -1px -1px 2px, #b9f 1px -1px 2px, #b9f -1px 1px 2px;\\n  font-family: arial;\\n  line-height: .3;\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter {\\n  width: .7em;\\n}\\n.CodeMirror-foldgutter-open,\\n.CodeMirror-foldgutter-folded {\\n  cursor: pointer;\\n}\\n.CodeMirror-foldgutter-open:after {\\n  content: \\\"\\\\25BE\\\";\\n}\\n.CodeMirror-foldgutter-folded:after {\\n  content: \\\"\\\\25B8\\\";\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/codemirror/addon/fold/foldgutter.css\n// module id = engA\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var startLine = start.line, has = hasImport(startLine), prev;\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var startLine = start.line, has = hasInclude(startLine);\n  if (has == null || hasInclude(startLine - 1) != null) return null;\n  for (var end = startLine;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(startLine, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/brace-fold.js\n// module id = fo6W\n// module chunks = 4 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-49e52881\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./manage-problem-edit.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"aa779c20\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-49e52881\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/manager/manage-problem-edit.vue\n// module id = hdeF\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    var self = this;\n    cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      this.cm.off(\"cursorActivity\", this.activityFunc);\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i];\n      if (completion.hint) completion.hint(this.cm, data, completion);\n      else this.cm.replaceRange(getText(completion), completion.from || data.from,\n                                completion.to || data.to, \"complete\");\n      CodeMirror.signal(data, \"pick\", completion);\n      this.close();\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||\n          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      if (data && this.data && isNewCompletion(this.data, data)) return;\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function isNewCompletion(old, nw) {\n    var moved = CodeMirror.cmpPos(nw.from, old.from)\n    return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch\n  }\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n\n    var hints = this.hints = document.createElement(\"ul\");\n    hints.className = \"CodeMirror-hints\";\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    hints.style.left = left + \"px\";\n    hints.style.top = top + \"px\";\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n    (completion.options.container || document.body).appendChild(hints);\n    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n    var scrolls = hints.scrollHeight > hints.clientHeight + 1\n    var startScroll = cm.getScrollInfo();\n\n    if (overlapY > 0) {\n      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n      if (curTop - height > 0) { // Fits above cursor\n        hints.style.top = (top = pos.top - height) + \"px\";\n        below = false;\n      } else if (height > winH) {\n        hints.style.height = (winH - 5) + \"px\";\n        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n        var cursor = cm.getCursor();\n        if (data.from.ch != cursor.ch) {\n          pos = cm.cursorCoords(cursor);\n          hints.style.left = (left = pos.left) + \"px\";\n          box = hints.getBoundingClientRect();\n        }\n      }\n    }\n    var overlapX = box.right - winW;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = pos.left - overlapX) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      if (node.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node.offsetTop - 3;\n      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    var to = CodeMirror.Pos(cur.line, token.end);\n    if (token.string && /\\w/.test(token.string[token.string.length - 1])) {\n      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);\n    } else {\n      var term = \"\", from = to;\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnUnfocus: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/hint/show-hint.js\n// module id = jQeI\n// module chunks = 4 5","<template>\n  <div class=\"manage-problem\">\n    <confirm :text=\"confirmText\" @confirm=\"confirmDele\" ref=\"confirm\"></confirm>\n    <transition name=\"el-fade-in-linear\">\n      <div v-show=\"!isShowEdit\">\n        <div class=\"handle-box\">\n          <el-button-group>\n            <el-button type=\"primary\" @click.stop=\"showSetupProblem\">创建题目</el-button>\n            <el-button type=\"success\" @click.stop=\"refreshProblems\">刷新数据</el-button>\n          </el-button-group>\n          <div class=\"search-wrapper\">\n            <search></search>\n          </div>\n        </div>\n        <el-table :data=\"problemDatas\" border ref=\"multipleTable\" style=\"width: 80%\"\n                  @selection-change=\"handleSelectionChange\">\n          <el-table-column type=\"selection\" width=\"55\"></el-table-column>\n          <el-table-column prop=\"id\" label=\"ID\" width=\"150\">\n          </el-table-column>\n          <el-table-column prop=\"title\" label=\"标题\" sortable width=\"350\">\n          </el-table-column>\n          <el-table-column prop=\"tag\" label=\"标签\" sortable width=\"250\" :formatter=\"calcTag\">\n          </el-table-column>\n          <el-table-column prop=\"level\" label=\"难度\" sortable width=\"100\">\n          </el-table-column>\n          <el-table-column prop=\"submitted\" label=\"提交数\" sortable width=\"100\">\n          </el-table-column>\n          <el-table-column prop=\"accepted\" label=\"通过数\" sortable width=\"100\">\n          </el-table-column>\n          <el-table-column label=\"操作\" width=\"150\" fixed=\"right\">\n            <template scope=\"scope\">\n              <el-button size=\"small\"\n                         @click.stop=\"handleEdit(scope.$index, scope.row)\">编辑\n              </el-button>\n              <el-button size=\"small\" type=\"danger\"\n                         @click.stop=\"handleDelete(scope.$index, scope.row)\">删除\n              </el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n        <div class=\"pagination\">\n          <el-pagination\n            @current-change=\"handleCurrentChange\"\n            layout=\"prev, pager, next\"\n            :current-page=\"cur_page\"\n            :total=\"100\">\n          </el-pagination>\n        </div>\n      </div>\n    </transition>\n    <transition name=\"el-fade-in-linear\">\n      <problem-edit v-show=\"isShowEdit\" :isEdit=\"isEdit\"\n                    @editFinish=\"hideEdit\" ref=\"problemEdit\"></problem-edit>\n    </transition>\n  </div>\n</template>\n\n<script type=\"text/ecmascript-6\">\n  import { baseUrl, MSG_OK, MSG_NO, editorThemes } from 'common/js/data'\n  import axios from 'axios'\n  import ElFormItem from '../../../node_modules/element-ui/packages/form/src/form-item'\n  import Search from 'components/search/search'\n  import ProblemEdit from 'components/manager/manage-problem-edit'\n  import { mapActions } from 'vuex'\n  import Problem from 'common/js/problem'\n  import Confirm from 'base/confirm/confirm'\n\n  export default{\n    data(){\n      return {\n        problemDatas: [],\n        cur_page: 1,\n        multipleSelection: [],\n        select_cate: '',\n        select_word: '',\n        del_list: [],\n        is_search: false,\n        rules: {\n          id: [\n            {required: true, message: 'id不能为空', trigger: 'blur'},\n            {min: 3, max: 3, message: 'id为3位字母', trigger: 'blur'}\n          ],\n          title: [\n            {required: true, message: '标题不能为空', trigger: 'blur'},\n            {min: 5, message: '标题过短', trigger: 'blur'}\n          ],\n          description: [\n            {required: true, message: '描述不能为空', trigger: 'blur'},\n            {min: 5, message: '描述过短', trigger: 'blur'}\n          ]\n        },\n        isShowEdit: false,  //是否展示编辑页面\n        isEdit: false,  //false新建题目 true编辑题目\n        confirmText: '',\n        curProblemId: '',\n        curProblemTitle: '',\n        editorThemes: editorThemes,\n        selectTheme: editorThemes[0]\n      }\n    },\n    created(){\n      this._getProblemsData(this.cur_page)\n    },\n    methods: {\n      showSetupProblem(){\n        this.isEdit = false\n        this.isShowEdit = true\n      },\n      handleCurrentChange(val){\n        this.cur_page = val\n        this._getProblemsData(this.cur_page)\n      },\n      _getProblemsData(curPage){\n        let url = `${baseUrl}/problems?page=${curPage}`\n        axios.get(url).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this.problemDatas = response.data.result\n          }\n        }, response => {})\n      },\n      formatter(row, column){\n        return row.address\n      },\n      filterTag(value, row){\n        return row.tag === value\n      },\n      handleEdit(index, row){\n        //点击编辑按钮\n        console.log(row)\n        this.saveOneProblem(new Problem(row))\n        this.isEdit = true\n        this.isShowEdit = true\n        this.$refs.problemEdit.showPromblemInfo()\n      },\n      handleDelete(index, row){\n        //点击删除按钮\n        this.curProblemId = row.id\n        this.curProblemTitle = row.title\n        this.confirmText = `确定要删除题目 “${this.curProblemTitle}”吗?`\n        this.$refs.confirm.show()\n      },\n      confirmDele(){\n        //确认删除\n        let url = `${baseUrl}/problems/${this.curProblemId}`\n        axios.delete(url).then(response => {\n          if (response.data.msg === MSG_OK) {\n            this._getProblemsData(this.cur_page)\n            this.$message({\n              message: `成功删除题目:${this.curProblemTitle}`,\n              type: 'success'\n            })\n          } else if (response.data.msg === MSG_NO) {\n            this.$notify.error({\n              title: '无法删除',\n              message: `${response.data.error}`\n            })\n          }\n        }, response => {\n          this.$message.error(`无法删除题目${this.curProblemTitle}`)\n        })\n      },\n      delAll(){\n        const self = this,\n          length = self.multipleSelection.length\n        let str = ''\n        self.del_list = self.del_list.concat(self.multipleSelection)\n        for (let i = 0; i < length; i++) {\n          str += self.multipleSelection[i].name + ' '\n        }\n        self.$message.error('删除了' + str)\n        self.multipleSelection = []\n      },\n      calcTag(row, column, cellValue) {\n        if (cellValue === '') {\n          return 'Nothing'\n        }\n        return cellValue.replace(',', ' & ')\n      },\n      handleSelectionChange(val){\n        this.multipleSelection = val\n      },\n      hideEdit(){\n        // 隐藏编辑页面\n        this.isShowEdit = false\n        this._getProblemsData(this.cur_page)\n      },\n      refreshProblems(){\n        //刷新manage-problems界面\n        this.cur_page = 1\n        this._getProblemsData(this.cur_page)\n      },\n      ...mapActions([\n        'saveOneProblem'\n      ])\n    },\n    computed: {\n      data(){\n        const self = this\n        return self.contestDatas.filter(function (d) {\n          let is_del = false\n          for (let i = 0; i < self.del_list.length; i++) {\n            if (d.name === self.del_list[i].name) {\n              is_del = true\n              break\n            }\n          }\n          if (!is_del) {\n            if (d.address.indexOf(self.select_cate) > -1 &&\n              (d.name.indexOf(self.select_word) > -1 ||\n              d.address.indexOf(self.select_word) > -1)\n            ) {\n              return d\n            }\n          }\n        })\n      }\n    },\n    components: {\n      ElFormItem,\n      Search,\n      ProblemEdit,\n      Confirm\n    }\n  }\n</script>\n\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n  .manage-problem\n    .el-dialog\n      .block\n        .el-date-editor\n          width 100%\n    .handle-box\n      margin-bottom 15px\n      width 80%\n      .el-button-group\n        .el-button\n          width 100px\n      .search-wrapper\n        float right\n\n  .pagination\n    margin: 20px 20% 0 0;\n    text-align: right;\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/manager/manage-problems.vue?1782c4d0","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/json/stringify.js\n// module id = mvHQ\n// module chunks = 2 3 5","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"manage-problem\"\n  }, [_c('confirm', {\n    ref: \"confirm\",\n    attrs: {\n      \"text\": _vm.confirmText\n    },\n    on: {\n      \"confirm\": _vm.confirmDele\n    }\n  }), _vm._v(\" \"), _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in-linear\"\n    }\n  }, [_c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.isShowEdit),\n      expression: \"!isShowEdit\"\n    }]\n  }, [_c('div', {\n    staticClass: \"handle-box\"\n  }, [_c('el-button-group', [_c('el-button', {\n    attrs: {\n      \"type\": \"primary\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.showSetupProblem($event)\n      }\n    }\n  }, [_vm._v(\"创建题目\")]), _vm._v(\" \"), _c('el-button', {\n    attrs: {\n      \"type\": \"success\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.stopPropagation();\n        _vm.refreshProblems($event)\n      }\n    }\n  }, [_vm._v(\"刷新数据\")])], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"search-wrapper\"\n  }, [_c('search')], 1)], 1), _vm._v(\" \"), _c('el-table', {\n    ref: \"multipleTable\",\n    staticStyle: {\n      \"width\": \"80%\"\n    },\n    attrs: {\n      \"data\": _vm.problemDatas,\n      \"border\": \"\"\n    },\n    on: {\n      \"selection-change\": _vm.handleSelectionChange\n    }\n  }, [_c('el-table-column', {\n    attrs: {\n      \"type\": \"selection\",\n      \"width\": \"55\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"id\",\n      \"label\": \"ID\",\n      \"width\": \"150\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"title\",\n      \"label\": \"标题\",\n      \"sortable\": \"\",\n      \"width\": \"350\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"tag\",\n      \"label\": \"标签\",\n      \"sortable\": \"\",\n      \"width\": \"250\",\n      \"formatter\": _vm.calcTag\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"level\",\n      \"label\": \"难度\",\n      \"sortable\": \"\",\n      \"width\": \"100\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"submitted\",\n      \"label\": \"提交数\",\n      \"sortable\": \"\",\n      \"width\": \"100\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"prop\": \"accepted\",\n      \"label\": \"通过数\",\n      \"sortable\": \"\",\n      \"width\": \"100\"\n    }\n  }), _vm._v(\" \"), _c('el-table-column', {\n    attrs: {\n      \"label\": \"操作\",\n      \"width\": \"150\",\n      \"fixed\": \"right\"\n    },\n    scopedSlots: _vm._u([{\n      key: \"default\",\n      fn: function(scope) {\n        return [_c('el-button', {\n          attrs: {\n            \"size\": \"small\"\n          },\n          on: {\n            \"click\": function($event) {\n              $event.stopPropagation();\n              _vm.handleEdit(scope.$index, scope.row)\n            }\n          }\n        }, [_vm._v(\"编辑\\n            \")]), _vm._v(\" \"), _c('el-button', {\n          attrs: {\n            \"size\": \"small\",\n            \"type\": \"danger\"\n          },\n          on: {\n            \"click\": function($event) {\n              $event.stopPropagation();\n              _vm.handleDelete(scope.$index, scope.row)\n            }\n          }\n        }, [_vm._v(\"删除\\n            \")])]\n      }\n    }])\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"pagination\"\n  }, [_c('el-pagination', {\n    attrs: {\n      \"layout\": \"prev, pager, next\",\n      \"current-page\": _vm.cur_page,\n      \"total\": 100\n    },\n    on: {\n      \"current-change\": _vm.handleCurrentChange\n    }\n  })], 1)], 1)]), _vm._v(\" \"), _c('transition', {\n    attrs: {\n      \"name\": \"el-fade-in-linear\"\n    }\n  }, [_c('problem-edit', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.isShowEdit),\n      expression: \"isShowEdit\"\n    }],\n    ref: \"problemEdit\",\n    attrs: {\n      \"isEdit\": _vm.isEdit\n    },\n    on: {\n      \"editFinish\": _vm.hideEdit\n    }\n  })], 1)], 1)\n}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-1ffcf786\",\"hasScoped\":true,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/manager/manage-problems.vue\n// module id = oxMS\n// module chunks = 5","var core = require('../../modules/_core');\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/json/stringify.js\n// module id = qkKv\n// module chunks = 2 3 5","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".manage-problem .el-dialog .block .el-date-editor[data-v-1ffcf786]{width:100%}.manage-problem .handle-box[data-v-1ffcf786]{margin-bottom:15px;width:80%}.manage-problem .handle-box .el-button-group .el-button[data-v-1ffcf786]{width:100px}.manage-problem .handle-box .search-wrapper[data-v-1ffcf786]{float:right}.pagination[data-v-1ffcf786]{margin:20px 20% 0 0;text-align:right}\", \"\", {\"version\":3,\"sources\":[\"E:/前端/bootstrap学习/codeproject/src/components/manager/manage-problems.vue\"],\"names\":[],\"mappings\":\"AACA,mEACE,UAAY,CACb,AACD,6CACE,mBAAoB,AACpB,SAAW,CACZ,AACD,yEACE,WAAa,CACd,AACD,6DACE,WAAa,CACd,AACD,6BACE,oBAAqB,AACrB,gBAAkB,CACnB\",\"file\":\"manage-problems.vue\",\"sourcesContent\":[\"\\n.manage-problem .el-dialog .block .el-date-editor[data-v-1ffcf786] {\\n  width: 100%;\\n}\\n.manage-problem .handle-box[data-v-1ffcf786] {\\n  margin-bottom: 15px;\\n  width: 80%;\\n}\\n.manage-problem .handle-box .el-button-group .el-button[data-v-1ffcf786] {\\n  width: 100px;\\n}\\n.manage-problem .handle-box .search-wrapper[data-v-1ffcf786] {\\n  float: right;\\n}\\n.pagination[data-v-1ffcf786] {\\n  margin: 20px 20% 0 0;\\n  text-align: right;\\n}\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-1ffcf786\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/manager/manage-problems.vue\n// module id = qm6i\n// module chunks = 5","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = sOR5\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerGlobalHelper(\"fold\", \"comment\", function(mode) {\n  return mode.blockCommentStart && mode.blockCommentEnd;\n}, function(cm, start) {\n  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;\n  if (!startToken || !endToken) return;\n  var line = start.line, lineText = cm.getLine(line);\n\n  var startCh;\n  for (var at = start.ch, pass = 0;;) {\n    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);\n    if (found == -1) {\n      if (pass == 1) return;\n      pass = 1;\n      at = lineText.length;\n      continue;\n    }\n    if (pass == 1 && found < start.ch) return;\n    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&\n        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||\n         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {\n      startCh = found + startToken.length;\n      break;\n    }\n    at = found - 1;\n  }\n\n  var depth = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (pos == nextOpen) ++depth;\n      else if (!--depth) { end = i; endCh = pos; break outer; }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/fold/comment-fold.js\n// module id = soCA\n// module chunks = 4 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  function kill(cm, from, to, mayGrow, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (mayGrow) lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      kill(cm, cursor, findEnd(cm, cursor, by, dir), true);\n    }\n  }\n\n  function killRegion(cm) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        kill(cm, selection.anchor, selection.head);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  function setMark(cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(msg + \": <input type=\\\"text\\\" style=\\\"width: 10em\\\"/>\", f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  function quit(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  CodeMirror.emacs = {kill: kill, killRegion: killRegion, repeated: repeated};\n\n  // Actual keymap\n\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": function(cm) {kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"));},\n    \"Ctrl-K\": repeated(function(cm) {\n      var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n      var text = cm.getRange(start, end);\n      if (!/\\S/.test(text)) {\n        text += \"\\n\";\n        end = Pos(start.line + 1, 0);\n      }\n      kill(cm, start, end, true, text);\n    }),\n    \"Alt-W\": function(cm) {\n      addToRing(cm.getSelection());\n      clearMark(cm);\n    },\n    \"Ctrl-Y\": function(cm) {\n      var start = cm.getCursor();\n      cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n      cm.setSelection(start, cm.getCursor());\n    },\n    \"Alt-Y\": function(cm) {cm.replaceSelection(popFromRing(), \"around\", \"paste\");},\n\n    \"Ctrl-Space\": setMark, \"Ctrl-Shift-2\": setMark,\n\n    \"Ctrl-F\": move(byChar, 1), \"Ctrl-B\": move(byChar, -1),\n    \"Right\": move(byChar, 1), \"Left\": move(byChar, -1),\n    \"Ctrl-D\": function(cm) { killTo(cm, byChar, 1); },\n    \"Delete\": function(cm) { killRegion(cm) || killTo(cm, byChar, 1); },\n    \"Ctrl-H\": function(cm) { killTo(cm, byChar, -1); },\n    \"Backspace\": function(cm) { killRegion(cm) || killTo(cm, byChar, -1); },\n\n    \"Alt-F\": move(byWord, 1), \"Alt-B\": move(byWord, -1),\n    \"Alt-D\": function(cm) { killTo(cm, byWord, 1); },\n    \"Alt-Backspace\": function(cm) { killTo(cm, byWord, -1); },\n\n    \"Ctrl-N\": move(byLine, 1), \"Ctrl-P\": move(byLine, -1),\n    \"Down\": move(byLine, 1), \"Up\": move(byLine, -1),\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStart\",\n\n    \"Alt-V\": move(byPage, -1), \"Ctrl-V\": move(byPage, 1),\n    \"PageUp\": move(byPage, -1), \"PageDown\": move(byPage, 1),\n\n    \"Ctrl-Up\": move(byParagraph, -1), \"Ctrl-Down\": move(byParagraph, 1),\n\n    \"Alt-A\": move(bySentence, -1), \"Alt-E\": move(bySentence, 1),\n    \"Alt-K\": function(cm) { killTo(cm, bySentence, 1); },\n\n    \"Ctrl-Alt-K\": function(cm) { killTo(cm, byExpr, 1); },\n    \"Ctrl-Alt-Backspace\": function(cm) { killTo(cm, byExpr, -1); },\n    \"Ctrl-Alt-F\": move(byExpr, 1), \"Ctrl-Alt-B\": move(byExpr, -1),\n\n    \"Shift-Ctrl-Alt-2\": function(cm) {\n      var cursor = cm.getCursor();\n      cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n    },\n    \"Ctrl-Alt-T\": function(cm) {\n      var leftStart = byExpr(cm, cm.getCursor(), -1), leftEnd = byExpr(cm, leftStart, 1);\n      var rightEnd = byExpr(cm, leftEnd, 1), rightStart = byExpr(cm, rightEnd, -1);\n      cm.replaceRange(cm.getRange(rightStart, rightEnd) + cm.getRange(leftEnd, rightStart) +\n                      cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n    },\n    \"Ctrl-Alt-U\": repeated(toEnclosingExpr),\n\n    \"Alt-Space\": function(cm) {\n      var pos = cm.getCursor(), from = pos.ch, to = pos.ch, text = cm.getLine(pos.line);\n      while (from && /\\s/.test(text.charAt(from - 1))) --from;\n      while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n      cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n    },\n    \"Ctrl-O\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"start\"); }),\n    \"Ctrl-T\": repeated(function(cm) {\n      cm.execCommand(\"transposeChars\");\n    }),\n\n    \"Alt-C\": repeated(function(cm) {\n      operateOnWord(cm, function(w) {\n        var letter = w.search(/\\w/);\n        if (letter == -1) return w;\n        return w.slice(0, letter) + w.charAt(letter).toUpperCase() + w.slice(letter + 1).toLowerCase();\n      });\n    }),\n    \"Alt-U\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toUpperCase(); });\n    }),\n    \"Alt-L\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toLowerCase(); });\n    }),\n\n    \"Alt-;\": \"toggleComment\",\n\n    \"Ctrl-/\": repeated(\"undo\"), \"Shift-Ctrl--\": repeated(\"undo\"),\n    \"Ctrl-Z\": repeated(\"undo\"), \"Cmd-Z\": repeated(\"undo\"),\n    \"Shift-Alt-,\": \"goDocStart\", \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\", \"Ctrl-R\": \"findPersistentPrev\", \"Ctrl-G\": quit, \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); }),\n    \"Tab\": \"indentAuto\",\n\n    \"Alt-G G\": function(cm) {\n      var prefix = getPrefix(cm, true);\n      if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n      getInput(cm, \"Goto line\", function(str) {\n        var num;\n        if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n          cm.setCursor(num - 1);\n      });\n    },\n\n    \"Ctrl-X Tab\": function(cm) {\n      cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n    },\n    \"Ctrl-X Ctrl-X\": function(cm) {\n      cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n    },\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X U\": repeated(\"undo\"),\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X Delete\": function(cm) { kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), true); },\n    \"Ctrl-X H\": \"selectAll\",\n\n    \"Ctrl-Q Tab\": repeated(\"insertTab\"),\n    \"Ctrl-U\": addPrefixMap\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/keymap/emacs.js\n// module id = tjx/\n// module chunks = 4 5","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = ujcs\n// module chunks = 5","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && matching[line.text.charAt(pos)]) ||\n        matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/addon/edit/matchbrackets.js\n// module id = vq+x\n// module chunks = 4 5","/*\n * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n */\n\n(function(global) {\n    'use strict';\n    // existing version for noConflict()\n    var _Base64 = global.Base64;\n    var version = \"2.3.2\";\n    // if node.js, we use Buffer\n    var buffer;\n    if (typeof module !== 'undefined' && module.exports) {\n        try {\n            buffer = require('buffer').Buffer;\n        } catch (err) {}\n    }\n    // constants\n    var b64chars\n        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var b64tab = function(bin) {\n        var t = {};\n        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n        return t;\n    }(b64chars);\n    var fromCharCode = String.fromCharCode;\n    // encoder stuff\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n                                + fromCharCode(0x80 | (cc & 0x3f)))\n                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n        } else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    var cb_encode = function(ccc) {\n        var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16\n            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n        chars = [\n            b64chars.charAt( ord >>> 18),\n            b64chars.charAt((ord >>> 12) & 63),\n            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n        ];\n        return chars.join('');\n    };\n    var btoa = global.btoa ? function(b) {\n        return global.btoa(b);\n    } : function(b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n    var _encode = buffer ?\n        buffer.from && buffer.from !== Uint8Array.from ? function (u) {\n            return (u.constructor === buffer.constructor ? u : buffer.from(u))\n                .toString('base64')\n        }\n        :  function (u) {\n            return (u.constructor === buffer.constructor ? u : new  buffer(u))\n                .toString('base64')\n        }\n        : function (u) { return btoa(utob(u)) }\n    ;\n    var encode = function(u, urisafe) {\n        return !urisafe\n            ? _encode(String(u))\n            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n                return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n    };\n    var encodeURI = function(u) { return encode(u, true) };\n    // decoder stuff\n    var re_btou = new RegExp([\n        '[\\xC0-\\xDF][\\x80-\\xBF]',\n        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n    ].join('|'), 'g');\n    var cb_btou = function(cccc) {\n        switch(cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n                |     (0x3f & cccc.charCodeAt(3)),\n            offset = cp - 0x10000;\n            return (fromCharCode((offset  >>> 10) + 0xD800)\n                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return fromCharCode(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    |  (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return  fromCharCode(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                    |  (0x3f & cccc.charCodeAt(1))\n            );\n        }\n    };\n    var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    var cb_decode = function(cccc) {\n        var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n        chars = [\n            fromCharCode( n >>> 16),\n            fromCharCode((n >>>  8) & 0xff),\n            fromCharCode( n         & 0xff)\n        ];\n        chars.length -= [0, 0, 2, 1][padlen];\n        return chars.join('');\n    };\n    var atob = global.atob ? function(a) {\n        return global.atob(a);\n    } : function(a){\n        return a.replace(/[\\s\\S]{1,4}/g, cb_decode);\n    };\n    var _decode = buffer ?\n        buffer.from && buffer.from !== Uint8Array.from ? function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : buffer.from(a, 'base64')).toString();\n        }\n        : function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : new buffer(a, 'base64')).toString();\n        }\n        : function(a) { return btou(atob(a)) };\n    var decode = function(a){\n        return _decode(\n            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n        );\n    };\n    var noConflict = function() {\n        var Base64 = global.Base64;\n        global.Base64 = _Base64;\n        return Base64;\n    };\n    // export Base64\n    global.Base64 = {\n        VERSION: version,\n        atob: atob,\n        btoa: btoa,\n        fromBase64: decode,\n        toBase64: encode,\n        utob: utob,\n        encode: encode,\n        encodeURI: encodeURI,\n        btou: btou,\n        decode: decode,\n        noConflict: noConflict\n    };\n    // if ES5 is available, make Base64.extendString() available\n    if (typeof Object.defineProperty === 'function') {\n        var noEnum = function(v){\n            return {value:v,enumerable:false,writable:true,configurable:true};\n        };\n        global.Base64.extendString = function () {\n            Object.defineProperty(\n                String.prototype, 'fromBase64', noEnum(function () {\n                    return decode(this)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64', noEnum(function (urisafe) {\n                    return encode(this, urisafe)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64URI', noEnum(function () {\n                    return encode(this, true)\n                }));\n        };\n    }\n    //\n    // export Base64 to the namespace\n    //\n    if (global['Meteor']) { // Meteor.js\n        Base64 = global.Base64;\n    }\n    // module.exports and AMD are mutually exclusive.\n    // module.exports has precedence.\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports.Base64 = global.Base64;\n    }\n    else if (typeof define === 'function' && define.amd) {\t\t\n        // AMD. Register as an anonymous module.\t\n        define([], function(){ return global.Base64 });\n    }\n    // that's it!\n})(   typeof self   !== 'undefined' ? self\n    : typeof window !== 'undefined' ? window\n    : typeof global !== 'undefined' ? global\n    : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/js-base64/base64.js\n// module id = xrTZ\n// module chunks = 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-2d96e4b2\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/stylus-loader/index.js?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./search.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"56e4b5b6\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-2d96e4b2\",\"scoped\":true,\"hasInlineConfig\":false}!./~/stylus-loader?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/search/search.vue\n// module id = yGpH\n// module chunks = 2 5"],"sourceRoot":""}